package com.smart.rct.migration.serviceImpl;

import java.io.BufferedReader;
import java.io.BufferedWriter;
import java.io.File;
import java.io.FileInputStream;
import java.io.FileNotFoundException;
import java.io.FileOutputStream;
import java.io.FileReader;
import java.io.FileWriter;
import java.io.IOException;
import java.io.InputStreamReader;
import java.io.OutputStream;
import java.io.OutputStreamWriter;
import java.io.StringReader;
import java.io.Writer;
import java.nio.charset.StandardCharsets;
import java.nio.file.Files;
import java.nio.file.Paths;
import java.security.KeyManagementException;
import java.security.KeyStoreException;
import java.security.NoSuchAlgorithmException;
import java.sql.Timestamp;
import java.text.DateFormat;
import java.text.SimpleDateFormat;
import java.time.Duration;
import java.time.LocalDateTime;
import java.time.LocalTime;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Base64;
import java.util.Collections;
import java.util.Comparator;
import java.util.Date;
import java.util.HashMap;
import java.util.Iterator;
import java.util.LinkedHashMap;
import java.util.LinkedHashSet;
import java.util.LinkedList;
import java.util.List;
import java.util.Map;
import java.util.Objects;
import java.util.Map.Entry;
import java.util.Set;
import java.util.TreeMap;
import java.util.TreeSet;
import java.util.concurrent.ConcurrentHashMap;
import java.util.concurrent.ConcurrentLinkedQueue;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;
import java.util.concurrent.atomic.AtomicBoolean;
import java.util.concurrent.atomic.AtomicInteger;
import java.util.regex.Pattern;
import java.util.stream.Collectors;

import javax.net.ssl.SSLContext;
import javax.persistence.EntityManager;
import javax.persistence.PersistenceContext;
import javax.xml.parsers.DocumentBuilder;
import javax.xml.parsers.DocumentBuilderFactory;

import org.apache.commons.io.FileUtils;
import org.apache.commons.io.FilenameUtils;
import org.apache.commons.lang.StringUtils;
import org.apache.commons.lang.exception.ExceptionUtils;
import org.apache.commons.lang.math.NumberUtils;
import org.apache.http.config.Registry;
import org.apache.http.config.RegistryBuilder;
import org.apache.http.conn.socket.ConnectionSocketFactory;
import org.apache.http.conn.socket.PlainConnectionSocketFactory;
import org.apache.http.conn.ssl.NoopHostnameVerifier;
import org.apache.http.conn.ssl.SSLConnectionSocketFactory;
import org.apache.http.conn.ssl.SSLContexts;
import org.apache.http.conn.ssl.TrustStrategy;
import org.apache.http.impl.client.CloseableHttpClient;
import org.apache.http.impl.client.HttpClients;
import org.apache.http.impl.conn.BasicHttpClientConnectionManager;
import org.codehaus.jackson.map.ObjectMapper;
import org.codehaus.jackson.type.TypeReference;
import org.json.simple.JSONArray;
import org.json.simple.JSONObject;
import org.json.simple.parser.JSONParser;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.core.io.FileSystemResource;
import org.springframework.data.mongodb.core.MongoTemplate;
import org.springframework.data.mongodb.core.query.Criteria;
import org.springframework.data.mongodb.core.query.Query;
import org.springframework.http.HttpEntity;
import org.springframework.http.HttpHeaders;
import org.springframework.http.HttpMethod;
import org.springframework.http.MediaType;
import org.springframework.http.ResponseEntity;
import org.springframework.http.client.BufferingClientHttpRequestFactory;
import org.springframework.http.client.ClientHttpRequestInterceptor;
import org.springframework.http.client.HttpComponentsClientHttpRequestFactory;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;
import org.springframework.util.LinkedMultiValueMap;
import org.springframework.util.MultiValueMap;
import org.springframework.util.ObjectUtils;
import org.springframework.web.client.HttpClientErrorException;
import org.springframework.web.client.HttpServerErrorException;
import org.springframework.web.client.RestTemplate;
import org.springframework.web.util.UriComponentsBuilder;
import org.w3c.dom.Document;
import org.w3c.dom.Element;
import org.w3c.dom.Node;
import org.w3c.dom.NodeList;
import org.xml.sax.InputSource;

import com.google.gson.JsonObject;
import com.smart.rct.common.entity.CustomerDetailsEntity;
import com.smart.rct.common.entity.GrowConstantsEntity;
import com.smart.rct.common.entity.LsmEntity;
import com.smart.rct.common.entity.NetworkConfigDetailsEntity;
import com.smart.rct.common.entity.NetworkConfigEntity;
import com.smart.rct.common.entity.NetworkTypeDetailsEntity;
import com.smart.rct.common.entity.OvGeneralEntity;
import com.smart.rct.common.entity.OvScheduledEntity;
import com.smart.rct.common.entity.ProgramTemplateEntity;
import com.smart.rct.common.entity.ReportsEntity;
import com.smart.rct.common.entity.RunTestInputEntity;
import com.smart.rct.common.entity.WorkFlowManagementEntity;
import com.smart.rct.common.models.CiqMapValuesModel;
import com.smart.rct.common.models.DependentRuleValidationModel;
import com.smart.rct.common.models.NetworkTypeDetailsModel;
import com.smart.rct.common.models.OvAutomationModel;
import com.smart.rct.common.models.ProgramTemplateModel;
import com.smart.rct.common.models.TrackerDetailsModel;
import com.smart.rct.common.repository.CustomerRepository;
import com.smart.rct.common.repositoryImpl.LsmRepositoryImpl;
import com.smart.rct.common.repositoryImpl.NetworkTypeDetailsRepositoryImpl;
import com.smart.rct.common.service.CustomerService;
import com.smart.rct.common.service.DuoGeneralConfigService;
import com.smart.rct.common.service.NetworkConfigService;
import com.smart.rct.common.service.OvScheduledTaskService;
import com.smart.rct.constants.AuditConstants;
import com.smart.rct.constants.Constants;
import com.smart.rct.constants.FaultCodes;
import com.smart.rct.constants.XmlCommandsConstants;
import com.smart.rct.duosocket.SocketSession;
import com.smart.rct.exception.RctException;
import com.smart.rct.interceptor.GlobalInitializerListener;
import com.smart.rct.migration.entity.CmdRuleBuilderEntity;
import com.smart.rct.migration.entity.FileRuleBuilderEntity;
import com.smart.rct.migration.entity.OvTestResultEntity;
import com.smart.rct.migration.entity.PrePostMapping;
import com.smart.rct.migration.entity.RunTestEntity;
import com.smart.rct.migration.entity.RunTestResultEntity;
import com.smart.rct.migration.entity.ShellCmdRuleBuilderEntity;
import com.smart.rct.migration.entity.ShellCommandEntity;
import com.smart.rct.migration.entity.UploadFileEntity;
import com.smart.rct.migration.entity.UseCaseBuilderEntity;
import com.smart.rct.migration.entity.UseCaseBuilderParamEntity;
import com.smart.rct.migration.entity.UseCaseCmdRuleEntity;
import com.smart.rct.migration.entity.UseCaseFileRuleEntity;
import com.smart.rct.migration.entity.UseCaseShellRuleEntity;
import com.smart.rct.migration.entity.UseCaseXmlRuleEntity;
import com.smart.rct.migration.entity.XmlElementEntity;
import com.smart.rct.migration.entity.XmlRootEntity;
import com.smart.rct.migration.entity.XmlRuleBuilderEntity;
import com.smart.rct.migration.model.RunTestModel;
import com.smart.rct.migration.model.WorkFlowManagementModel;
import com.smart.rct.migration.repository.PrePostRepository;
import com.smart.rct.migration.repository.RunTestRepository;
import com.smart.rct.migration.repository.RunTestResultRepository;
import com.smart.rct.migration.repository.UploadFileRepository;
import com.smart.rct.migration.repository.UseCaseBuilderRepository;
import com.smart.rct.migration.repository.WorkFlowManagementRepository;
import com.smart.rct.migration.repository.XmlRuleBuilderRepository;
import com.smart.rct.migration.repositoryImpl.UseCaseBuilderRepositoryImpl;
import com.smart.rct.migration.service.RunTestService;
import com.smart.rct.migration.service.UseCaseBuilderService;
import com.smart.rct.postmigration.entity.Audit4GFsuSummaryEntity;
import com.smart.rct.postmigration.entity.Audit4GSummaryEntity;
import com.smart.rct.postmigration.entity.Audit5GCBandSummaryEntity;
import com.smart.rct.postmigration.entity.Audit5GDSSSummaryEntity;
import com.smart.rct.postmigration.entity.AuditConstantsEntity;
import com.smart.rct.postmigration.repository.AuditConstantsRepository;
import com.smart.rct.postmigration.repository.ReportsRepository;
import com.smart.rct.postmigration.service.Audit4GFsuIssueService;
import com.smart.rct.postmigration.service.Audit4GFsuSummaryService;
import com.smart.rct.postmigration.service.Audit4GIssueService;
import com.smart.rct.postmigration.service.Audit4GSummaryService;
import com.smart.rct.postmigration.service.Audit5GCBandIssueService;
import com.smart.rct.postmigration.service.Audit5GCBandSummaryService;
import com.smart.rct.postmigration.service.Audit5GDSSIssueService;
import com.smart.rct.postmigration.service.Audit5GDSSSummaryService;
import com.smart.rct.postmigration.service.AuditCriticalParamsService;
import com.smart.rct.postmigration.service.ReportsService;
import com.smart.rct.premigration.entity.CheckListScriptDetEntity;
import com.smart.rct.premigration.entity.GenerateInfoAuditEntity;
import com.smart.rct.premigration.entity.NeMappingEntity;
import com.smart.rct.premigration.entity.PremigrationOvUpadteEntity;
import com.smart.rct.premigration.models.CIQDetailsModel;
import com.smart.rct.premigration.models.CheckListDetailsModel;
import com.smart.rct.premigration.models.CheckListModel;
import com.smart.rct.premigration.models.NeMappingModel;
import com.smart.rct.premigration.repository.CIQUploadRepository;
import com.smart.rct.premigration.repository.FileUploadRepository;
import com.smart.rct.premigration.service.FetchProcessService;
import com.smart.rct.premigration.service.FileUploadService;
import com.smart.rct.premigration.service.NeMappingService;
import com.smart.rct.premigration.serviceImpl.GenerateCsvServiceImpl;
import com.smart.rct.usermanagement.entity.UserDetailsEntity;
import com.smart.rct.usermanagement.entity.UserSessionPool;
import com.smart.rct.usermanagement.models.User;
import com.smart.rct.usermanagement.repositoryImpl.UserActionRepositoryImpl;
import com.smart.rct.usermanagement.serviceImpl.LoggingRequestInterceptor;
import com.smart.rct.util.Audit4GFccIdUtil;
import com.smart.rct.util.Audit4GTestUtil;
import com.smart.rct.util.Audit4GTestUtil2;
import com.smart.rct.util.Audit4GTestUtil3;
import com.smart.rct.util.Audit4GUSMGrowUtil;
import com.smart.rct.util.Audit5GCBANDTestUtil;
import com.smart.rct.util.Audit5GCbandMMUUtil2;
import com.smart.rct.util.Audit5GCbandUtil;
import com.smart.rct.util.Audit5GDSSTestUtil;
import com.smart.rct.util.Audit5GDSSUtil;
import com.smart.rct.util.Audit5GMMIAUTestUtil;
import com.smart.rct.util.Audit5GMMTestUtil;
import com.smart.rct.util.AuditCbandMH1IPFetch;
import com.smart.rct.util.AuditXmlRulesServiceUtil;
import com.smart.rct.util.AuditXmlRulesServiceUtil5GDSS;
import com.smart.rct.util.AuditXmlRulesServiceUtil5GMM;
import com.smart.rct.util.CbandMMUReportingToolUtil;
import com.smart.rct.util.CommonUtil;
import com.smart.rct.util.DateUtil;
import com.smart.rct.util.FileUtil;
import com.smart.rct.util.GlobalStatusMap;
import com.smart.rct.util.LoadPropertyFiles;
import com.smart.rct.util.NeUpStatusUtil;
import com.smart.rct.util.PasswordCrypt;
import com.smart.rct.util.RSSIAuditXmlRulesServiceUtil;
import com.smart.rct.util.RSSITestUtil;

@Service
public class RunTestServiceImpl implements RunTestService {

	final static Logger logger = LoggerFactory.getLogger(RunTestServiceImpl.class);

	@Autowired
	RunTestRepository runTestRepository;

	@Autowired
	NetworkTypeDetailsRepositoryImpl networkTypeDetailsRepositoryImpl;

	@Autowired
	FetchProcessService fetchProcessService;
	
	@Autowired
	CustomerService customerService;

	@Autowired
	CustomerRepository customerRepository;


	@Autowired
	LsmRepositoryImpl lsmRepositoryImpl;

	@Autowired
	WorkFlowManagementRepository workFlowManagementRepository;

	@PersistenceContext
	private EntityManager entityManager;

	@Autowired
	OvScheduledTaskService ovScheduledTaskService;

	@Autowired
	UploadFileRepository uploadFileRepository;

	@Autowired
	UseCaseBuilderRepository useCaseBuilderRepository;

	@Autowired
	RunTestResultRepository runTestResultRepository;

	@Autowired
	FileUploadRepository fileUploadRepository;

	@Autowired
	MongoTemplate mongoTemplate;

	@Autowired
	ReportsRepository reportsRepository;

	@Autowired
	FileUploadService fileUploadService;

	@Autowired
	XmlRuleBuilderRepository xmlRuleBuilderRepository;

	// kannan starts
	@Autowired
	CIQUploadRepository ciqUploadRepository;

	@Autowired
	CommonUtil commonUtil;
	// kannan ends

	@Autowired
	UserActionRepositoryImpl userActionRepositoryImpl;

	@Autowired
	RunTestService runTestService;

	@Autowired
	public UploadFileServiceImpl uploadFileServiceImpl;

	@Autowired
	NetworkConfigService networkConfigService;

	@Autowired
	UseCaseBuilderService useCaseBuilderService;

	@Autowired
	UseCaseBuilderRepositoryImpl useCaseBuilderRepositoryImpl;

	@Autowired
	NeMappingService neMappingService;

	@Autowired
	AuditXmlRulesServiceUtil auditXmlRulesServiceUtil;

	@Autowired
	ReportsService reportService;

	@Autowired
	DuoGeneralConfigService duoGeneralConfigService;

	@Autowired
	Audit4GIssueService audit4GIssueService;
	
	@Autowired
	Audit4GFsuIssueService audit4GFsuIssueService;

	@Autowired
	Audit4GTestUtil audit4gTestUtil;
 
	@Autowired
	Audit4GTestUtil2 audit4gTestUtil2;
	
	@Autowired
	Audit5GCbandUtil audit5GCbandUtil;

	@Autowired
	Audit5GDSSUtil audit5GDSSUtil;

	@Autowired
	Audit4GSummaryService audit4GSummaryService;
	
	@Autowired
	Audit4GFsuSummaryService audit4GFsuSummaryService;

	@Autowired
	Audit5GCBandIssueService audit5GCBandIssueService;

	@Autowired
	Audit5GCBandSummaryService audit5GCBandSummaryService;

	@Autowired
	Audit5GDSSIssueService audit5GDSSIssueService;

	@Autowired
	Audit5GDSSSummaryService audit5GDSSSummaryService;

	@Autowired
	AuditXmlRulesServiceUtil5GDSS auditXmlRulesServiceUtil5GDSS;
	
	@Autowired
	AuditXmlRulesServiceUtil5GMM auditXmlRulesServiceUtil5GMM;
	
	//mmu audit
	@Autowired
	Audit5GCbandMMUUtil2 audit5GCbandMMUUtil2;
	
	@Autowired
	Audit4GTestUtil3 audit4gTestUtil3;
	
	@Autowired
	Audit5GMMTestUtil audit5GMMTestUtil;
	
	@Autowired
	Audit5GCBANDTestUtil audit5GCBANDTestUtil;
	
	@Autowired
	Audit5GDSSTestUtil audit5GDSSTestUtil;

	@Autowired
	Audit4GUSMGrowUtil audit4GUSMGrowUtil;
	
	@Autowired
	Audit5GMMIAUTestUtil audit5GMMIAUTestUtil;

	@Autowired
	RSSITestUtil rssiTestUtil;
	
	@Autowired
	GenerateCsvServiceImpl generateCsvServiceImpl;
	
	//rssi audit
	@Autowired
	RSSIAuditXmlRulesServiceUtil rSSIAuditXmlRulesServiceUtil;
	
	@Autowired
	PrePostRepository prePostRepo;
	
	@Autowired
	AuditCbandMH1IPFetch auditCbandMH1IPFetch;
	
	@Autowired
	CbandMMUReportingToolUtil cbandMMUReportingToolUtil;
	
	@Autowired
	NeUpStatusUtil neUpStatusUtil;
	
	@Autowired
	AuditConstantsRepository auditConstantsRepository;
	
	@Autowired
	AuditCriticalParamsService auditCriticalParamsService;
	
	@Autowired
	Audit4GFccIdUtil audit4GFccIdUtil;
	
	static String resultNode = "";
	static int depthOfXML = 0;

	String ruleDelimiter = "\\|";

	static final String FAILURE = "Failure";
	static final String RESULT_OK = "RESULT = OK";
	static final String SINGLE_LINE = "-----------------------";
	static final String DOUBLE_LINE = "=====================";
	static final String COMPLETE = "COMPLD";
	static final String NO_DATA = "NO DATA";

	@SuppressWarnings("null")
	@Override
	public List<RunTestModel> getRunTestDetails(int page, int count, Integer customerId, Integer programId,
			String migrationStatus, String migrationSubStatus, int days) {
		List<RunTestEntity> runTestDetails = null;
		List<RunTestModel> objRunTestModel = new ArrayList<>();
		try {
			runTestDetails = runTestRepository.getRunTestDetails(page, count, customerId, programId, migrationStatus,
					migrationSubStatus, days);

			if (runTestDetails != null && !runTestDetails.isEmpty()) {
				for (RunTestEntity runTestEntity : runTestDetails) {
					RunTestModel runModel = new RunTestModel();
					runModel.setTestName(runTestEntity.getTestName());
					runModel.setLsmVersion(runTestEntity.getLsmVersion());
					runModel.setLsmName(runTestEntity.getLsmName());
					runModel.setProgressStatus(runTestEntity.getProgressStatus());
					runModel.setStatus(runTestEntity.getStatus());
					runModel.setCiqName(runTestEntity.getCiqName());
					runModel.setNeName(runTestEntity.getNeName());
					runModel.setUseCase(runTestEntity.getUseCase());
					runModel.setId(runTestEntity.getId());
					runModel.setOutputFilepath(runTestEntity.getOutputFilepath());
					runModel.setResult(runTestEntity.getResult());
					runModel.setMigrationType(runTestEntity.getMigrationType());
					runModel.setMigrationSubType(runTestEntity.getMigrationSubType());
					runModel.setChecklistFileName(runTestEntity.getChecklistFileName());
					runModel.setUserName(runTestEntity.getUserName());

					DateFormat dateFormat = new SimpleDateFormat("yyyy-MM-dd HH:mm:ss");
					String sCreationDate = dateFormat.format(runTestEntity.getCreationDate());

					runModel.setCreationDate(sCreationDate);
					runModel.setTestDescription(runTestEntity.getTestDescription());
					runModel.setResultFilePath(runTestEntity.getResultFilePath());
					objRunTestModel.add(runModel);
				}
			}

		} catch (Exception e) {
			logger.error("Exception  in RunTestServiceImpl getRunTestDetails():" + ExceptionUtils.getFullStackTrace(e));
		}
		return objRunTestModel;
	}

	@SuppressWarnings("null")
	@Override
	public List<RunTestModel> getRunTestSearchDetails(RunTestModel runTestModel, int page, int count,
			Integer customerId, Integer programId, String migrationStatus, String migrationSubStatus, int days) {
		List<RunTestEntity> runTestDetails = null;
		List<RunTestModel> objRunTestModel = new ArrayList<>();
		try {
			runTestDetails = runTestRepository.getRunTestSearchDetails(runTestModel, page, count, customerId, programId,
					migrationStatus, migrationSubStatus, days);

			if (runTestDetails != null && !runTestDetails.isEmpty()) {
				for (RunTestEntity runTestEntity : runTestDetails) {
					RunTestModel runModel = new RunTestModel();
					runModel.setTestName(runTestEntity.getTestName());
					runModel.setLsmVersion(runTestEntity.getLsmVersion());
					runModel.setLsmName(runTestEntity.getLsmName());
					runModel.setProgressStatus(runTestEntity.getProgressStatus());
					runModel.setStatus(runTestEntity.getStatus());
					runModel.setCiqName(runTestEntity.getCiqName());
					runModel.setNeName(runTestEntity.getNeName());
					runModel.setUseCase(runTestEntity.getUseCase());
					runModel.setId(runTestEntity.getId());
					runModel.setOutputFilepath(runTestEntity.getOutputFilepath());
					runModel.setResult(runTestEntity.getResult());
					runModel.setMigrationType(runTestEntity.getMigrationType());
					runModel.setMigrationSubType(runTestEntity.getMigrationSubType());
					runModel.setChecklistFileName(runTestEntity.getChecklistFileName());
					runModel.setUserName(runTestEntity.getUserName());

					DateFormat dateFormat = new SimpleDateFormat("yyyy-MM-dd HH:mm:ss");
					String sCreationDate = dateFormat.format(runTestEntity.getCreationDate());

					runModel.setCreationDate(sCreationDate);
					runModel.setTestDescription(runTestEntity.getTestDescription());
					runModel.setResultFilePath(runTestEntity.getResultFilePath());
					objRunTestModel.add(runModel);
				}
			}

		} catch (Exception e) {
			logger.error("Exception  in RunTestServiceImpl getRunTestSearchDetails():"
					+ ExceptionUtils.getFullStackTrace(e));
		}
		return objRunTestModel;
	}

	@Override
	public List<Map> getSmList(int programId) {
		List<Map> smList = null;
		try {

			smList = runTestRepository.getSmList(programId);

		} catch (Exception e) {
			logger.error(" getSmList service : " + ExceptionUtils.getFullStackTrace(e));
		}
		return smList;

	}

	@Override
	public List<Map> getUseCaseList(int programId, String migrationType, String subType, String ciqFName,
			List<Map> neList) {

		List<Map> ucList = null;
		try {

			ucList = runTestRepository.getUseCaseList(programId, migrationType, subType, ciqFName, neList);

		} catch (Exception e) {
			logger.error(" getUseCaseList service : " + ExceptionUtils.getFullStackTrace(e));
		}
		return ucList;

	}

	@Override
	public List<Map> getUseCaseList(int programId, String migrationType, String subType) {

		List<Map> ucList = null;
		try {

			ucList = runTestRepository.getUseCaseList(programId, migrationType, subType);

		} catch (Exception e) {
			logger.error(" getUseCaseList service : " + ExceptionUtils.getFullStackTrace(e));
		}
		return ucList;

	}

	/**
	 * this method will return lsm details
	 * 
	 * @param
	 * @return Map
	 */

	@SuppressWarnings("null")
	@Override
	public Map<String, Object> getdropDownDetails(List<NetworkTypeDetailsModel> neList) {
		List<LsmEntity> objList = null;
		Map<String, Map<String, String>> versionNvNameMap = new LinkedHashMap<>();
		Map<String, Map<String, List<Map>>> versionNvNameMap1 = new HashMap<>();
		Map<Integer, List<String>> neTypeNVersionMap = new LinkedHashMap<>();
		Map finalresult = new HashMap();
		try {
			objList = uploadFileRepository.getLsmDetails();

			Map<String, List<UseCaseBuilderEntity>> comboUsecase = new HashMap<>();

			if (objList != null && !objList.isEmpty()) {
				Set<Integer> nwTypeIdSet = objList.stream().map(x -> x.getNetworkTypeDetailsEntity().getId())
						.collect(Collectors.toSet());

				if (nwTypeIdSet != null && !nwTypeIdSet.isEmpty()) {
					for (Integer neTypeId : nwTypeIdSet) {
						List<String> objListLsmVer = new ArrayList<>();
						for (LsmEntity objModel : objList) {

							if (neTypeId.equals(objModel.getNetworkTypeDetailsEntity().getId())) {
								if (!objListLsmVer.contains(objModel.getLsmVersion()))
									objListLsmVer.add(objModel.getLsmVersion());
							}
						}
						neTypeNVersionMap.put(neTypeId, objListLsmVer);
					}

				}
			}

			if (objList != null && !objList.isEmpty()) {
				Set<String> objVersionsSet = objList.stream().map(x -> x.getLsmVersion()).collect(Collectors.toSet());

				if (objVersionsSet != null && !objVersionsSet.isEmpty()) {
					for (String objVersion : objVersionsSet) {
						Map<String, String> objListLsms = new HashMap<>();
						for (LsmEntity objModel : objList) {
							if (objVersion.equals(objModel.getLsmVersion())) {
								int id = objModel.getId();
								String lsmName = objModel.getLsmName();
								String lsmVersion = objModel.getLsmVersion();
								String combo = id + lsmVersion + lsmName;
								objListLsms.put(objModel.getLsmName(), combo);
							}
						}
						versionNvNameMap.put(objVersion, objListLsms);
					}
				}
			}

			for (Entry<String, Map<String, String>> entry : versionNvNameMap.entrySet()) {
				String version = entry.getKey();
				Map<String, List<Map>> versionNvNameM = new HashMap<>();
				Map<String, String> m = entry.getValue();
				for (Map.Entry<String, String> entry1 : m.entrySet()) {
					String lsmName = entry1.getKey();
					String lsmNamecombo = entry1.getValue();
					List<UseCaseBuilderEntity> l = comboUsecase.get(lsmNamecombo);
					List<Map> lmap = new ArrayList<>();
					if (l != null) {
						for (UseCaseBuilderEntity e : l) {
							Map ma = new HashMap<>();
							ma.put("useCaseId", e.getId());
							ma.put("executionSequence", e.getExecutionSequence());
							ma.put("useCaseName", e.getUseCaseName());
							lmap.add(ma);
						}
					}
					versionNvNameM.put(lsmName, lmap);
				}
				versionNvNameMap1.put(version, versionNvNameM);
			}

			if (neList != null && !neList.isEmpty()) {
				for (NetworkTypeDetailsModel NetModel : neList) {
					Map map = new HashMap();
					List<String> list = neTypeNVersionMap.get(NetModel.getId());
					if (list != null && !list.isEmpty()) {
						for (String version : list) {
							map.put(version, versionNvNameMap1.get(version));
						}
					}
					finalresult.put(NetModel.getNetworkType(), map);
				}
			}

		} catch (Exception e) {
			logger.error(
					"Exception  getdropDownDetails() in  RunTestServiceImpl:" + ExceptionUtils.getFullStackTrace(e));
		}
		return finalresult;
	}

	@Override
	public List<NetworkTypeDetailsModel> getNetWorksBasedOnCustomer(Integer customerId) {
		List<NetworkTypeDetailsModel> neTypeDetailsList = null;
		try {
			neTypeDetailsList = lsmRepositoryImpl.getNetWorksBasedOnCustomer(customerId);

		} catch (Exception e) {
			logger.error("Exception  getNetWorksBasedOnCustomer() in  RunTestServiceImpl:"
					+ ExceptionUtils.getFullStackTrace(e));
		}
		return neTypeDetailsList;
	}

	public JSONObject getSaneDetailsforPassword(JSONObject runTestParams) {
		JSONObject result = new JSONObject();

		try {
			Map run = (Map) runTestParams.get("runTestFormDetails");
			int lsmId = Integer.parseInt(run.get("lsmId").toString());
			boolean useCurrPassword = (boolean) run.get("currentPassword");
			NetworkConfigEntity networkConfigEntity = runTestRepository.getNeType(lsmId);
			List<NetworkConfigDetailsEntity> neDetailsLst = networkConfigEntity.getNeDetails();
			for (NetworkConfigDetailsEntity neDetails : neDetailsLst) {
				if (useCurrPassword == false
						&& "SANE".equalsIgnoreCase(neDetails.getServerTypeEntity().getServerType())) {

					String serverName = neDetails.getServerName();
					String serverIP = neDetails.getServerIp();
					result.put("serverName", serverName);
					result.put("serverIp", serverIP);
					return result;
				}
			}
		} catch (Exception e) {
			logger.error("Exception  getSaneDetailsforPassword() in  RunTestServiceImpl:"
					+ ExceptionUtils.getFullStackTrace(e));
		}

		return result;
	}

	public int getScriptSleepInterval(List<Map> scriptSeqDetails, int scriptId) {
		int sleepInterval = 0;
		try {

			if (scriptSeqDetails != null) {
				for (Map scriptInfo : scriptSeqDetails) {

					int mapScriptId = Integer.parseInt(scriptInfo.get("scriptId").toString());

					if (mapScriptId == scriptId) {
						sleepInterval = Integer.parseInt(scriptInfo.get("scriptSleepInterval").toString());
						break;

					}
				}
			}
		} catch (Exception e) {
			logger.error(
					"Exception RunTestServiceImpl in getScriptSleepInterval() " + ExceptionUtils.getFullStackTrace(e));
		}

		return sleepInterval;

	}

	public int getUCSleepInterval(List<LinkedHashMap> ucDetails, int ucId) {

		int sleepInterval = 0;
		try {
			if (ucDetails != null) {
				for (Map ucInfo : ucDetails) {

					int mapUcId = Integer.parseInt(ucInfo.get("useCaseId").toString());

					if (mapUcId == ucId) {

						sleepInterval = Integer.parseInt(ucInfo.get("ucSleepInterval").toString());

						break;

					}
				}
			}

		} catch (Exception e) {
			logger.error("Exception RunTestServiceImpl in getUCSleepInterval() " + ExceptionUtils.getFullStackTrace(e));
		}
		return sleepInterval;

	}

	public int getScriptExeSeq(List<Map> scriptSeqDetails, int scriptId) {

		int scriptExecution = 1;
		try {
			if (scriptSeqDetails != null) {
				for (Map scriptInfo : scriptSeqDetails) {

					int mapScriptId = Integer.parseInt(scriptInfo.get("scriptId").toString());

					if (mapScriptId == scriptId) {
						scriptExecution = Integer.parseInt(scriptInfo.get("scriptExeSequence").toString());

					}
				}
			}

		} catch (Exception e) {
			logger.error("Exception RunTestServiceImpl in getScriptExeSeq() " + ExceptionUtils.getFullStackTrace(e));
		}
		return scriptExecution;

	}

	@Override
	public String getRuntestEnbProgressStatus(JSONObject runTestParams) {

		try {
			Map run = (Map) runTestParams.get("runTestFormDetails");
			List<Map> neList = (List<Map>) run.get("neDetails");

			for (Map neid : neList) {

				String neName = neid.get("neName").toString();
				boolean inProgressStatus = runTestRepository.getRuntestEnbProgressStatus(neName);

				if (inProgressStatus) {
					return "Site Execution is in progress, cannot initiate execution";
				}
			}
		} catch (Exception e) {
			logger.error("Exception RunTestServiceImpl in getRuntestEnbProgressStatus() "
					+ ExceptionUtils.getFullStackTrace(e));
		}
		return Constants.SUCCESS;
	}

	@Override
	public String getRuntestExecResult(JSONObject runTestParams, Map<String, RunTestEntity> runTestEntityMap,
			String runType, String htmlOutputFileName, Map<String, Object> reRunDetails, boolean rfScriptFlags)
			throws RctException {
		
		Map run = (Map) runTestParams.get("runTestFormDetails");
		String testname = run.get("testname").toString();
		List<Map> scriptSeqDetails = (List<Map>) run.get("scripts");
		List<Map> neList = (List<Map>) run.get("neDetails");
		List<LinkedHashMap> useCaseList = (List) run.get("useCase");
		int programId = Integer.parseInt(runTestParams.get("programId").toString());
		
		boolean useCurrPassword = (boolean) run.get("currentPassword");
		String	 programName = runTestParams.get("programName").toString();
		String serviceToken = runTestParams.get("serviceToken").toString();
		String sanePassword = run.get("password").toString();
		String migType = runTestParams.get("migrationType").toString();
		String migSubType = runTestParams.get("migrationSubType").toString();
		String userName = runTestParams.get("userName").toString();
		String checklistFileName = run.get("checklistFileName").toString();
		String ciqFileName = run.get("ciqName").toString();
		String sProgramId = runTestParams.get("programId").toString();
		String remarks = run.get("testDesc").toString();
		
		String sessionId = runTestParams.get("sessionId").toString();
		CustomerDetailsEntity customerDetailsEntity = getCustomerDetailsEntity(programId);
		AtomicBoolean totalTestCompleted = new AtomicBoolean();
		AtomicBoolean isMultipleDUo = new AtomicBoolean();
		isMultipleDUo.set(false);
		if(run.containsKey("multipleDuo")) {
		boolean duo1234 = (boolean) run.get("multipleDuo");
		if(duo1234==true) {
			isMultipleDUo.set(true);
		}}

		try {
			ExecutorService executorservice = Executors.newFixedThreadPool(neList.size());
			for (Map usecase : useCaseList) {
				Integer useCaseId = Integer.valueOf(usecase.get("useCaseId").toString());
				runTestRepository.updateUseCountForUseCase(useCaseId, Constants.USECOUNT_INCREMENT, neList.size());
			}
			for (Map neid : neList) {

				executorservice.submit(() -> {
					LocalDateTime l1 = LocalDateTime.now();
					Map<String, String> scriptFilesDetails = new HashMap<>();
					StringBuilder auditHtmlFilePath = new StringBuilder();
					ReportsEntity reportsEntity = null;
					StringBuilder auditHtmlFileName = new StringBuilder();
					String neId = neid.get("neId").toString();
					String neName = neid.get("neName").toString();
					String lsmName = "";
					String lsmVersion = "";
					int lsmId = 0;
					String Info="";
					boolean TotalScriptExecute = false;
					boolean Type = false;
					boolean NecreationResult = false;
					boolean DeletionResult = false;
					String lastscriptFileName=null;
					String TotalRFzipCount="";
					int TotalScriptCount;
					int ProgressCount=0;
					String programName2 = customerDetailsEntity.getProgramName();
					if(run.containsKey("prePostAuditFlag")&&run.get("prePostAuditFlag")!=null) {
					Type = (boolean) run.get("prePostAuditFlag");
					}
					NeMappingModel neMappingModelversion = new NeMappingModel();
					CustomerDetailsEntity programDetailsEntityversion = new CustomerDetailsEntity();
					programDetailsEntityversion.setId(programId);
					neMappingModelversion.setProgramDetailsEntity(programDetailsEntityversion);
					neMappingModelversion.setEnbId(neId);
					NetworkConfigEntity neMappingEntitiesForVersion = runTestRepository
							.getNetWorkEntityDetails(neMappingModelversion);
					if (neMappingEntitiesForVersion != null) {
						lsmVersion = neMappingEntitiesForVersion.getNeVersionEntity().getNeVersion();
						lsmId = neMappingEntitiesForVersion.getId();
					}
					if (run.get("lsmName").toString().isEmpty()) {
						lsmName = neMappingEntitiesForVersion.getNeName();
					} else {
						lsmName = run.get("lsmName").toString();
						lsmVersion = run.get("lsmVersion").toString();
						NetworkConfigEntity neConfigEntity = runTestRepository.getNEConfigEntity(lsmVersion, lsmName,
								programDetailsEntityversion);
						lsmId = neConfigEntity.getId();
					}
					String threadname = "RT_" + runTestEntityMap.get(neId).getId();
					Thread.currentThread().setName(threadname);
					logger.error("Started the thread for NE " + neId + " at : " + l1);
					runTestEntityMap.get(neId).setruntestThreadName(threadname);
					runTestRepository.updateRunTest(runTestEntityMap.get(neId));
					NetworkConfigEntity networkConfigEntity = runTestRepository.getNeType(lsmId);

					NetworkConfigEntity neEntity = uploadFileServiceImpl.getNeEntity(lsmVersion, lsmName, programId);

					UserDetailsEntity userDetailsEntity2 = userActionRepositoryImpl.getUserDetailsBasedName(userName);
					if (GlobalStatusMap.userNeQueue.contains(userDetailsEntity2.getVpnUserName())) {
						GlobalStatusMap.userNeQueue.get(userDetailsEntity2.getVpnUserName()).add(neId);
					} else {
						GlobalStatusMap.userNeQueue.put(userDetailsEntity2.getVpnUserName(),
								new ConcurrentLinkedQueue<>());
						GlobalStatusMap.userNeQueue.get(userDetailsEntity2.getVpnUserName()).add(neId);
					}

					String migrationType = null;
					String migrationSubType = null;

					if (migType.equalsIgnoreCase(Constants.MIGRATION)) {
						migrationType = "Migration";
					} else if (migType.equalsIgnoreCase(Constants.POST_MIGRATION)) {
						migrationType = "PostMigration";
					} else if (migType.equalsIgnoreCase(Constants.PRE_MIGRATION)) {
						migrationType = "PreMigration";
					}
					if ("precheck".equalsIgnoreCase(migSubType)) {
						migrationSubType = "PreCheck";
					} else if ("commission".equalsIgnoreCase(migSubType)) {
						migrationSubType = "Commission";
					} else if ("postcheck".equalsIgnoreCase(migSubType)) {
						migrationSubType = "PostCheck";
					} else if ("AUDIT".equalsIgnoreCase(migSubType)) {
						migrationSubType = "Audit";
					} else if ("RANATP".equalsIgnoreCase(migSubType)) {
						migrationSubType = "RanATP";
					} else if ("NEGrow".equalsIgnoreCase(migSubType)) {
						migrationSubType = "NEGrow";
					}
					String generateScriptPath = ""; 
					String ovNegrow="OFF";
					String ovNeDegrow="OFF";
					int DeletionDays=0;
					if(migrationSubType.equalsIgnoreCase("NEGrow")) {
					if (run.containsKey("type") && run.get("type")!=null&& run.get("type").equals("OV")) {
							OvAutomationModel ovAutomationModel = customerService.getOvAutomationTemplate();
							if (ovAutomationModel != null) { 
								ovNegrow=ovAutomationModel.getNeGrow();
								ovNeDegrow=ovAutomationModel.getNeDeGrow();
								DeletionDays=ovAutomationModel.getDeletionDays();
								System.out.println("--------------Deletion Days -----------"+DeletionDays);
							}
						}
					}
					try {
						// generate script path
						StringBuilder generatedPath = new StringBuilder();
						generatedPath = generatedPath.append(LoadPropertyFiles.getInstance().getProperty("BASE_PATH"));
						generatedPath.append(Constants.CUSTOMER)
								.append(Constants.GENERATE_SCRIPT.replace("programId", sProgramId)
										.replace("migrationType", migrationType).replace("neId", neId)
										.replace("subType", migrationSubType));

						String finalStatusResult = "Success";
						int iUseCaseId = 0;
						Map<String, String> generateScriptMap = new HashMap<>();
						Map<String, String> scriptNameMap = new HashMap<>();
						if (scriptSeqDetails != null) {

							for (Map scriptInfoDetails : scriptSeqDetails) {
								String useGeneratedScriptsCheck = scriptInfoDetails.get("useGeneratedScript")
										.toString();
								String sScriptName = scriptInfoDetails.get("scriptName").toString();
								String useCaseNameInScript = scriptInfoDetails.get("useCaseName").toString();
								generateScriptMap.put(useCaseNameInScript + "_" + sScriptName,
										useGeneratedScriptsCheck);
								scriptNameMap.put(useCaseNameInScript + "_" + sScriptName, sScriptName);
							}
						}

						ArrayList scriptFinalLst = null;

						// Use case loop
						TreeSet<String> finalListFile = new TreeSet<>();
						scriptFinalLst = new ArrayList<ArrayList>();

						for (Map usecase : useCaseList) {
							if (((String) usecase.get("useCaseName")).contains(neId)
									|| migType.equalsIgnoreCase(Constants.POST_MIGRATION)) {
								Integer useCaseExeSeq = Integer.valueOf(usecase.get("executionSequence").toString());
								String useCaseName = (String) usecase.get("useCaseName");
								iUseCaseId = Integer.valueOf(usecase.get("useCaseId").toString());
								List<UseCaseBuilderParamEntity> scriptDetails = runTestRepository
										.getScriptDetails(iUseCaseId);

								Map<Integer, Integer> scriptIdAndSeqmap = new HashMap<>();
								for (UseCaseBuilderParamEntity scriptInfo : scriptDetails) {
									List scriptLst = new ArrayList<>();
									Integer scriptId = scriptInfo.getScriptsDetails().getId();

									int scriptUiExeSeq = getScriptExeSeq(scriptSeqDetails, scriptId);

									Integer scriptExeSeq = scriptUiExeSeq;

									Integer uploadedscriptId = scriptInfo.getId();
									if (scriptExeSeq != 0) {

										scriptLst.add(scriptId);
										scriptLst.add(scriptExeSeq);
										scriptLst.add(uploadedscriptId);
										scriptFinalLst.add(scriptLst);
										scriptIdAndSeqmap.put(scriptId, scriptExeSeq);

									}
								}

								// Script loop
								for (UseCaseBuilderParamEntity scriptEntity : scriptDetails) {

									Integer scriptId = scriptEntity.getScriptsDetails().getId();
									int scriptUiExeSeq = getScriptExeSeq(scriptSeqDetails, scriptId);
									Integer scriptExeSeq1 = scriptUiExeSeq;

									if (scriptExeSeq1 != 0) {
										int scriptExeSeq = scriptIdAndSeqmap.get(scriptId);

										// int scriptExeSeq = scriptEntity.getExecutionSequence();

										UploadFileEntity uploadFileEntity = null;

										uploadFileEntity = scriptEntity.getScriptsDetails();

										if (ObjectUtils.isEmpty(uploadFileEntity)) {
											uploadFileEntity = runTestRepository.getScriptInfo(scriptId);
										}

										String dbcollectionFileName = CommonUtil
												.createMongoDbFileName(String.valueOf(programId), ciqFileName);
										String vznEnbIP = fileUploadRepository.getEnBDataByPath(dbcollectionFileName,
												Constants.VZ_GROW_IPPLAN, neId,
												Constants.ORAN_SPRINT_COMM_SCRIPT_eNB_OAM_IP_eNB_S_B_IP);
										String eNB_OAM_IP = fileUploadRepository.getEnBDataByPath(dbcollectionFileName,
												Constants.SPT_GROW_SHEET_FDD_TDD, neId,
												Constants.ORAN_SPRINT_COMM_SCRIPT_8_CHG_IP_ADDR);

										String enbIP = "127.0.0.1";

										if (StringUtils.isNotEmpty(vznEnbIP)) {
											enbIP = vznEnbIP;
										} else if (StringUtils.isNotEmpty(eNB_OAM_IP)) {
											String sprintEnbIP = CommonUtil.getLeftSubStringWithLen(eNB_OAM_IP, 3);
											if (StringUtils.isNotEmpty(sprintEnbIP)) {
												enbIP = sprintEnbIP;
											} else {
												enbIP = eNB_OAM_IP;
											}
										}

										String CSR_OAM_IP = fileUploadRepository.getEnBDataByPath(dbcollectionFileName,
												Constants.SPT_GROW_SHEET_FDD_TDD, neId,
												Constants.ORAN_SPRINT_COMM_SCRIPT_9_CSR_OAM_IP);

										NeMappingModel neMappingModel = new NeMappingModel();
										CustomerDetailsEntity programDetailsEntity = new CustomerDetailsEntity();
										programDetailsEntity.setId(programId);
										neMappingModel.setProgramDetailsEntity(programDetailsEntity);
										neMappingModel.setEnbId(neId);
										List<NeMappingEntity> neMappingEntities = neMappingService
												.getNeMapping(neMappingModel);

										String neType = Constants.NE_TYPE_ENB;
										if (uploadFileEntity.getFileName().contains(Constants.PRECHECK_CSR_FILE_NAME)
												|| uploadFileEntity.getFileName()
														.contains(Constants.POSTCHECK_CSR_FILE_NAME)) {
											enbIP = CommonUtil.getLeftSubStringWithLen(CSR_OAM_IP, 3);
											neType = Constants.NE_TYPE_CSR;
										} else if (uploadFileEntity.getFileName()
												.contains(Constants.PRECHECK_BSM_FILE_NAME)
												|| uploadFileEntity.getFileName()
														.contains(Constants.POSTCHECK_BSM_FILE_NAME)) {
											enbIP = neMappingEntities.get(0).getBsmIp();
											neType = Constants.NE_TYPE_BSM;
										}
										/*
										 * enbIP = fileUploadRepository.getEnBDataByPath(ciqPgmIdAndCiqName, "IPPLAN",
										 * neId,"eNB_OAM_IP&eNB_S&B_IP");
										 */
										String useGeneratedScriptsCheck = generateScriptMap
												.get(useCaseName + "_" + uploadFileEntity.getFileName());

										String[] scriptNameSplit = uploadFileEntity.getFileName().split("\\.");
										String checkLsmName = null;
										if (useGeneratedScriptsCheck != null
												&& "YES".equalsIgnoreCase(useGeneratedScriptsCheck.trim())) {
											File folder = new File(generatedPath.toString());
											if (!folder.exists()) {
												FileUtil.createDirectory(generatedPath.toString());
											}

											File[] listOfFiles = folder.listFiles();
											ArrayList<String> listOfFile = new ArrayList<>();
											if (listOfFiles.length > 0) {
												for (File file : listOfFiles) {
													listOfFile.add(file.getName());
												}

												String sLsmName = lsmName;
												String sUseCaseName = useCaseName;

												if (sLsmName.contains("_")) {
													sLsmName = charRemoveAt(sLsmName);
												}

												if (sUseCaseName.contains("_")) {
													sUseCaseName = charRemoveAt(sUseCaseName);
												}

												if (scriptNameSplit[0].contains("_")) {
													scriptNameSplit[0] = charRemoveAt(scriptNameSplit[0]);
												}

												sLsmName = sLsmName.replaceAll("\\s", "");
												sUseCaseName = sUseCaseName.replaceAll("\\s", "");
												scriptNameSplit[0] = scriptNameSplit[0].replaceAll("\\s", "");
												useCaseName = useCaseName.trim().replaceAll("\\s", "_");

												String filePathwithName = scriptExeSeq + "_" + sLsmName + "_"
														+ sUseCaseName + "_" + iUseCaseId + "_" + scriptNameSplit[0]
														+ "_" + scriptId + "." + scriptNameSplit[1];
												if (listOfFile.contains(filePathwithName)) {
													// do nothing
												} else {
													
													generateScriptWithOutExe(neId, neName, sProgramId, migrationType,
															migrationSubType, uploadFileEntity, enbIP, neEntity,
															useCaseName, sessionId, lsmName, iUseCaseId, useCaseExeSeq,
															scriptId, scriptExeSeq, lsmId, useCurrPassword,
															sanePassword, userName, lsmVersion, ciqFileName, neType,
															rfScriptFlags);
													
												}

											} else {
												
												generateScriptWithOutExe(neId, neName, sProgramId, migrationType,
														migrationSubType, uploadFileEntity, enbIP, neEntity,
														useCaseName, sessionId, lsmName, iUseCaseId, useCaseExeSeq,
														scriptId, scriptExeSeq, lsmId, useCurrPassword, sanePassword,
														userName, lsmVersion, ciqFileName, neType, rfScriptFlags);
												 
											}

										} else {
											
											generateScriptWithOutExe(neId, neName, sProgramId, migrationType,
													migrationSubType, uploadFileEntity, enbIP, neEntity, useCaseName,
													sessionId, lsmName, iUseCaseId, useCaseExeSeq, scriptId,
													scriptExeSeq, lsmId, useCurrPassword, sanePassword, userName,
													lsmVersion, ciqFileName, neType, rfScriptFlags);
											
										}

										checkLsmName = lsmName;

										if (checkLsmName.contains("_")) {
											checkLsmName = charRemoveAt(checkLsmName);
										}

										checkLsmName = checkLsmName.replaceAll("\\s", "");

										File folder = new File(generatedPath.toString());
										File[] listOfFiles = folder.listFiles();

										if (listOfFiles.length > 0) {
											for (File file : listOfFiles) {
												String fileName = file.getName();
												if (fileName.contains(checkLsmName)
														&& fileName.contains(Integer.toString(iUseCaseId))
														&& fileName.contains(Integer.toString(scriptId))
														&& fileName.contains(Integer.toString(scriptExeSeq))) {
													finalListFile.add(fileName);
												} else {
													// do nothing
												}
											}
										}

									} else {
										// do nothing
									}
								}
							}
						}

						/*
						 * File folder = new File(generatedPath.toString()); File[] listOfFiles =
						 * folder.listFiles(); TreeSet<String> finalListFile = new TreeSet<String>(); if
						 * (listOfFiles.length > 0) { for (File file : listOfFiles) { String fileName =
						 * file.getName(); if (fileName.contains(sessionId)) {
						 * finalListFile.add(fileName); } else { // do nothing } } }
						 */

						// Map<Integer, ArrayList> UseCasehashMap = new HashMap<>();
						// ArrayList<String> list = null;

						// for (String Filename : finalListFile) {

						// String[] useCaseExeSeq = Filename.split("_");
						// int iUseCaseExeSeq = Integer.parseInt(useCaseExeSeq[0]);

						// if (UseCasehashMap.containsKey(iUseCaseExeSeq)) {
						// list.add(Filename);
						// } else {
						// list = new ArrayList<String>();
						// list.add(Filename);
						// }
						// UseCasehashMap.put(iUseCaseExeSeq, list);
						// }

						// Map<Integer, ArrayList> usecaseSortedByExeSeqMap =
						// UseCasehashMap.entrySet().stream()
						// .sorted(Map.Entry.comparingByKey()).collect(Collectors.toMap(Map.Entry::getKey,
						// Map.Entry::getValue, (e1, e2) -> e1, LinkedHashMap::new));

						// mainloop: for (Entry<Integer, ArrayList> h :
						// usecaseSortedByExeSeqMap.entrySet()) {

						// ArrayList<String> sortedValues = h.getValue();
						Map<Integer, String> scriptExehashMap = new HashMap<>();

						for (String fileName : finalListFile) {

							String[] scriptExeSeq = fileName.split("_");
							int iScriptExeSeq = Integer.parseInt(scriptExeSeq[0]);

							scriptExehashMap.put(iScriptExeSeq, fileName);

						}
						TotalScriptCount=scriptExehashMap.size();
						//System.out.println("Total Script"+scriptExehashMap.size());
						Map<Integer, String> scriptexeSortedByExeSeqMap = scriptExehashMap.entrySet().stream()
								.sorted(Map.Entry.comparingByKey()).collect(Collectors.toMap(Map.Entry::getKey,
										Map.Entry::getValue, (e1, e2) -> e1, LinkedHashMap::new));
						///to get the last script
						 int counter = 1;
						for (Entry<Integer, String> file : scriptexeSortedByExeSeqMap.entrySet())
					    {
							scriptexeSortedByExeSeqMap.size();
					       
					            if (counter == scriptexeSortedByExeSeqMap.size()) {
					               
					            	String orderFileName = file.getValue();
					            	String[] useCaseNameSplitforscript = orderFileName.split("_");
					            	lastscriptFileName = useCaseNameSplitforscript[0];
					               
					            }
					            counter++;
					        
					    }

						// updating runTestEntity to update the generated script path before running the
						// run test
						mainloop1: for (Entry<Integer, String> file : scriptexeSortedByExeSeqMap.entrySet()) {
							String orderFileName = file.getValue();
							String fileNameWithPath = generatedPath.toString() + "/" + orderFileName;
							String filePathWithRunTestId = generatedPath.toString()
									+ runTestEntityMap.get(neId).getId();
							File dir = new File(filePathWithRunTestId);
							if (!dir.exists()) {
								FileUtil.createDirectory(filePathWithRunTestId);
							}
							FileUtils.copyFileToDirectory(new File(fileNameWithPath), dir);
							String filePath = filePathWithRunTestId.toString() + "/" + orderFileName;
							generateScriptPath = generateScriptPath
									+ filePath.replace(LoadPropertyFiles.getInstance().getProperty("BASE_PATH"), "")
									+ ",";

							if (StringUtils.isNotEmpty(generateScriptPath)) {
								runTestEntityMap.get(neId).setGenerateScriptPath(
										generateScriptPath.substring(0, generateScriptPath.length() - 1));
								runTestRepository.updateRunTest(runTestEntityMap.get(neId));
							}
						}
						// performance increasing
						ConcurrentHashMap<Integer, UseCaseBuilderEntity> useCaseBuilderEntiyMap = new ConcurrentHashMap<>();
						ConcurrentHashMap<Integer, UploadFileEntity> uploadFileEntityMap = new ConcurrentHashMap<>();
						JSONObject duoData = isDuoApplicable(null, networkConfigEntity, useCurrPassword, sanePassword);
						// AtomicInteger checkListCount=new AtomicInteger();
//main start is here step1
						int PnpKey=0;
						int newPnpKey = 0;
						String pnpValue="" ;
						boolean pnpstatus = false;
						mainloop1: for (Entry<Integer, String> file : scriptexeSortedByExeSeqMap.entrySet()) {
							// Duration for Script execution
							LocalDateTime lshtool1 = LocalDateTime.now();
							long dshsec = 0;
							// swetha
							String orderFileName = file.getValue();
							String  PreviousResuly="";
							// for (String orderFileName : finalListFile) {

							String fileNameWithPath = generatedPath.toString() + "/" + orderFileName;
							String dbcollectionFileName = CommonUtil.createMongoDbFileName(String.valueOf(programId),
									ciqFileName);
							String vznEnbIP = fileUploadRepository.getEnBDataByPath(dbcollectionFileName,
									Constants.VZ_GROW_IPPLAN, neId,
									Constants.ORAN_SPRINT_COMM_SCRIPT_eNB_OAM_IP_eNB_S_B_IP);
							String eNB_OAM_IP = fileUploadRepository.getEnBDataByPath(dbcollectionFileName,
									Constants.SPT_GROW_SHEET_FDD_TDD, neId,
									Constants.ORAN_SPRINT_COMM_SCRIPT_8_CHG_IP_ADDR);
							String enbIP = "127.0.0.1";

							if (StringUtils.isNotEmpty(vznEnbIP)) {
								enbIP = vznEnbIP;
							} else if (StringUtils.isNotEmpty(eNB_OAM_IP)) {
								String sprintEnbIP = CommonUtil.getLeftSubStringWithLen(eNB_OAM_IP, 3);
								if (StringUtils.isNotEmpty(sprintEnbIP)) {
									enbIP = sprintEnbIP;
								} else {
									enbIP = eNB_OAM_IP;
								}
							}

							String output = "";
							String shelloutput = "";
							String outputFileName = "";
							String outputFileNameAudit = "";
							StringBuilder newOutputFileDBPath = new StringBuilder();
							StringBuilder newOutputFilePath = new StringBuilder();

							String[] useCaseNameSplit = orderFileName.split("_");
							int iScriptExeSeq = Integer.parseInt(useCaseNameSplit[0]);
							String useCaseName = useCaseNameSplit[2];
							int scriptId = Integer.parseInt(useCaseNameSplit[5].split("\\.")[0]);
							String descFinalPath = "";
							String scriptFileName = useCaseNameSplit[4];
							iUseCaseId = Integer.parseInt(useCaseNameSplit[3]);

							if ("PreCheck".equalsIgnoreCase(migrationSubType) && "CONTINUE".equalsIgnoreCase(runType)) {

								List<String> objSkipList = (List<String>) reRunDetails.get("skipIds");
								StringBuilder ObjBuilder = new StringBuilder();
								ObjBuilder.append(String.valueOf(iUseCaseId));
								ObjBuilder.append("_");
								ObjBuilder.append(String.valueOf(scriptId));

								if (objSkipList.contains(ObjBuilder.toString())) {
									continue mainloop1;
								}

							} else if ("PreCheck".equalsIgnoreCase(migrationSubType)
									&& "RERUNSCRIPT".equalsIgnoreCase(runType)) {

								List<String> objSkipList = (List<String>) reRunDetails.get("skipIds");
								StringBuilder ObjBuilder = new StringBuilder();
								ObjBuilder.append(String.valueOf(iUseCaseId));
								ObjBuilder.append("_");
								ObjBuilder.append(String.valueOf(scriptId));

								if (objSkipList.contains(ObjBuilder.toString())) {
									continue mainloop1;
								}

							}
							if ("NEGrow".equalsIgnoreCase(migrationSubType) && "CONTINUE".equalsIgnoreCase(runType)) {

								List<String> objSkipList = (List<String>) reRunDetails.get("skipIds");
								StringBuilder ObjBuilder = new StringBuilder();
								ObjBuilder.append(String.valueOf(iUseCaseId));
								ObjBuilder.append("_");
								ObjBuilder.append(String.valueOf(scriptId));

								if (objSkipList.contains(ObjBuilder.toString())) {
									continue mainloop1;
								}

							} else if ("NEGrow".equalsIgnoreCase(migrationSubType)
									&& "RERUNSCRIPT".equalsIgnoreCase(runType)) {

								List<String> objSkipList = (List<String>) reRunDetails.get("skipIds");
								StringBuilder ObjBuilder = new StringBuilder();
								ObjBuilder.append(String.valueOf(iUseCaseId));
								ObjBuilder.append("_");
								ObjBuilder.append(String.valueOf(scriptId));

								if (objSkipList.contains(ObjBuilder.toString())) {
									continue mainloop1;
								}

							}else if ("NEGrow".equalsIgnoreCase(migrationSubType)
									&& scriptFileName.contains("NeCreationTimeBashFile")) {

								if (NecreationResult) {
									continue mainloop1;
								}

							}
							// code optimisation
							UseCaseBuilderEntity useCaseBuilderEntity = null;
							if (useCaseBuilderEntiyMap.containsKey(iUseCaseId)) {
								useCaseBuilderEntity = useCaseBuilderEntiyMap.get(iUseCaseId);
							} else {
								useCaseBuilderEntity = runTestRepository.getUseCaseEntity(iUseCaseId);
								useCaseBuilderEntiyMap.put(iUseCaseId, useCaseBuilderEntity);
							}

							String originalUseCaseName = useCaseBuilderEntity.getUseCaseName();

							UploadFileEntity scriptEntity = getUploadFileEntity(useCaseBuilderEntity, scriptId);
							uploadFileEntityMap.put(scriptId, scriptEntity);

							if (ObjectUtils.isEmpty(scriptEntity)) {
								scriptEntity = runTestRepository.getScriptInfo(scriptId);
								uploadFileEntityMap.put(scriptId, scriptEntity);
							}
							/*
							 * if(uploadFileEntityMap.containsKey(scriptId)) {
							 * scriptEntity=uploadFileEntityMap.get(scriptId); }else {
							 * scriptEntity=getUploadFileEntity(useCaseBuilderEntity, scriptId);
							 * //scriptEntity= runTestRepository.getScriptInfo(scriptId);
							 * uploadFileEntityMap.put(scriptId, scriptEntity); }
							 */
							// code optimisation

							/// not included
							// swetha
							String scriptAbsFileName = LoadPropertyFiles.getInstance().getProperty("BASE_PATH")
									+ scriptEntity.getFilePath() + "/" + originalUseCaseName.trim().replaceAll(" ", "_")
									+ "/" + scriptEntity.getFileName();

							scriptFilesDetails.put(scriptAbsFileName, scriptEntity.getPrompt());
							// not included
							// need to do code optimisation
							// Code Optimisation (04-01-2020)
							/*
							 * if(checkListCount.get()==0) { List<CheckListDetailsModel> sheetList =
							 * ciqUploadRepository.getCheckListAllSheetNames( checklistFileName,
							 * CommonUtil.createMongoDbFileNameCheckList(sProgramId, checklistFileName,
							 * ciqFileName)); Set<String> sheetDetails = sheetList.stream().map(x ->
							 * x.getSheetName()) .collect(Collectors.toSet()); //need to do code
							 * optimisation //RunTestEntity runTestEntityDetails =
							 * runTestRepository.getRunTestEntityDetails(programId, // migrationType,
							 * migrationSubType, testname, neName);
							 * 
							 * if (sheetDetails != null) { for (String sheet : sheetDetails) {
							 * ciqUploadRepository .insertChecklistDetails(
							 * CommonUtil.createMongoDbFileNameCheckList(sProgramId, checklistFileName,
							 * ciqFileName), sheet, neName, remarks, runTestEntityMap.get(neId).getId()); }
							 * checkListCount.getAndIncrement(); } }
							 */
							StringBuilder outputFilePath = new StringBuilder();

							StringBuilder comFilePath = new StringBuilder();
							String scriptArguments = scriptEntity.getArguments();

							// Template changes starts
							String connectionLocationUserName = null;
							String connectionLocationPwd = "";
							String connectionSudoPassword = "";

							ProgramTemplateEntity programTemplateEntity = fileUploadRepository
									.getProgramTemplate(programId, Constants.SCRIPT_STORE_TEMPLATE);
							if (programTemplateEntity != null) {
								if (programTemplateEntity.getValue() != null
										&& !programTemplateEntity.getValue().trim().isEmpty()) {
									JSONObject objData = CommonUtil.parseDataToJSON(programTemplateEntity.getValue());
									HashMap connLocation = (HashMap) objData.get("connLocation");

									// NE
									HashMap ne = (HashMap) connLocation.get("NE");
									connectionSudoPassword = ne.get("sudoPassword").toString();
									connectionLocationUserName = ne.get("username").toString();
									connectionLocationPwd = ne.get("password").toString();

								}
							}
							String finalArguments = "";
							// Template changes end
							if (CommonUtil.isValidObject(scriptArguments) && StringUtils.isNotEmpty(scriptArguments)) {
								String[] arguments = scriptArguments.split(Constants.DELIMITER);
								if (CommonUtil.isValidObject(arguments) && arguments.length > 0) {
									for (String argument : arguments) {
										String argPreceeding = "";
										argument = argument.trim();
										if (argument.contains(" ") && argument.contains("-")
												&& argument.startsWith("-")) {
											argPreceeding = StringUtils.substringBefore(argument, " ");
											argPreceeding = argPreceeding.trim();
											argument = StringUtils.substringAfter(argument, " ");
											argument = argument.trim();
										}

										// need to do code optimisation
										UserDetailsEntity userDetailsEntity = userActionRepositoryImpl
												.getUserDetailsBasedName(userName);
										String saneUserName = "";
										String sanePwd = "";
										if (CommonUtil.isValidObject(userDetailsEntity)) {
											saneUserName = userDetailsEntity.getVpnUserName();
										}
										if (useCurrPassword == true) {
											sanePwd = PasswordCrypt.decrypt(userDetailsEntity.getVpnPassword());
										} else {
											sanePwd = sanePassword;
										}
										String newArgument = commonUtil.getArgumentValue(Integer.toString(programId),
												ciqFileName, neId, neName, networkConfigEntity, migrationType,
												migrationSubType, argument, userName, sessionId,
												connectionLocationUserName, connectionLocationPwd,
												connectionSudoPassword, saneUserName, sanePwd);
										if (argPreceeding != null) {
											if (argPreceeding.trim().contains("-")) {
												finalArguments = finalArguments + " " + argPreceeding + " ";
											}
										}
										if (newArgument != null) {
											newArgument = "'" + newArgument + "'";
										}
										finalArguments = finalArguments + newArgument + " ";

									}
								}
							}
							comFilePath.append(LoadPropertyFiles.getInstance().getProperty("BASE_PATH"))
									.append(Constants.CUSTOMER).append(Constants.SEPARATOR).append(programId);

							if (migrationType.equalsIgnoreCase(Constants.MIGRATION)) {

								outputFilePath.append(comFilePath)
										.append(Constants.RUN_MIGRATION_OUTPUT.replace("migration", migrationType)
												.replace("enbId", StringUtils.substringBeforeLast(neId, "."))
												.replace("subtype", migrationSubType).replaceAll(" ", "_"));
								newOutputFilePath.append(comFilePath)
										.append(Constants.RUN_MIGRATION_OUTPUT.replace("migration", migrationType)
												.replace("enbId", StringUtils.substringBeforeLast(neId, "."))
												.replace("subtype", migrationSubType).replaceAll(" ", "_"))
										.append(testname).append("_").append(StringUtils.substringBeforeLast(neId, "."))
										.append("_").append(neName).append("/");

								newOutputFileDBPath.append(Constants.SEPARATOR).append(Constants.CUSTOMER)
										.append(Constants.SEPARATOR).append(programId).append(Constants.SEPARATOR)
										.append(Constants.RUN_MIGRATION_OUTPUT.replace("migration", migrationType)
												.replace("enbId", StringUtils.substringBeforeLast(neId, "."))
												.replace("subtype", migrationSubType).replaceAll(" ", "_"))
										.append(testname).append("_").append(StringUtils.substringBeforeLast(neId, "."))
										.append("_").append(neName).append("/");

								File newFilePath = new File(newOutputFilePath.toString());
								newFilePath.mkdirs();

								File outFilePath = new File(outputFilePath.toString());
								outFilePath.mkdirs();

								outputFileName = outputFilePath + serviceToken + "_" + "output.txt";
								LocalDateTime lsh1 = LocalDateTime.now();
								// logger.error("Executing Script : " + scriptEntity.getFileName() + " NE : " +
								// neId + " at : " + lsh1);

								JSONObject tempCommand = null;
								if (duoData.containsKey("status") && duoData.get("status").equals(Constants.SUCCESS)) {
									tempCommand = getCurlCommandMig(neId, sProgramId, migrationType, scriptEntity,
											neEntity, originalUseCaseName, ciqFileName);
								}

								if (tempCommand != null && tempCommand.containsKey("command")) {
									/*System.out.println("--------------Command-----------");
									System.out.println(tempCommand.get("command").toString());
									System.out.println("--------------Command-----------");*/
									if (isMultipleDUo.get() && sProgramId.equals("34")) {
										logger.error("DB LOGS:  Before Calling duoSession : "+neId);
										shelloutput = duoSessionNeId(userName, outputFileName,
												scriptEntity.getFileName(), duoData,
												tempCommand.get("command").toString(), neId, sProgramId);
										logger.error("DB LOGS:  After Calling duoSession : "+neId);
									}else if (isMultipleDUo.get() && !programName2.contains("4G")) {
										logger.error("DB LOGS:  Before Calling duoSession : "+neId);

										shelloutput = duoSessionAU(userName, outputFileName,
												scriptEntity.getFileName(), duoData,
												tempCommand.get("command").toString(), neId, sProgramId);
										logger.error("DB LOGS:  After Calling duoSession : "+neId);
									} else {
										logger.error("DB LOGS:  Before Calling duoSession : "+neId);

										shelloutput = duoSession(userName, outputFileName, scriptEntity.getFileName(),
												duoData, tempCommand.get("command").toString());
										logger.error("DB LOGS:  After Calling duoSession : "+neId);
									}
									if(shelloutput.contains(lastscriptFileName)) {
										TotalScriptExecute=true;
									}
								} else if (!duoData.containsKey("reason")) {
									shelloutput = executeCommand(fileNameWithPath, outputFileName, finalArguments, "");
								} else {
									shelloutput = duoData.get("reason").toString();
								}

								LocalDateTime lsh2 = LocalDateTime.now();
								// logger.error("Completed Script : " + scriptEntity.getFileName() + " NE : " +
								// neId + " at : " + lsh2);
								dshsec = Duration.between(lsh1, lsh2).getSeconds();
								if (dshsec > Constants.SSH_TIMEOUT && !shelloutput.contains("<rpc-reply")
										&& !shelloutput.contains("</rpc-reply>")) {
									shelloutput = shelloutput + "\n\nMessage from SRCT : SSH Timeout";
								}
								logger.error("Duration for script in server " + scriptEntity.getFileName() + " NE : "
										+ neId + "(HH:mm:ss) : " + String.format("%d:%02d:%02d", dshsec / 3600,
												(dshsec % 3600) / 60, dshsec % 60));

								// Thread.sleep(10000);

								// shelloutput = readFileAsString("/home/user/Desktop/migration_resopnse");
								// shelloutput = readFileAsString("/home/user/Desktop/Sprint_Output_Log.txt");

								// for testing kannan

								// if(networkConfigEntity.getNeTypeEntity().getNeType().equalsIgnoreCase("VLSM")){
								// output = readFileAsString("/home/user/Desktop/Vzn_Output_Log.txt");
								// }else{
								// output = readFileAsString("/home/user/Desktop/Sprint_Output_Log.txt");
								// }

								String timeStamp = new SimpleDateFormat("MMddyyyy_HH_mm_ss")
										.format(new Timestamp(System.currentTimeMillis()));

								if ("PreCheck".equalsIgnoreCase(migrationSubType)
										&& !"CURRENT".equalsIgnoreCase(runType)) {
									String finalFileName = null;
									File fileExist = new File(newOutputFilePath.toString());
									if (fileExist.exists() && fileExist.isDirectory()) {
										String[] files = fileExist.list(); // get the files in String format.
										for (String fileName : files) {
											if (fileName.contains(useCaseName + "_" + scriptFileName)) {
												finalFileName = fileName;
											}
										}
									}

									String path = newOutputFilePath.toString() + finalFileName;

									File fileWithNameExist = new File(path);

									if (fileWithNameExist.exists()) {
										PreviousResuly=new String(Files.readAllBytes(Paths.get(path)), StandardCharsets.UTF_8);
										System.out.println(PreviousResuly);
										fileWithNameExist.delete();
									}
								}

								String newOutputFileName = serviceToken + "_" + useCaseName + "_" + scriptFileName + "_"
										+ timeStamp + ".txt";
								descFinalPath = newOutputFilePath.toString() + newOutputFileName;
								FileWriter fileWriter = new FileWriter(descFinalPath);
								fileWriter.write(shelloutput);
								fileWriter.close();

								// CommonUtil.removeCtrlChars(outputFileName);
								CommonUtil.removeCtrlChars(descFinalPath);

								long sleepTime = getScriptSleepInterval(scriptSeqDetails, scriptId);

								Thread.sleep(sleepTime);

							} else if (migrationType.equalsIgnoreCase(Constants.PRE_MIGRATION)) {

								outputFilePath.append(comFilePath)
										.append(Constants.RUN_MIGRATION_OUTPUT.replace("migration", migrationType)
												.replace("enbId", StringUtils.substringBeforeLast(neId, "."))
												.replace("subtype", migrationSubType).replaceAll(" ", "_"));
								newOutputFilePath.append(comFilePath)
										.append(Constants.RUN_MIGRATION_OUTPUT.replace("migration", migrationType)
												.replace("enbId", StringUtils.substringBeforeLast(neId, "."))
												.replace("subtype", migrationSubType).replaceAll(" ", "_"))
										.append(testname).append("_").append(StringUtils.substringBeforeLast(neId, "."))
										.append("_").append(neName).append("/");

								newOutputFileDBPath.append(Constants.SEPARATOR).append(Constants.CUSTOMER)
										.append(Constants.SEPARATOR).append(programId).append(Constants.SEPARATOR)
										.append(Constants.RUN_MIGRATION_OUTPUT.replace("migration", migrationType)
												.replace("enbId", StringUtils.substringBeforeLast(neId, "."))
												.replace("subtype", migrationSubType).replaceAll(" ", "_"))
										.append(testname).append("_").append(StringUtils.substringBeforeLast(neId, "."))
										.append("_").append(neName).append("/");

								File newFilePath = new File(newOutputFilePath.toString());
								newFilePath.mkdirs();

								File outFilePath = new File(outputFilePath.toString());
								outFilePath.mkdirs();

								outputFileName = outputFilePath + serviceToken + "_" + "output.txt";

								LocalDateTime lsh1 = LocalDateTime.now();
								// logger.error("Executing Script : " + scriptEntity.getFileName() + " NE : " +
								// neId + " at : " + lsh1);
								JSONObject tempCommand = null;
								if (duoData.containsKey("status") && duoData.get("status").equals(Constants.SUCCESS)) {
									tempCommand = getCurlCommandMig(neId, sProgramId, migrationType, scriptEntity,
											neEntity, originalUseCaseName, ciqFileName);
								}

								if (tempCommand != null && tempCommand.containsKey("command")) {
									/*System.out.println("--------------Command-----------");
									System.out.println(tempCommand.get("command").toString());
									System.out.println("--------------Command-----------");*/
									if (isMultipleDUo.get() && sProgramId.equals("34")) {
										logger.error("DB LOGS:  Before Calling duoSession : "+neId);
										shelloutput = duoSessionNeId(userName, outputFileName,
												scriptEntity.getFileName(), duoData,
												tempCommand.get("command").toString(), neId, sProgramId);
										logger.error("DB LOGS:  After Calling duoSession : "+neId);
										//shelloutput = returnshellop(scriptFileName+".xml");
									}else if (isMultipleDUo.get() && !programName2.contains("4G")) {
										logger.error("DB LOGS:  Before Calling duoSession : "+neId);
										shelloutput = duoSessionAU(userName, outputFileName,
												scriptEntity.getFileName(), duoData,
												tempCommand.get("command").toString(), neId, sProgramId);
										logger.error("DB LOGS:  After Calling duoSession : "+neId);
										//shelloutput = returnshellop(scriptFileName+".xml");
									} else {
										logger.error("DB LOGS:  Before Calling duoSession : "+neId);
										shelloutput = duoSession(userName, outputFileName, scriptEntity.getFileName(),
												duoData, tempCommand.get("command").toString());
										logger.error("DB LOGS:  After Calling duoSession : "+neId);
										//shelloutput = returnshellop(scriptFileName+".xml");
									}
								} else if (!duoData.containsKey("reason")) {
									shelloutput = executeCommand(fileNameWithPath, outputFileName, finalArguments, "");
								} else {
									shelloutput = duoData.get("reason").toString();
								}

								LocalDateTime lsh2 = LocalDateTime.now();
								// logger.error("Completed Script : " + scriptEntity.getFileName() + " NE : " +
								// neId + " at : " + lsh2);
								dshsec = Duration.between(lsh1, lsh2).getSeconds();
								if (dshsec > Constants.SSH_TIMEOUT && !shelloutput.contains("<rpc-reply")
										&& !shelloutput.contains("</rpc-reply>")) {
									shelloutput = shelloutput + "\n\nMessage from SRCT : SSH Timeout";
								}
								logger.error("Duration for script in server " + scriptEntity.getFileName() + " NE : "
										+ neId + "(HH:mm:ss) : " + String.format("%d:%02d:%02d", dshsec / 3600,
												(dshsec % 3600) / 60, dshsec % 60));
								// shelloutput = readFileAsString("/home/user/Desktop/Successful_run_log.txt");

								// Thread.sleep(10000);

								// shelloutput = readFileAsString("/home/user/Desktop/migration_resopnse");
								// shelloutput = readFileAsString("/home/user/Desktop/Sprint_Output_Log.txt");

								// for testing kannan

								// if(networkConfigEntity.getNeTypeEntity().getNeType().equalsIgnoreCase("VLSM")){
								// output = readFileAsString("/home/user/Desktop/Vzn_Output_Log.txt");
								// }else{
								// output = readFileAsString("/home/user/Desktop/Sprint_Output_Log.txt");
								// }

								String timeStamp = new SimpleDateFormat("MMddyyyy_HH_mm_ss")
										.format(new Timestamp(System.currentTimeMillis()));

								if ("NEGrow".equalsIgnoreCase(migrationSubType)
										&& !"CURRENT".equalsIgnoreCase(runType)) {
									String finalFileName = null;
									File fileExist = new File(newOutputFilePath.toString());
									if (fileExist.exists() && fileExist.isDirectory()) {
										String[] files = fileExist.list(); // get the files in String format.
										for (String fileName : files) {
											if (fileName.contains(useCaseName + "_" + scriptFileName)) {
												finalFileName = fileName;
											}
										}
									}

									String path = newOutputFilePath.toString() + finalFileName;

									File fileWithNameExist = new File(path);

									if (fileWithNameExist.exists()) {
										fileWithNameExist.delete();
									}
								}

								String newOutputFileName = serviceToken + "_" + useCaseName + "_" + scriptFileName + "_"
										+ timeStamp + ".txt";
								descFinalPath = newOutputFilePath.toString() + newOutputFileName;
								FileWriter fileWriter = new FileWriter(descFinalPath);
								fileWriter.write(shelloutput);
								fileWriter.close();

								// CommonUtil.removeCtrlChars(outputFileName);
								CommonUtil.removeCtrlChars(descFinalPath);

								long sleepTime = getScriptSleepInterval(scriptSeqDetails, scriptId);

								Thread.sleep(sleepTime);

							}

							else if (migrationType.equalsIgnoreCase(Constants.POST_MIGRATION)) {

								outputFilePath.append(comFilePath)
										.append(Constants.RUN_MIGRATION_OUTPUT.replace("migration", migrationType)
												.replace("enbId", StringUtils.substringBeforeLast(neId, "."))
												.replace("subtype", migrationSubType).replaceAll(" ", "_"));

								newOutputFilePath.append(comFilePath)
										.append(Constants.RUN_MIGRATION_OUTPUT.replace("migration", migrationType)
												.replace("enbId", StringUtils.substringBeforeLast(neId, "."))
												.replace("subtype", migrationSubType).replaceAll(" ", "_"))
										.append(testname).append("_").append(StringUtils.substringBeforeLast(neId, "."))
										.append("_").append(neName).append("/");

								newOutputFileDBPath.append(Constants.SEPARATOR).append(Constants.CUSTOMER)
										.append(Constants.SEPARATOR).append(programId).append(Constants.SEPARATOR)
										.append(Constants.RUN_MIGRATION_OUTPUT.replace("migration", migrationType)
												.replace("enbId", StringUtils.substringBeforeLast(neId, "."))
												.replace("subtype", migrationSubType).replaceAll(" ", "_"))
										.append(testname).append("_").append(StringUtils.substringBeforeLast(neId, "."))
										.append("_").append(neName).append("/");

								String timeStamp = new SimpleDateFormat("yyyy-MM-dd_HH:mm:ss").format(new Date());

								auditHtmlFileName.setLength(0);
								auditHtmlFileName.append("AUDIT_" + neId + "_" + timeStamp + ".html");

								auditHtmlFilePath.setLength(0);
								auditHtmlFilePath.append(comFilePath)
										.append(Constants.RUN_MIGRATION_OUTPUT.replace("migration", migrationType)
												.replace("enbId", StringUtils.substringBeforeLast(neId, "."))
												.replace("subtype", migrationSubType).replaceAll(" ", "_"))
										.append(auditHtmlFileName.toString());

								File newFilePath = new File(newOutputFilePath.toString());
								newFilePath.mkdirs();

								File outFilePath = new File(outputFilePath.toString());
								outFilePath.mkdirs();

								outputFileNameAudit = outputFilePath + serviceToken + "_" + "output.txt";

								/*
								 * String dbcollectionFileName = CommonUtil
								 * .createMongoDbFileName(String.valueOf(programId), ciqFileName);
								 * List<CIQDetailsModel> resultList = getCIQDetailsModelList(neId,
								 * dbcollectionFileName);
								 * 
								 * // networkConfigEntity = runTestRepository.getNeType(lsmId); String cduIp =
								 * getEnbOamIp(resultList); String eNodeID = neId; String eNodeName = neName;
								 * 
								 */

								// String subtype = null;
								if ("AUDIT".equalsIgnoreCase(migrationSubType)) {
									// subtype = "Audit"; Audit
									LocalDateTime lsh1 = LocalDateTime.now();
									// logger.error("Executing Script : " + scriptEntity.getFileName() + " NE : " +
									// neId + " at : " + lsh1);
									shelloutput = executeCommand(fileNameWithPath, outputFileNameAudit, finalArguments,
											"");
									LocalDateTime lsh2 = LocalDateTime.now();
									// logger.error("Completed Script : " + scriptEntity.getFileName() + " NE : " +
									// neId + " at : " + lsh2);
									dshsec = Duration.between(lsh1, lsh2).getSeconds();
									if (dshsec > Constants.SSH_TIMEOUT && !shelloutput.contains("<rpc-reply")
											&& !shelloutput.contains("</rpc-reply>")) {
										shelloutput = shelloutput + "\n\nMessage from SRCT : SSH Timeout";
									}
									logger.error("Duration for script in server " + scriptEntity.getFileName()
											+ " NE : " + neId + "(HH:mm:ss) : " + String.format("%d:%02d:%02d",
													dshsec / 3600, (dshsec % 3600) / 60, dshsec % 60));
									// shelloutput = readFileAsString("/home/user/Desktop/audit_response");

									// for testing kannan
									/*
									 * output = readFileAsString("/home/user/Desktop/checkcmdtxt.txt"); if
									 * (networkConfigEntity.getNeTypeEntity().getNeType().equalsIgnoreCase("VLSM"))
									 * { output = readFileAsString("/home/user/Desktop/Vzn_Output_Log.txt"); } else
									 * { output = readFileAsString("/home/user/Desktop/Sprint_Output_Log.txt"); }
									 */
								}
								String path = LoadPropertyFiles.getInstance().getProperty("BASE_PATH") + "Customer/"
										+ programId + "/" + migrationType + "/" + neId + "/" + migrationSubType + "/"
										+ "Output" + "/";

								File duplicatePath = new File(path);
								duplicatePath.mkdirs();

								if ("AUDIT".equalsIgnoreCase(migrationSubType)) {

									timeStamp = new SimpleDateFormat("MMddyyyy_HH_mm_ss")
											.format(new Timestamp(System.currentTimeMillis()));
									String newOutputFileName = serviceToken + "_" + useCaseName + "_" + scriptFileName
											+ "_" + timeStamp + ".txt";
									descFinalPath = newOutputFilePath.toString() + newOutputFileName;
									FileWriter fileWriter = new FileWriter(descFinalPath);
									fileWriter.write(shelloutput);
									fileWriter.close();
								}

								// CommonUtil.removeCtrlChars(outputFileNameAudit);
								CommonUtil.removeCtrlChars(descFinalPath);

							}

							// complted executing

							UseCaseBuilderParamEntity useCaseBuilderParamEntity = null;

							for (int j = 0; j < scriptFinalLst.size(); j++) {
								ArrayList scritlst = (ArrayList) scriptFinalLst.get(j);
								int scriptID = (int) scritlst.get(0);

								if (scriptID == scriptEntity.getId()) {
									int scrpitid12 = (int) scritlst.get(2);
									// code optimisation
									useCaseBuilderParamEntity = getUseCaseBuilderParamEntity(useCaseBuilderEntity,
											scrpitid12);
									if (ObjectUtils.isEmpty(useCaseBuilderParamEntity)) {
										useCaseBuilderParamEntity = useCaseBuilderRepository
												.getUseCaseBuilderParamEntity(scrpitid12);
									}
									// code optimisation
									break;
								}
							}

							LinkedHashSet<UseCaseCmdRuleEntity> useCaseCmdRuleEntityset = useCaseBuilderParamEntity
									.getUseCaseCmdRuleEntitySet().parallelStream()
									.sorted((p1, p2) -> p1.getId().compareTo(p2.getId()))
									.collect((Collectors.toCollection(LinkedHashSet::new)));

							LinkedHashSet<UseCaseShellRuleEntity> useCaseShellRuleEntityset = useCaseBuilderParamEntity
									.getUseCaseShellRuleEntitySet().parallelStream()
									.sorted((p1, p2) -> p1.getId().compareTo(p2.getId()))
									.collect((Collectors.toCollection(LinkedHashSet::new)));

							LinkedHashSet<UseCaseFileRuleEntity> useCaseFileRuleEntityset = useCaseBuilderParamEntity
									.getUseCaseFileRuleEntitySet().parallelStream()
									.sorted((p1, p2) -> p1.getId().compareTo(p2.getId()))
									.collect((Collectors.toCollection(LinkedHashSet::new)));
							LinkedHashSet<UseCaseXmlRuleEntity> useCaseXmlRuleEntityset = useCaseBuilderParamEntity

									.getUseCaseXmlRuleEntitySet().parallelStream()
									.sorted((p1, p2) -> p1.getId().compareTo(p2.getId()))
									.collect((Collectors.toCollection(LinkedHashSet::new)));

							RunTestEntity runTestEntity = runTestEntityMap.get(neId);

							// code optimisation
							UseCaseBuilderEntity useCaseBuilderEntitybyId = useCaseBuilderEntiyMap.get(iUseCaseId);
							;

							/*
							 * if(useCaseBuilderEntiyMap.containsKey(iUseCaseId)) {
							 * useCaseBuilderEntitybyId=useCaseBuilderEntiyMap.get(iUseCaseId); }else {
							 * useCaseBuilderEntitybyId=useCaseBuilderService
							 * .getUseCaseBuilderEntity(iUseCaseId); useCaseBuilderEntiyMap.put(iUseCaseId,
							 * useCaseBuilderEntity); }
							 */
							UploadFileEntity uploadFileEntity = uploadFileEntityMap.get(scriptId);
							ConcurrentHashMap<Integer, List<RunTestResultEntity>> runtestResultEntityListMap = new ConcurrentHashMap<>();
							/*
							 * if(uploadFileEntityMap.containsKey(scriptId)) {
							 * uploadFileEntity=uploadFileEntityMap.get(scriptId); }else { uploadFileEntity=
							 * uploadFileRepository.getUploadFileEntity(scriptId);
							 * uploadFileEntityMap.put(scriptId, uploadFileEntity); }
							 */

							// code optimisation
							for (UseCaseXmlRuleEntity xml : useCaseXmlRuleEntityset) {
								XmlRuleBuilderEntity xmlRuleEntity = xml.getXmlRuleBuilderEntity();
								int xmlRuleOccurenece = xml.getXmlRuleSequence();
								String xmlResult = "FAIL";

								/*
								 * if ("AUDIT".equalsIgnoreCase(migrationSubType)) { shelloutput =
								 * readFileAsString(outputFileNameAudit); }else { shelloutput =
								 * readFileAsString(outputFileName); }
								 */

								xmlResult = xmlParsing(xmlRuleEntity, shelloutput, xmlRuleOccurenece, neName, neId,
										dbcollectionFileName, migrationSubType);

								Object obj = new JSONParser().parse(xmlResult);
								JSONObject jo = (JSONObject) obj;
								xmlResult = (String) jo.get("outputResult");
								Map ruleResultJsonMap = (Map) jo.get("ruleResultJson");
								String ruleResultJson = ruleResultJsonMap.toString();

								if (!"PASS".equalsIgnoreCase(xmlResult)) {
									finalStatusResult = FAILURE;
								}
								RunTestResultEntity updatedRunTestResultEntity = null;
								if ("PreCheck".equalsIgnoreCase(migrationSubType)
										&& !"CURRENT".equalsIgnoreCase(runType)) {
									Set<RunTestResultEntity> objListResultEntity = runTestEntity
											.getRunTestResultEntity();
									if (!ObjectUtils.isEmpty(objListResultEntity)) {

										for (RunTestResultEntity runTestResultEntityXml : objListResultEntity)

										{
											if ((runTestResultEntityXml.getUploadFileEntity() != null)
													&& (runTestResultEntityXml.getXmlRuleBuilderEntity() != null)
													&& (runTestResultEntityXml.getUseCaseBuilderEntity() != null)
													&& (uploadFileEntity.getId().intValue() == runTestResultEntityXml
															.getUploadFileEntity().getId().intValue())
													&& (xmlRuleEntity.getId().intValue() == runTestResultEntityXml
															.getXmlRuleBuilderEntity().getId().intValue())
													&& (useCaseBuilderEntitybyId.getId()
															.intValue() == runTestResultEntityXml
																	.getUseCaseBuilderEntity().getId().intValue())) {
												updatedRunTestResultEntity = runTestResultEntityXml;
												break;
											}

										}

										if (updatedRunTestResultEntity != null) {
											String PreviousResult=updatedRunTestResultEntity.getCurrentResult();
											updatedRunTestResultEntity.setCurrentResult(xmlResult);
											updatedRunTestResultEntity
													.setCurrentScriptOutput(newOutputFileDBPath.toString());
											updatedRunTestResultEntity.setCustomerDetailsEntity(customerDetailsEntity);
											updatedRunTestResultEntity.setMigrationType(migrationType);
											updatedRunTestResultEntity.setMigrationSubType(migrationSubType);
											updatedRunTestResultEntity.setNeName(neId);
											updatedRunTestResultEntity.setRuleResultJson(ruleResultJson);
											updatedRunTestResultEntity.setScriptExeSeq(iScriptExeSeq);
											updatedRunTestResultEntity.setPreviousScriptOutput(PreviousResuly);
											updatedRunTestResultEntity.setPreviousResult(PreviousResult);
										}
									}
								}
								if ("NEGrow".equalsIgnoreCase(migrationSubType)
										&& !"CURRENT".equalsIgnoreCase(runType)) {
									Set<RunTestResultEntity> objListResultEntity = runTestEntity
											.getRunTestResultEntity();
									if (!ObjectUtils.isEmpty(objListResultEntity)) {

										for (RunTestResultEntity runTestResultEntityXml : objListResultEntity)

										{
											if ((runTestResultEntityXml.getUploadFileEntity() != null)
													&& (runTestResultEntityXml.getXmlRuleBuilderEntity() != null)
													&& (runTestResultEntityXml.getUseCaseBuilderEntity() != null)
													&& (uploadFileEntity.getId().intValue() == runTestResultEntityXml
															.getUploadFileEntity().getId().intValue())
													&& (xmlRuleEntity.getId().intValue() == runTestResultEntityXml
															.getXmlRuleBuilderEntity().getId().intValue())
													&& (useCaseBuilderEntitybyId.getId()
															.intValue() == runTestResultEntityXml
																	.getUseCaseBuilderEntity().getId().intValue())) {
												updatedRunTestResultEntity = runTestResultEntityXml;
												break;
											}

										}

										if (updatedRunTestResultEntity != null) {
											updatedRunTestResultEntity.setCurrentResult(xmlResult);
											updatedRunTestResultEntity
													.setCurrentScriptOutput(newOutputFileDBPath.toString());
											updatedRunTestResultEntity.setCustomerDetailsEntity(customerDetailsEntity);
											updatedRunTestResultEntity.setMigrationType(migrationType);
											updatedRunTestResultEntity.setMigrationSubType(migrationSubType);
											updatedRunTestResultEntity.setNeName(neId);
											updatedRunTestResultEntity.setRuleResultJson(ruleResultJson);
											updatedRunTestResultEntity.setScriptExeSeq(iScriptExeSeq);
										}
									}
								}
								RunTestResultEntity runTestResultEntity = new RunTestResultEntity();
								runTestResultEntity.setRunTestEntity(runTestEntity);

								runTestResultEntity.setUseCaseBuilderEntity(useCaseBuilderEntitybyId);
								runTestResultEntity.setUploadFileEntity(uploadFileEntity);

								runTestResultEntity.setXmlRuleBuilderEntity(xmlRuleEntity);

								runTestResultEntity.setCurrentResult(xmlResult);
								runTestResultEntity.setCurrentScriptOutput(newOutputFileDBPath.toString());
								runTestResultEntity.setCustomerDetailsEntity(customerDetailsEntity);
								runTestResultEntity.setMigrationType(migrationType);
								runTestResultEntity.setMigrationSubType(migrationSubType);
								runTestResultEntity.setNeName(neId);
								runTestResultEntity.setRuleResultJson(ruleResultJson);
								runTestResultEntity.setScriptExeSeq(iScriptExeSeq);
								try {
									logger.error("bala scriptname ==="
											+ runTestResultEntity.getUploadFileEntity().getFileName() + " status=== "
											+ runTestResultEntity.getCurrentResult());
								} catch (Exception e) {
									e.printStackTrace();
								}

								if (runtestResultEntityListMap.containsKey(scriptId)) {
									if (updatedRunTestResultEntity != null) {
										runtestResultEntityListMap.get(scriptId).add(updatedRunTestResultEntity);
									} else {
										runtestResultEntityListMap.get(scriptId).add(runTestResultEntity);
									}
								} else {
									List<RunTestResultEntity> runtestResultEntityList = new ArrayList<>();
									if (updatedRunTestResultEntity != null) {
										runtestResultEntityList.add(updatedRunTestResultEntity);
									} else {
										runtestResultEntityList.add(runTestResultEntity);
									}
									runtestResultEntityListMap.put(scriptId, runtestResultEntityList);
								}

								if (updatedRunTestResultEntity != null) {
									runTestResultRepository.updateValueToPrevious(updatedRunTestResultEntity);
								} else {
									runTestResultRepository.createRunTestResult(runTestResultEntity);
								}

							}

							for (UseCaseShellRuleEntity j : useCaseShellRuleEntityset) {
								ShellCmdRuleBuilderEntity shellRuleEntity = j.getShellRuleBuilderEntity();
								int shellRuleOccurence = j.getShellRuleSequence();
								String shellResult = "FAIL";

								/*
								 * if ("AUDIT".equalsIgnoreCase(migrationSubType)) { shelloutput =
								 * readFileAsString(outputFileNameAudit); }else { shelloutput =
								 * readFileAsString(outputFileName); }
								 */

								shellResult = shellProcess(shellRuleEntity, shelloutput, shellRuleOccurence, neName,
										neId);

								if (!"PASS".equalsIgnoreCase(shellResult)) {
									finalStatusResult = FAILURE;
								}

								RunTestResultEntity updatedRunTestResultEntity = null;
								if ("PreCheck".equalsIgnoreCase(migrationSubType)
										&& !"CURRENT".equalsIgnoreCase(runType)) {
									Set<RunTestResultEntity> objListResultEntity = runTestEntity
											.getRunTestResultEntity();
									if (!ObjectUtils.isEmpty(objListResultEntity)) {
										/*
										 * List<RunTestResultEntity>
										 * updatedEntityList=objListResultEntity.stream().filter(X ->
										 * ((X.getUploadFileEntity()!=null) && (X.getShellCmdRuleBuilderEntity()!=null)
										 * && (X.getUseCaseBuilderEntity()!=null) &&
										 * (uploadFileEntity.getId()==X.getUploadFileEntity().getId()) &&
										 * (shellRuleEntity.getId()==X.getShellCmdRuleBuilderEntity().getId()) &&
										 * (useCaseBuilderEntitybyId.getId()==X.getUseCaseBuilderEntity().getId())))
										 * .collect(Collectors.toList());
										 */

										for (RunTestResultEntity runTestResultEntityShell : objListResultEntity)

										{
											if ((runTestResultEntityShell.getUploadFileEntity() != null)
													&& (runTestResultEntityShell.getShellCmdRuleBuilderEntity() != null)
													&& (runTestResultEntityShell.getUseCaseBuilderEntity() != null)
													&& (uploadFileEntity.getId().intValue() == runTestResultEntityShell
															.getUploadFileEntity().getId().intValue())
													&& (shellRuleEntity.getId().intValue() == runTestResultEntityShell
															.getShellCmdRuleBuilderEntity().getId().intValue())
													&& (useCaseBuilderEntitybyId.getId()
															.intValue() == runTestResultEntityShell
																	.getUseCaseBuilderEntity().getId().intValue())) {
												updatedRunTestResultEntity = runTestResultEntityShell;
												break;
											}

										}

										if (updatedRunTestResultEntity != null) {
											updatedRunTestResultEntity.setCurrentResult(shellResult);
											updatedRunTestResultEntity
													.setCurrentScriptOutput(newOutputFileDBPath.toString());
											updatedRunTestResultEntity.setCustomerDetailsEntity(customerDetailsEntity);
											updatedRunTestResultEntity.setMigrationType(migrationType);
											updatedRunTestResultEntity.setMigrationSubType(migrationSubType);
											updatedRunTestResultEntity.setNeName(neId);
											updatedRunTestResultEntity.setScriptExeSeq(iScriptExeSeq);
										}
									}
								}
								if ("NEGrow".equalsIgnoreCase(migrationSubType)
										&& !"CURRENT".equalsIgnoreCase(runType)) {
									Set<RunTestResultEntity> objListResultEntity = runTestEntity
											.getRunTestResultEntity();
									if (!ObjectUtils.isEmpty(objListResultEntity)) {
										/*
										 * List<RunTestResultEntity>
										 * updatedEntityList=objListResultEntity.stream().filter(X ->
										 * ((X.getUploadFileEntity()!=null) && (X.getShellCmdRuleBuilderEntity()!=null)
										 * && (X.getUseCaseBuilderEntity()!=null) &&
										 * (uploadFileEntity.getId()==X.getUploadFileEntity().getId()) &&
										 * (shellRuleEntity.getId()==X.getShellCmdRuleBuilderEntity().getId()) &&
										 * (useCaseBuilderEntitybyId.getId()==X.getUseCaseBuilderEntity().getId())))
										 * .collect(Collectors.toList());
										 */

										for (RunTestResultEntity runTestResultEntityShell : objListResultEntity)

										{
											if ((runTestResultEntityShell.getUploadFileEntity() != null)
													&& (runTestResultEntityShell.getShellCmdRuleBuilderEntity() != null)
													&& (runTestResultEntityShell.getUseCaseBuilderEntity() != null)
													&& (uploadFileEntity.getId().intValue() == runTestResultEntityShell
															.getUploadFileEntity().getId().intValue())
													&& (shellRuleEntity.getId().intValue() == runTestResultEntityShell
															.getShellCmdRuleBuilderEntity().getId().intValue())
													&& (useCaseBuilderEntitybyId.getId()
															.intValue() == runTestResultEntityShell
																	.getUseCaseBuilderEntity().getId().intValue())) {
												updatedRunTestResultEntity = runTestResultEntityShell;
												break;
											}

										}

										if (updatedRunTestResultEntity != null) {
											updatedRunTestResultEntity.setCurrentResult(shellResult);
											updatedRunTestResultEntity
													.setCurrentScriptOutput(newOutputFileDBPath.toString());
											updatedRunTestResultEntity.setCustomerDetailsEntity(customerDetailsEntity);
											updatedRunTestResultEntity.setMigrationType(migrationType);
											updatedRunTestResultEntity.setMigrationSubType(migrationSubType);
											updatedRunTestResultEntity.setNeName(neId);
											updatedRunTestResultEntity.setScriptExeSeq(iScriptExeSeq);
										}
									}
								}

								RunTestResultEntity runTestResultEntity = new RunTestResultEntity();
								runTestResultEntity.setRunTestEntity(runTestEntity);

								runTestResultEntity.setUseCaseBuilderEntity(useCaseBuilderEntitybyId);
								runTestResultEntity.setUploadFileEntity(uploadFileEntity);

								runTestResultEntity.setShellCmdRuleBuilderEntity(shellRuleEntity);

								runTestResultEntity.setCurrentResult(shellResult);
								runTestResultEntity.setCurrentScriptOutput(newOutputFileDBPath.toString());
								runTestResultEntity.setCustomerDetailsEntity(customerDetailsEntity);
								runTestResultEntity.setMigrationType(migrationType);
								runTestResultEntity.setMigrationSubType(migrationSubType);
								runTestResultEntity.setNeName(neId);
								runTestResultEntity.setScriptExeSeq(iScriptExeSeq);

								if (runtestResultEntityListMap.containsKey(scriptId)) {
									if (updatedRunTestResultEntity != null) {
										runtestResultEntityListMap.get(scriptId).add(updatedRunTestResultEntity);
									} else {
										runtestResultEntityListMap.get(scriptId).add(runTestResultEntity);
									}
								} else {
									List<RunTestResultEntity> runtestResultEntityList = new ArrayList<>();
									if (updatedRunTestResultEntity != null) {
										runtestResultEntityList.add(updatedRunTestResultEntity);
									} else {
										runtestResultEntityList.add(runTestResultEntity);
									}
									runtestResultEntityListMap.put(scriptId, runtestResultEntityList);
								}
								if (updatedRunTestResultEntity != null) {
									runTestResultRepository.updateValueToPrevious(updatedRunTestResultEntity);
								} else {
									runTestResultRepository.createRunTestResult(runTestResultEntity);
								}

							}

							for (UseCaseCmdRuleEntity j : useCaseCmdRuleEntityset) {
								CmdRuleBuilderEntity cmdRuleEntity = j.getCmdRuleBuilderEntity();
								int cmRuleOccurence = j.getCommandRuleSequence();
								String cmdResult = "FAIL";

								/*
								 * if ("AUDIT".equalsIgnoreCase(migrationSubType)) { shelloutput =
								 * readFileAsString(outputFileNameAudit); }else { shelloutput =
								 * readFileAsString(outputFileName); }
								 */

								cmdResult = cliProcess(cmdRuleEntity, shelloutput, cmRuleOccurence, neName, neId);

								Object obj = new JSONParser().parse(cmdResult);
								JSONObject jo = (JSONObject) obj;
								cmdResult = (String) jo.get("outputResult");
								Map ruleResultJsonMap = (Map) jo.get("ruleResultJson");
								String ruleResultJson = ruleResultJsonMap.toString();

								if (!"PASS".equalsIgnoreCase(cmdResult)) {
									finalStatusResult = FAILURE;
								}

								RunTestResultEntity updatedRunTestResultEntity = null;
								if ("PreCheck".equalsIgnoreCase(migrationSubType)
										&& !"CURRENT".equalsIgnoreCase(runType)) {
									Set<RunTestResultEntity> objListResultEntity = runTestEntity
											.getRunTestResultEntity();
									if (!ObjectUtils.isEmpty(objListResultEntity)) {

										for (RunTestResultEntity runTestResultEntitycmd : objListResultEntity)

										{
											if ((runTestResultEntitycmd.getUploadFileEntity() != null)
													&& (runTestResultEntitycmd.getCmdRuleBuilderEntity() != null)
													&& (runTestResultEntitycmd.getUseCaseBuilderEntity() != null)
													&& (uploadFileEntity.getId().intValue() == runTestResultEntitycmd
															.getUploadFileEntity().getId().intValue())
													&& (cmdRuleEntity.getId().intValue() == runTestResultEntitycmd
															.getShellCmdRuleBuilderEntity().getId().intValue())
													&& (useCaseBuilderEntitybyId.getId()
															.intValue() == runTestResultEntitycmd
																	.getUseCaseBuilderEntity().getId().intValue())) {
												updatedRunTestResultEntity = runTestResultEntitycmd;
												break;
											}

										}

										if (updatedRunTestResultEntity != null) {
											updatedRunTestResultEntity.setCurrentResult(cmdResult);
											updatedRunTestResultEntity
													.setCurrentScriptOutput(newOutputFileDBPath.toString());
											updatedRunTestResultEntity.setCustomerDetailsEntity(customerDetailsEntity);
											updatedRunTestResultEntity.setMigrationType(migrationType);
											updatedRunTestResultEntity.setMigrationSubType(migrationSubType);
											updatedRunTestResultEntity.setNeName(neId);
											updatedRunTestResultEntity.setRuleResultJson(ruleResultJson);
											updatedRunTestResultEntity.setScriptExeSeq(iScriptExeSeq);

										}
									}
								}
								if ("NEGrow".equalsIgnoreCase(migrationSubType)
										&& !"CURRENT".equalsIgnoreCase(runType)) {
									Set<RunTestResultEntity> objListResultEntity = runTestEntity
											.getRunTestResultEntity();
									if (!ObjectUtils.isEmpty(objListResultEntity)) {

										for (RunTestResultEntity runTestResultEntitycmd : objListResultEntity)

										{
											if ((runTestResultEntitycmd.getUploadFileEntity() != null)
													&& (runTestResultEntitycmd.getCmdRuleBuilderEntity() != null)
													&& (runTestResultEntitycmd.getUseCaseBuilderEntity() != null)
													&& (uploadFileEntity.getId().intValue() == runTestResultEntitycmd
															.getUploadFileEntity().getId().intValue())
													&& (cmdRuleEntity.getId().intValue() == runTestResultEntitycmd
															.getShellCmdRuleBuilderEntity().getId().intValue())
													&& (useCaseBuilderEntitybyId.getId()
															.intValue() == runTestResultEntitycmd
																	.getUseCaseBuilderEntity().getId().intValue())) {
												updatedRunTestResultEntity = runTestResultEntitycmd;
												break;
											}

										}

										if (updatedRunTestResultEntity != null) {
											updatedRunTestResultEntity.setCurrentResult(cmdResult);
											updatedRunTestResultEntity
													.setCurrentScriptOutput(newOutputFileDBPath.toString());
											updatedRunTestResultEntity.setCustomerDetailsEntity(customerDetailsEntity);
											updatedRunTestResultEntity.setMigrationType(migrationType);
											updatedRunTestResultEntity.setMigrationSubType(migrationSubType);
											updatedRunTestResultEntity.setNeName(neId);
											updatedRunTestResultEntity.setRuleResultJson(ruleResultJson);
											updatedRunTestResultEntity.setScriptExeSeq(iScriptExeSeq);

										}
									}
								}

								RunTestResultEntity runTestResultEntity = new RunTestResultEntity();
								runTestResultEntity.setRunTestEntity(runTestEntity);

								runTestResultEntity.setUseCaseBuilderEntity(useCaseBuilderEntitybyId);
								runTestResultEntity.setUploadFileEntity(uploadFileEntity);

								runTestResultEntity.setCmdRuleBuilderEntity(cmdRuleEntity);

								runTestResultEntity.setCurrentResult(cmdResult);
								runTestResultEntity.setCurrentScriptOutput(newOutputFileDBPath.toString());
								runTestResultEntity.setCustomerDetailsEntity(customerDetailsEntity);
								runTestResultEntity.setMigrationType(migrationType);
								runTestResultEntity.setMigrationSubType(migrationSubType);
								runTestResultEntity.setNeName(neId);
								runTestResultEntity.setRuleResultJson(ruleResultJson);
								runTestResultEntity.setScriptExeSeq(iScriptExeSeq);

								if (runtestResultEntityListMap.containsKey(scriptId)) {
									if (updatedRunTestResultEntity != null) {
										runtestResultEntityListMap.get(scriptId).add(updatedRunTestResultEntity);
									} else {
										runtestResultEntityListMap.get(scriptId).add(runTestResultEntity);
									}
								} else {
									List<RunTestResultEntity> runtestResultEntityList = new ArrayList<>();
									if (updatedRunTestResultEntity != null) {
										runtestResultEntityList.add(updatedRunTestResultEntity);
									} else {
										runtestResultEntityList.add(runTestResultEntity);
									}
									runtestResultEntityListMap.put(scriptId, runtestResultEntityList);
								}

								if (updatedRunTestResultEntity != null) {
									runTestResultRepository.updateValueToPrevious(updatedRunTestResultEntity);
								} else {
									runTestResultRepository.createRunTestResult(runTestResultEntity);
								}

							}
							StringBuilder fileFinaloutput = new StringBuilder();
							for (UseCaseFileRuleEntity entity : useCaseFileRuleEntityset) {
								FileRuleBuilderEntity fileRuleEntity = entity.getFileRuleBuilderEntity();

								String fileName1 = "admin_" + fileRuleEntity.getFileName();
								// int count = fileRule.getOccCount();
								int count = 2;
								String serachParam = fileRuleEntity.getSearchParameter();
								String status = fileRuleEntity.getStatus();
								String finalResult = "FAIL";
								String outputString = null;

								boolean result = fileExists(fileName1);
								if (result) {
									Map finalResultMap = paramCount(fileName1, count, serachParam, status);
									outputString = (String) finalResultMap.get("outputString");

									fileFinaloutput = fileFinaloutput.append("\nfileName :").append(fileName1)
											.append("\n").append(outputString);

									FileWriter fileWriter = new FileWriter(descFinalPath, true);
									fileWriter.write(shelloutput);
									fileWriter.close();

									finalResult = (String) finalResultMap.get("status");
								}

								if (!"PASS".equalsIgnoreCase(finalResult)) {
									finalStatusResult = FAILURE;
								}

								RunTestResultEntity updatedRunTestResultEntity = null;
								if ("PreCheck".equalsIgnoreCase(migrationSubType)
										&& !"CURRENT".equalsIgnoreCase(runType)) {
									Set<RunTestResultEntity> objListResultEntity = runTestEntity
											.getRunTestResultEntity();
									if (!ObjectUtils.isEmpty(objListResultEntity)) {

										for (RunTestResultEntity runTestResultEntityFile : objListResultEntity)

										{
											if ((runTestResultEntityFile.getUploadFileEntity() != null)
													&& (runTestResultEntityFile.getFileRuleBuilderEntity() != null)
													&& (runTestResultEntityFile.getUseCaseBuilderEntity() != null)
													&& (uploadFileEntity.getId().intValue() == runTestResultEntityFile
															.getUploadFileEntity().getId().intValue())
													&& (fileRuleEntity.getId().intValue() == runTestResultEntityFile
															.getFileRuleBuilderEntity().getId().intValue())
													&& (useCaseBuilderEntitybyId.getId()
															.intValue() == runTestResultEntityFile
																	.getUseCaseBuilderEntity().getId().intValue())) {
												updatedRunTestResultEntity = runTestResultEntityFile;
												break;
											}

										}
										if (updatedRunTestResultEntity != null) {
											String PreviousResult=updatedRunTestResultEntity.getCurrentResult();
											updatedRunTestResultEntity.setCurrentResult(finalResult);
											updatedRunTestResultEntity
													.setCurrentScriptOutput(newOutputFileDBPath.toString());
											updatedRunTestResultEntity.setCustomerDetailsEntity(customerDetailsEntity);
											updatedRunTestResultEntity.setMigrationType(migrationType);
											updatedRunTestResultEntity.setMigrationSubType(migrationSubType);
											updatedRunTestResultEntity.setNeName(neId);
											updatedRunTestResultEntity.setScriptExeSeq(iScriptExeSeq);
											updatedRunTestResultEntity.setPreviousScriptOutput(PreviousResuly);
											updatedRunTestResultEntity.setPreviousResult(PreviousResult);
										}
									}
								}
								if ("NEGrow".equalsIgnoreCase(migrationSubType)
										&& !"CURRENT".equalsIgnoreCase(runType)) {
									Set<RunTestResultEntity> objListResultEntity = runTestEntity
											.getRunTestResultEntity();
									if (!ObjectUtils.isEmpty(objListResultEntity)) {

										for (RunTestResultEntity runTestResultEntityFile : objListResultEntity)

										{
											if ((runTestResultEntityFile.getUploadFileEntity() != null)
													&& (runTestResultEntityFile.getFileRuleBuilderEntity() != null)
													&& (runTestResultEntityFile.getUseCaseBuilderEntity() != null)
													&& (uploadFileEntity.getId().intValue() == runTestResultEntityFile
															.getUploadFileEntity().getId().intValue())
													&& (fileRuleEntity.getId().intValue() == runTestResultEntityFile
															.getFileRuleBuilderEntity().getId().intValue())
													&& (useCaseBuilderEntitybyId.getId()
															.intValue() == runTestResultEntityFile
																	.getUseCaseBuilderEntity().getId().intValue())) {
												updatedRunTestResultEntity = runTestResultEntityFile;
												break;
											}

										}
										if (updatedRunTestResultEntity != null) {
											updatedRunTestResultEntity.setCurrentResult(finalResult);
											updatedRunTestResultEntity
													.setCurrentScriptOutput(newOutputFileDBPath.toString());
											updatedRunTestResultEntity.setCustomerDetailsEntity(customerDetailsEntity);
											updatedRunTestResultEntity.setMigrationType(migrationType);
											updatedRunTestResultEntity.setMigrationSubType(migrationSubType);
											updatedRunTestResultEntity.setNeName(neId);
											updatedRunTestResultEntity.setScriptExeSeq(iScriptExeSeq);
										}
									}
								}

								RunTestResultEntity runTestResultEntity = new RunTestResultEntity();
								runTestResultEntity.setRunTestEntity(runTestEntity);

								runTestResultEntity.setUseCaseBuilderEntity(useCaseBuilderEntitybyId);
								runTestResultEntity.setUploadFileEntity(uploadFileEntity);

								runTestResultEntity.setFileRuleBuilderEntity(fileRuleEntity);

								runTestResultEntity.setCurrentResult(finalResult);
								runTestResultEntity.setCurrentScriptOutput(newOutputFileDBPath.toString());
								runTestResultEntity.setCustomerDetailsEntity(customerDetailsEntity);
								runTestResultEntity.setMigrationType(migrationType);
								runTestResultEntity.setMigrationSubType(migrationSubType);
								runTestResultEntity.setNeName(neId);
								runTestResultEntity.setScriptExeSeq(iScriptExeSeq);

								if (runtestResultEntityListMap.containsKey(scriptId)) {
									if (updatedRunTestResultEntity != null) {
										runtestResultEntityListMap.get(scriptId).add(updatedRunTestResultEntity);
									} else {
										runtestResultEntityListMap.get(scriptId).add(runTestResultEntity);
									}
								} else {
									List<RunTestResultEntity> runtestResultEntityList = new ArrayList<>();
									if (updatedRunTestResultEntity != null) {
										runtestResultEntityList.add(updatedRunTestResultEntity);
									} else {
										runtestResultEntityList.add(runTestResultEntity);
									}
									runtestResultEntityListMap.put(scriptId, runtestResultEntityList);
								}

								if (updatedRunTestResultEntity != null) {
									runTestResultRepository.updateValueToPrevious(updatedRunTestResultEntity);
								} else {
									runTestResultRepository.createRunTestResult(runTestResultEntity);
								}

								if ("RERUN".equals(runType)) {
									List<RunTestResultEntity> testResultEntity = runTestResultRepository
											.getPreviousRunTestResult(runTestEntityMap.get(neId).getId());
									for (RunTestResultEntity rtre : testResultEntity) {
										rtre.setPreviousResult(rtre.getCurrentResult());
										rtre.setCurrentResult(finalResult);
										rtre.setPreviousScriptOutput(rtre.getCurrentScriptOutput());
										rtre.setCurrentScriptOutput(shelloutput);

										runTestResultRepository.updateValueToPrevious(rtre);

										RunTestEntity runTest = runTestRepository
												.getRunTestEntity(runTestEntityMap.get(neId).getId());
										runTest.setCreationDate(new Date());
										runTestEntityMap.get(neId).setCreationDate(new Date());
										runTestRepository.updateRunTest(runTest);

									}
								} else {

									runTestResultRepository.createRunTestResult(runTestResultEntity);
								}

							}

							if (useCaseFileRuleEntityset.isEmpty() && useCaseCmdRuleEntityset.isEmpty()
									&& useCaseXmlRuleEntityset.isEmpty() && useCaseShellRuleEntityset.isEmpty()) {
								RunTestResultEntity updatedRunTestResultEntity = null;
								if ("PreCheck".equalsIgnoreCase(migrationSubType)
										&& !"CURRENT".equalsIgnoreCase(runType)) {
									Set<RunTestResultEntity> objListResultEntity = runTestEntity
											.getRunTestResultEntity();
									if (!ObjectUtils.isEmpty(objListResultEntity)) {

										for (RunTestResultEntity runTestResultEntityUploadFile : objListResultEntity)

										{
											if ((runTestResultEntityUploadFile.getUploadFileEntity() != null)
													&& (runTestResultEntityUploadFile.getUseCaseBuilderEntity() != null)
													&& (uploadFileEntity.getId()
															.intValue() == runTestResultEntityUploadFile
																	.getUploadFileEntity().getId().intValue())
													&& (useCaseBuilderEntitybyId.getId()
															.intValue() == runTestResultEntityUploadFile
																	.getUseCaseBuilderEntity().getId().intValue())) {
												updatedRunTestResultEntity = runTestResultEntityUploadFile;
												break;
											}

										}

										if (updatedRunTestResultEntity != null) {
											updatedRunTestResultEntity.setCurrentResult("PASS");
											updatedRunTestResultEntity
													.setCurrentScriptOutput(newOutputFileDBPath.toString());
											updatedRunTestResultEntity.setCustomerDetailsEntity(customerDetailsEntity);
											updatedRunTestResultEntity.setMigrationType(migrationType);
											updatedRunTestResultEntity.setMigrationSubType(migrationSubType);
											updatedRunTestResultEntity.setNeName(neId);
											updatedRunTestResultEntity.setScriptExeSeq(iScriptExeSeq);
										}

									}
								}
								if ("NEGrow".equalsIgnoreCase(migrationSubType)
										&& !"CURRENT".equalsIgnoreCase(runType)) {
									Set<RunTestResultEntity> objListResultEntity = runTestEntity
											.getRunTestResultEntity();
									if (!ObjectUtils.isEmpty(objListResultEntity)) {

										for (RunTestResultEntity runTestResultEntityUploadFile : objListResultEntity)

										{
											if ((runTestResultEntityUploadFile.getUploadFileEntity() != null)
													&& (runTestResultEntityUploadFile.getUseCaseBuilderEntity() != null)
													&& (uploadFileEntity.getId()
															.intValue() == runTestResultEntityUploadFile
																	.getUploadFileEntity().getId().intValue())
													&& (useCaseBuilderEntitybyId.getId()
															.intValue() == runTestResultEntityUploadFile
																	.getUseCaseBuilderEntity().getId().intValue())) {
												updatedRunTestResultEntity = runTestResultEntityUploadFile;
												break;
											}

										}

										if (updatedRunTestResultEntity != null) {
											updatedRunTestResultEntity.setCurrentResult("PASS");
											updatedRunTestResultEntity
													.setCurrentScriptOutput(newOutputFileDBPath.toString());
											updatedRunTestResultEntity.setCustomerDetailsEntity(customerDetailsEntity);
											updatedRunTestResultEntity.setMigrationType(migrationType);
											updatedRunTestResultEntity.setMigrationSubType(migrationSubType);
											updatedRunTestResultEntity.setNeName(neId);
											updatedRunTestResultEntity.setScriptExeSeq(iScriptExeSeq);
										}

									}
								}

								RunTestResultEntity runTestResultEntity = new RunTestResultEntity();

								// runTestResultEntity.setRunTestId(runTestEntityMap.get(neId).getId());
								runTestResultEntity.setRunTestEntity(runTestEntity);

								runTestResultEntity.setUseCaseBuilderEntity(useCaseBuilderEntitybyId);
								runTestResultEntity.setUploadFileEntity(uploadFileEntity);

								runTestResultEntity.setCurrentResult("PASS");
								runTestResultEntity.setCurrentScriptOutput(newOutputFileDBPath.toString());
								runTestResultEntity.setCustomerDetailsEntity(customerDetailsEntity);
								runTestResultEntity.setMigrationType(migrationType);
								runTestResultEntity.setMigrationSubType(migrationSubType);
								runTestResultEntity.setNeName(neId);
								runTestResultEntity.setScriptExeSeq(iScriptExeSeq);

								if (runtestResultEntityListMap.containsKey(scriptId)) {
									runtestResultEntityListMap.get(scriptId).add(runTestResultEntity);
								} else {
									List<RunTestResultEntity> runtestResultEntityList = new ArrayList<>();
									runtestResultEntityList.add(runTestResultEntity);
									runtestResultEntityListMap.put(scriptId, runtestResultEntityList);
								}

								runTestResultRepository.createRunTestResult(runTestResultEntity);
							}
							// kannan
							// }
							List<RunTestResultEntity> resultList = runtestResultEntityListMap.get(scriptId);
							boolean status = false;
							for (RunTestResultEntity runTestResultEntity : resultList) {
								try {
									logger.error("final bala scriptname ==="
											+ runTestResultEntity.getUploadFileEntity().getFileName() + " status=== "
											+ runTestResultEntity.getCurrentResult());
								} catch (Exception e) {
									e.printStackTrace();
								}
								if (runTestResultEntity.getCurrentResult().equalsIgnoreCase("PASS")) {
									status = true;
								} else {
									status = false;
									break;
								}
							}
							List<RunTestResultEntity> runTestResultEntityList = runTestService.getRunTestResult(runTestEntity.getId());
							ProgressCount=runTestResultEntityList.size();
							String CountProgress=String.valueOf(ProgressCount);
							String ScriptTotal =String.valueOf(TotalScriptCount);
							runTestEntityMap.get(neId).setProgressScript(CountProgress);
							runTestEntityMap.get(neId).setTotalScript(ScriptTotal);
							runTestRepository.updateRunTest(runTestEntityMap.get(neId));
							System.out.println("progress"+ ProgressCount);
							// need to write some code balu

							/*
							 * if (status) {
							 * 
							 * NeMappingModel neMappingModel = new NeMappingModel(); CustomerDetailsEntity
							 * programDetailsEntity = new CustomerDetailsEntity();
							 * programDetailsEntity.setId(programId);
							 * neMappingModel.setProgramDetailsEntity(programDetailsEntity);
							 * neMappingModel.setEnbId(neId); List<NeMappingEntity> neMappingEntities =
							 * neMappingService.getNeMapping(neMappingModel);
							 * 
							 * CheckListScriptDetEntity checkListScriptDetEntity =
							 * useCaseBuilderRepositoryImpl .getCheckListDetails(programId);
							 * List<CheckListScriptDetEntity> CheckListScriptDetails = null; if
							 * ("AUDIT".equalsIgnoreCase(migrationSubType)) { CheckListScriptDetails =
							 * useCaseBuilderRepositoryImpl.getExeseq(programId,
							 * uploadFileEntity.getFileName(), null,
							 * checkListScriptDetEntity.getCheckListFileName()); } else if
							 * ("PreCheck".equalsIgnoreCase(migrationSubType)) { CheckListScriptDetails =
							 * useCaseBuilderRepositoryImpl.getExeseq(programId,
							 * uploadFileEntity.getFileName(), null,
							 * checkListScriptDetEntity.getCheckListFileName()); } else if
							 * ("NEGrow".equalsIgnoreCase(migrationSubType)) { CheckListScriptDetails =
							 * useCaseBuilderRepositoryImpl.getExeseq(programId,
							 * uploadFileEntity.getFileName(), null,
							 * checkListScriptDetEntity.getCheckListFileName()); } else {
							 * CheckListScriptDetails = useCaseBuilderRepositoryImpl.getExeseq(programId,
							 * uploadFileEntity.getFileName(), neMappingEntities.get(0).getSiteConfigType(),
							 * checkListScriptDetEntity.getCheckListFileName()); }
							 * 
							 * List<CheckListModel> checkListModel =
							 * ciqUploadRepository.getCheckListDetails( "checkListModel", neName,
							 * runTestEntity.getId(), CheckListScriptDetails.get(0).getStepIndex()); //
							 * CheckListModel checkListModel = new CheckListModel();
							 * 
							 * CheckListModel createCheckListEntity = new CheckListModel();
							 * createCheckListEntity.setRunTestId(runTestEntity.getId());
							 * createCheckListEntity.setStepIndex(CheckListScriptDetails.get(0).getStepIndex
							 * ());
							 * 
							 * if (!checkListModel.isEmpty()) { LinkedHashMap<String, String> map =
							 * checkListModel.get(0).getCheckListMap(); // LinkedHashMap<String, String> map
							 * = new LinkedHashMap(); map.put("check", "true");
							 * createCheckListEntity.setCheckListMap(map);
							 * 
							 * ciqUploadRepository.updateCheckListFileDetails(createCheckListEntity,
							 * "checkListModel", neName); } }
							 */

							// end bala loop
							boolean pnpExistIssue=false;
							if(originalUseCaseName.contains("pnp")&&shelloutput.contains("The system ID already exists")&&ovNegrow.equalsIgnoreCase("ON")&&ovNeDegrow.equalsIgnoreCase("ON")) {
								pnpExistIssue=true;
							}

							if (!status && "PreCheck".equalsIgnoreCase(migrationSubType)) {

								/*
								 * Map<String,String> failDetails=new HashMap<>();
								 * failDetails.put("useCaseName", useCaseName);
								 * failDetails.put("scriptFileName", scriptFileName);
								 * XmlCommandsConstants.SCRIFT_FAIL_DETAILS.put(serviceToken, scriptFileName);
								 */
								totalTestCompleted.set(true);
								LocalDateTime lshtool2 = LocalDateTime.now();
								long dshtool = Duration.between(lshtool1, lshtool2).getSeconds() - dshsec;
								logger.error("Duration for script in tool " + scriptEntity.getFileName() + " NE : "
										+ neId + "(HH:mm:ss) : " + String.format("%d:%02d:%02d", dshtool / 3600,
												(dshtool % 3600) / 60, dshtool % 60));
								
								break mainloop1;
							}else if (status && "NEGrow".equalsIgnoreCase(migrationSubType)&&originalUseCaseName.contains("pnp")
									&&ovNegrow.equalsIgnoreCase("ON")) {
								totalTestCompleted.set(true);
								//here if pnp run successfully then we break the loop where neCreatin and delete use case  will be terminate ovNeDegrow
								break mainloop1;
							}else if (status && "NEGrow".equalsIgnoreCase(migrationSubType)&&scriptFileName.contains("NeCreation")
									&&ovNegrow.equalsIgnoreCase("ON")&&ovNeDegrow.equalsIgnoreCase("ON")) {
								//logic to check the date of creation if it is more then 5 day then while continue the loop  elae while break the loop
									String outputLog="";
									JSONObject resultjson1=null;
									JSONObject resultjson2=null;
									JSONObject resultjson=null;
									String Date="";
									outputLog = StringUtils.substringAfter(shelloutput, ".sh");
									if(outputLog.contains("probableCause"))
									{
									Object obj = new JSONParser().parse(outputLog);
									resultjson= (JSONObject) obj;
									}
									if(resultjson!=null&&resultjson.containsKey("alarmList")) {
										List<LinkedHashMap> str = (List) resultjson.get("alarmList");
										if(!str.isEmpty()) {
											int i=1;
										System.out.println(str);
										for (Map usecase : str) {
											if (i==1) {
												resultjson1=(JSONObject) usecase;
											}else {
											resultjson2=(JSONObject) usecase;
											}
											i++;
										}
										}
										
									}
									if(resultjson1!=null&&!resultjson1.isEmpty()&&resultjson1.containsKey("probableCause")&&resultjson1.containsKey("alarmTime")
										&&	resultjson2!=null&&!resultjson2.isEmpty()&&resultjson2.containsKey("probableCause")&&resultjson2.containsKey("alarmTime"))
									{
										Date=resultjson1.get("alarmTime").toString();
										System.out.println(Date);
										NecreationResult=true;
									}
									if(!Date.isEmpty()) {
									Date = Date.trim().replaceAll("[^a-zA-Z0-9]", "");
								    Date=  Date.substring(0,8);
									
									SimpleDateFormat sdf = new SimpleDateFormat("yyyyMMdd");
									Date d1 = sdf.parse(Date);
									System.out.println(d1);
									String pattern = "yyyy-MM-dd";
									SimpleDateFormat simpleDateFormat = new SimpleDateFormat(pattern);

									String date = simpleDateFormat.format(new Date());
									date=date.replaceAll("-", "");
									System.out.println(date);
									LocalDateTime lshtool2 = LocalDateTime.now();
									Date d2 = sdf.parse(date);
									System.out.println(d2);
									long difference_In_Time  = d2.getTime() - d1.getTime();
									long difference_In_Days= (difference_In_Time/86400000);
									System.out.println(difference_In_Days);
									System.out.println("--------------Deletion Days -----------"+DeletionDays);
									if(difference_In_Days>DeletionDays) {
										DeletionResult=true;
									}
									}
									
								
								
							}else if (status && "NEGrow".equalsIgnoreCase(migrationSubType)&&scriptFileName.contains("PackageInventory")
									&&ovNegrow.equalsIgnoreCase("ON")&&ovNeDegrow.equalsIgnoreCase("ON")) {
								//in this loop if dejleteNe  run successfull then it will change the pnpstatus to true which 
								//will use to execute the pnp usecase  one more time
								if(DeletionResult) {
									continue mainloop1;
								}else {
									if(NecreationResult&&!DeletionResult) {
										Info="Delete NE  Doesn't meet the Critreia ";
									}else if(!NecreationResult){
										Info="alarmTime is not present in the Necrection Script Response ";
									}
									break mainloop1;
								}
								
							}else if (status && "NEGrow".equalsIgnoreCase(migrationSubType)&&originalUseCaseName.contains("DeleteNE")
									&&ovNegrow.equalsIgnoreCase("ON")&&ovNeDegrow.equalsIgnoreCase("ON")) {
								//in this loop if deleteNe  run successfull then it will change the pnpstatus to true which 
								//will use to execute the pnp usecase  one more time
								pnpstatus=true;
								finalStatusResult = "Success";
								
							}else if (!status && "NEGrow".equalsIgnoreCase(migrationSubType)&&pnpExistIssue
									&&ovNegrow.equalsIgnoreCase("ON")&&ovNeDegrow.equalsIgnoreCase("ON")) {
								continue mainloop1;
							}else if (!status && "NEGrow".equalsIgnoreCase(migrationSubType)) {
								totalTestCompleted.set(true);
								LocalDateTime lshtool2 = LocalDateTime.now();
								long dshtool = Duration.between(lshtool1, lshtool2).getSeconds() - dshsec;
								logger.error("Duration for script in tool " + scriptEntity.getFileName() + " NE : "
										+ neId + "(HH:mm:ss) : " + String.format("%d:%02d:%02d", dshtool / 3600,
												(dshtool % 3600) / 60, dshtool % 60));
							if(scriptFileName.contains("PackageInventory")&&ovNegrow.equalsIgnoreCase("ON")&&ovNeDegrow.equalsIgnoreCase("ON")){
								Info="Delete NE  Doesn't meet the Critreia ";
							}
								break mainloop1;
							}
							LocalDateTime lshtool2 = LocalDateTime.now();
							long dshtool = Duration.between(lshtool1, lshtool2).getSeconds() - dshsec;
							logger.error("Duration for script in tool " + scriptEntity.getFileName() + " NE : " + neId
									+ "(HH:mm:ss) : " + String.format("%d:%02d:%02d", dshtool / 3600,
											(dshtool % 3600) / 60, dshtool % 60));
						}
						
						
					//this if contidion is only for OV run neID
						if (pnpstatus && "NEGrow".equalsIgnoreCase(migrationSubType)) {
							
							for (Entry<Integer, String> file : scriptexeSortedByExeSeqMap.entrySet()) {
								if(file.getValue().contains("pnp")) {
									newPnpKey=file.getKey();
									pnpValue=file.getValue();
								}
							}
							scriptexeSortedByExeSeqMap.clear();
							scriptexeSortedByExeSeqMap.put(newPnpKey, pnpValue);
							//scriptexeSortedByExeSeqMap.remove(PnpKey);
							mainloop1: for (Entry<Integer, String> file : scriptexeSortedByExeSeqMap.entrySet()) {
								// Duration for Script execution
								LocalDateTime lshtool1 = LocalDateTime.now();
								long dshsec = 0;
								// swetha
								String orderFileName = file.getValue();
								String fileNameWithPath = generatedPath.toString() + "/" + orderFileName;
								String dbcollectionFileName = CommonUtil.createMongoDbFileName(String.valueOf(programId),
										ciqFileName);
								String vznEnbIP = fileUploadRepository.getEnBDataByPath(dbcollectionFileName,
										Constants.VZ_GROW_IPPLAN, neId,
										Constants.ORAN_SPRINT_COMM_SCRIPT_eNB_OAM_IP_eNB_S_B_IP);
								String eNB_OAM_IP = fileUploadRepository.getEnBDataByPath(dbcollectionFileName,
										Constants.SPT_GROW_SHEET_FDD_TDD, neId,
										Constants.ORAN_SPRINT_COMM_SCRIPT_8_CHG_IP_ADDR);
								String enbIP = "127.0.0.1";

								if (StringUtils.isNotEmpty(vznEnbIP)) {
									enbIP = vznEnbIP;
								} else if (StringUtils.isNotEmpty(eNB_OAM_IP)) {
									String sprintEnbIP = CommonUtil.getLeftSubStringWithLen(eNB_OAM_IP, 3);
									if (StringUtils.isNotEmpty(sprintEnbIP)) {
										enbIP = sprintEnbIP;
									} else {
										enbIP = eNB_OAM_IP;
									}
								}

								String output = "";
								String shelloutput = "";
								String outputFileName = "";
								String outputFileNameAudit = "";
								StringBuilder newOutputFileDBPath = new StringBuilder();
								StringBuilder newOutputFilePath = new StringBuilder();

								String[] useCaseNameSplit = orderFileName.split("_");
								int iScriptExeSeq = Integer.parseInt(useCaseNameSplit[0]);
								String useCaseName = useCaseNameSplit[2];
								int scriptId = Integer.parseInt(useCaseNameSplit[5].split("\\.")[0]);
								String descFinalPath = "";
								String scriptFileName = useCaseNameSplit[4];
								iUseCaseId = Integer.parseInt(useCaseNameSplit[3]);

								
								// code optimisation
								UseCaseBuilderEntity useCaseBuilderEntity = null;
								if (useCaseBuilderEntiyMap.containsKey(iUseCaseId)) {
									useCaseBuilderEntity = useCaseBuilderEntiyMap.get(iUseCaseId);
								} else {
									useCaseBuilderEntity = runTestRepository.getUseCaseEntity(iUseCaseId);
									useCaseBuilderEntiyMap.put(iUseCaseId, useCaseBuilderEntity);
								}

								String originalUseCaseName = useCaseBuilderEntity.getUseCaseName();

								UploadFileEntity scriptEntity = getUploadFileEntity(useCaseBuilderEntity, scriptId);
								uploadFileEntityMap.put(scriptId, scriptEntity);

								if (ObjectUtils.isEmpty(scriptEntity)) {
									scriptEntity = runTestRepository.getScriptInfo(scriptId);
									uploadFileEntityMap.put(scriptId, scriptEntity);
								}
								
								 
								String scriptAbsFileName = LoadPropertyFiles.getInstance().getProperty("BASE_PATH")
										+ scriptEntity.getFilePath() + "/" + originalUseCaseName.trim().replaceAll(" ", "_")
										+ "/" + scriptEntity.getFileName();

								scriptFilesDetails.put(scriptAbsFileName, scriptEntity.getPrompt());
								
								StringBuilder outputFilePath = new StringBuilder();

								StringBuilder comFilePath = new StringBuilder();
								String scriptArguments = scriptEntity.getArguments();

								// Template changes starts
								String connectionLocationUserName = null;
								String connectionLocationPwd = "";
								String connectionSudoPassword = "";

								ProgramTemplateEntity programTemplateEntity = fileUploadRepository
										.getProgramTemplate(programId, Constants.SCRIPT_STORE_TEMPLATE);
								if (programTemplateEntity != null) {
									if (programTemplateEntity.getValue() != null
											&& !programTemplateEntity.getValue().trim().isEmpty()) {
										JSONObject objData = CommonUtil.parseDataToJSON(programTemplateEntity.getValue());
										HashMap connLocation = (HashMap) objData.get("connLocation");

										// NE
										HashMap ne = (HashMap) connLocation.get("NE");
										connectionSudoPassword = ne.get("sudoPassword").toString();
										connectionLocationUserName = ne.get("username").toString();
										connectionLocationPwd = ne.get("password").toString();

									}
								}
								String finalArguments = "";
								// Template changes end
								if (CommonUtil.isValidObject(scriptArguments) && StringUtils.isNotEmpty(scriptArguments)) {
									String[] arguments = scriptArguments.split(Constants.DELIMITER);
									if (CommonUtil.isValidObject(arguments) && arguments.length > 0) {
										for (String argument : arguments) {
											String argPreceeding = "";
											argument = argument.trim();
											if (argument.contains(" ") && argument.contains("-")
													&& argument.startsWith("-")) {
												argPreceeding = StringUtils.substringBefore(argument, " ");
												argPreceeding = argPreceeding.trim();
												argument = StringUtils.substringAfter(argument, " ");
												argument = argument.trim();
											}

											// need to do code optimisation
											UserDetailsEntity userDetailsEntity = userActionRepositoryImpl
													.getUserDetailsBasedName(userName);
											String saneUserName = "";
											String sanePwd = "";
											if (CommonUtil.isValidObject(userDetailsEntity)) {
												saneUserName = userDetailsEntity.getVpnUserName();
											}
											if (useCurrPassword == true) {
												sanePwd = PasswordCrypt.decrypt(userDetailsEntity.getVpnPassword());
											} else {
												sanePwd = sanePassword;
											}
											String newArgument = commonUtil.getArgumentValue(Integer.toString(programId),
													ciqFileName, neId, neName, networkConfigEntity, migrationType,
													migrationSubType, argument, userName, sessionId,
													connectionLocationUserName, connectionLocationPwd,
													connectionSudoPassword, saneUserName, sanePwd);
											if (argPreceeding != null) {
												if (argPreceeding.trim().contains("-")) {
													finalArguments = finalArguments + " " + argPreceeding + " ";
												}
											}
											if (newArgument != null) {
												newArgument = "'" + newArgument + "'";
											}
											finalArguments = finalArguments + newArgument + " ";

										}
									}
								}
								comFilePath.append(LoadPropertyFiles.getInstance().getProperty("BASE_PATH"))
										.append(Constants.CUSTOMER).append(Constants.SEPARATOR).append(programId);

								 if (migrationType.equalsIgnoreCase(Constants.PRE_MIGRATION)) {

									outputFilePath.append(comFilePath)
											.append(Constants.RUN_MIGRATION_OUTPUT.replace("migration", migrationType)
													.replace("enbId", StringUtils.substringBeforeLast(neId, "."))
													.replace("subtype", migrationSubType).replaceAll(" ", "_"));
									newOutputFilePath.append(comFilePath)
											.append(Constants.RUN_MIGRATION_OUTPUT.replace("migration", migrationType)
													.replace("enbId", StringUtils.substringBeforeLast(neId, "."))
													.replace("subtype", migrationSubType).replaceAll(" ", "_"))
											.append(testname).append("_").append(StringUtils.substringBeforeLast(neId, "."))
											.append("_").append(neName).append("/");

									newOutputFileDBPath.append(Constants.SEPARATOR).append(Constants.CUSTOMER)
											.append(Constants.SEPARATOR).append(programId).append(Constants.SEPARATOR)
											.append(Constants.RUN_MIGRATION_OUTPUT.replace("migration", migrationType)
													.replace("enbId", StringUtils.substringBeforeLast(neId, "."))
													.replace("subtype", migrationSubType).replaceAll(" ", "_"))
											.append(testname).append("_").append(StringUtils.substringBeforeLast(neId, "."))
											.append("_").append(neName).append("/");

									File newFilePath = new File(newOutputFilePath.toString());
									newFilePath.mkdirs();

									File outFilePath = new File(outputFilePath.toString());
									outFilePath.mkdirs();

									outputFileName = outputFilePath + serviceToken + "_" + "output.txt";

									LocalDateTime lsh1 = LocalDateTime.now();
									// logger.error("Executing Script : " + scriptEntity.getFileName() + " NE : " +
									// neId + " at : " + lsh1);
									JSONObject tempCommand = null;
									if (duoData.containsKey("status") && duoData.get("status").equals(Constants.SUCCESS)) {
										tempCommand = getCurlCommandMig(neId, sProgramId, migrationType, scriptEntity,
												neEntity, originalUseCaseName, ciqFileName);
									}

									if (tempCommand != null && tempCommand.containsKey("command")) {
										/*System.out.println("--------------Command-----------");
										System.out.println(tempCommand.get("command").toString());
										System.out.println("--------------Command-----------");*/
										logger.error("DB LOGS:  Before Calling duoSession : "+neId);
										shelloutput = duoSession(userName, outputFileName, scriptEntity.getFileName(),
												duoData, tempCommand.get("command").toString());
										logger.error("DB LOGS:  After Calling duoSession : "+neId);
										//shelloutput = returnshellop("abcd.xml");
									} else if (!duoData.containsKey("reason")) {
										shelloutput = executeCommand(fileNameWithPath, outputFileName, finalArguments, "");
									} else {
										shelloutput = duoData.get("reason").toString();
									}

									LocalDateTime lsh2 = LocalDateTime.now();
									// logger.error("Completed Script : " + scriptEntity.getFileName() + " NE : " +
									// neId + " at : " + lsh2);
									dshsec = Duration.between(lsh1, lsh2).getSeconds();
									if (dshsec > Constants.SSH_TIMEOUT && !shelloutput.contains("<rpc-reply")
											&& !shelloutput.contains("</rpc-reply>")) {
										shelloutput = shelloutput + "\n\nMessage from SRCT : SSH Timeout";
									}
									logger.error("Duration for script in server " + scriptEntity.getFileName() + " NE : "
											+ neId + "(HH:mm:ss) : " + String.format("%d:%02d:%02d", dshsec / 3600,
													(dshsec % 3600) / 60, dshsec % 60));
									// shelloutput = readFileAsString("/home/user/Desktop/Successful_run_log.txt");

									// Thread.sleep(10000);

									// shelloutput = readFileAsString("/home/user/Desktop/migration_resopnse");
									// shelloutput = readFileAsString("/home/user/Desktop/Sprint_Output_Log.txt");

									// for testing kannan

									// if(networkConfigEntity.getNeTypeEntity().getNeType().equalsIgnoreCase("VLSM")){
									// output = readFileAsString("/home/user/Desktop/Vzn_Output_Log.txt");
									// }else{
									// output = readFileAsString("/home/user/Desktop/Sprint_Output_Log.txt");
									// }

									String timeStamp = new SimpleDateFormat("MMddyyyy_HH_mm_ss")
											.format(new Timestamp(System.currentTimeMillis()));

									

									String newOutputFileName = serviceToken + "_" + useCaseName + "_" + scriptFileName + "_"
											+ timeStamp + ".txt";
									descFinalPath = newOutputFilePath.toString() + newOutputFileName;
									FileWriter fileWriter = new FileWriter(descFinalPath);
									fileWriter.write(shelloutput);
									fileWriter.close();

									// CommonUtil.removeCtrlChars(outputFileName);
									CommonUtil.removeCtrlChars(descFinalPath);

									long sleepTime = getScriptSleepInterval(scriptSeqDetails, scriptId);

									Thread.sleep(sleepTime);

								}

								

								// complted executing

								UseCaseBuilderParamEntity useCaseBuilderParamEntity = null;

								for (int j = 0; j < scriptFinalLst.size(); j++) {
									ArrayList scritlst = (ArrayList) scriptFinalLst.get(j);
									int scriptID = (int) scritlst.get(0);

									if (scriptID == scriptEntity.getId()) {
										int scrpitid12 = (int) scritlst.get(2);
										// code optimisation
										useCaseBuilderParamEntity = getUseCaseBuilderParamEntity(useCaseBuilderEntity,
												scrpitid12);
										if (ObjectUtils.isEmpty(useCaseBuilderParamEntity)) {
											useCaseBuilderParamEntity = useCaseBuilderRepository
													.getUseCaseBuilderParamEntity(scrpitid12);
										}
										// code optimisation
										break;
									}
								}

								LinkedHashSet<UseCaseCmdRuleEntity> useCaseCmdRuleEntityset = useCaseBuilderParamEntity
										.getUseCaseCmdRuleEntitySet().parallelStream()
										.sorted((p1, p2) -> p1.getId().compareTo(p2.getId()))
										.collect((Collectors.toCollection(LinkedHashSet::new)));

								LinkedHashSet<UseCaseShellRuleEntity> useCaseShellRuleEntityset = useCaseBuilderParamEntity
										.getUseCaseShellRuleEntitySet().parallelStream()
										.sorted((p1, p2) -> p1.getId().compareTo(p2.getId()))
										.collect((Collectors.toCollection(LinkedHashSet::new)));

								LinkedHashSet<UseCaseFileRuleEntity> useCaseFileRuleEntityset = useCaseBuilderParamEntity
										.getUseCaseFileRuleEntitySet().parallelStream()
										.sorted((p1, p2) -> p1.getId().compareTo(p2.getId()))
										.collect((Collectors.toCollection(LinkedHashSet::new)));
								LinkedHashSet<UseCaseXmlRuleEntity> useCaseXmlRuleEntityset = useCaseBuilderParamEntity

										.getUseCaseXmlRuleEntitySet().parallelStream()
										.sorted((p1, p2) -> p1.getId().compareTo(p2.getId()))
										.collect((Collectors.toCollection(LinkedHashSet::new)));

								RunTestEntity runTestEntity = runTestEntityMap.get(neId);

								// code optimisation
								UseCaseBuilderEntity useCaseBuilderEntitybyId = useCaseBuilderEntiyMap.get(iUseCaseId);
								UploadFileEntity uploadFileEntity = uploadFileEntityMap.get(scriptId);
								ConcurrentHashMap<Integer, List<RunTestResultEntity>> runtestResultEntityListMap = new ConcurrentHashMap<>();
								for (UseCaseXmlRuleEntity xml : useCaseXmlRuleEntityset) {
									XmlRuleBuilderEntity xmlRuleEntity = xml.getXmlRuleBuilderEntity();
									int xmlRuleOccurenece = xml.getXmlRuleSequence();
									String xmlResult = "FAIL";

									
									xmlResult = xmlParsing(xmlRuleEntity, shelloutput, xmlRuleOccurenece, neName, neId,
											dbcollectionFileName, migrationSubType);

									Object obj = new JSONParser().parse(xmlResult);
									JSONObject jo = (JSONObject) obj;
									xmlResult = (String) jo.get("outputResult");
									Map ruleResultJsonMap = (Map) jo.get("ruleResultJson");
									String ruleResultJson = ruleResultJsonMap.toString();

									if (!"PASS".equalsIgnoreCase(xmlResult)) {
										finalStatusResult = FAILURE;
									}
									RunTestResultEntity updatedRunTestResultEntity = null;
									
									RunTestResultEntity runTestResultEntity = new RunTestResultEntity();
									runTestResultEntity.setRunTestEntity(runTestEntity);

									runTestResultEntity.setUseCaseBuilderEntity(useCaseBuilderEntitybyId);
									runTestResultEntity.setUploadFileEntity(uploadFileEntity);

									runTestResultEntity.setXmlRuleBuilderEntity(xmlRuleEntity);

									runTestResultEntity.setCurrentResult(xmlResult);
									runTestResultEntity.setCurrentScriptOutput(newOutputFileDBPath.toString());
									runTestResultEntity.setCustomerDetailsEntity(customerDetailsEntity);
									runTestResultEntity.setMigrationType(migrationType);
									runTestResultEntity.setMigrationSubType(migrationSubType);
									runTestResultEntity.setNeName(neId);
									runTestResultEntity.setRuleResultJson(ruleResultJson);
									runTestResultEntity.setScriptExeSeq(iScriptExeSeq);
									try {
										logger.error("bala scriptname ==="
												+ runTestResultEntity.getUploadFileEntity().getFileName() + " status=== "
												+ runTestResultEntity.getCurrentResult());
									} catch (Exception e) {
										e.printStackTrace();
									}

									if (runtestResultEntityListMap.containsKey(scriptId)) {
										if (updatedRunTestResultEntity != null) {
											runtestResultEntityListMap.get(scriptId).add(updatedRunTestResultEntity);
										} else {
											runtestResultEntityListMap.get(scriptId).add(runTestResultEntity);
										}
									} else {
										List<RunTestResultEntity> runtestResultEntityList = new ArrayList<>();
										if (updatedRunTestResultEntity != null) {
											runtestResultEntityList.add(updatedRunTestResultEntity);
										} else {
											runtestResultEntityList.add(runTestResultEntity);
										}
										runtestResultEntityListMap.put(scriptId, runtestResultEntityList);
									}

									if (updatedRunTestResultEntity != null) {
										runTestResultRepository.updateValueToPrevious(updatedRunTestResultEntity);
									} else {
										runTestResultRepository.createRunTestResult(runTestResultEntity);
									}

								}

								for (UseCaseShellRuleEntity j : useCaseShellRuleEntityset) {
									ShellCmdRuleBuilderEntity shellRuleEntity = j.getShellRuleBuilderEntity();
									int shellRuleOccurence = j.getShellRuleSequence();
									String shellResult = "FAIL";

									

									shellResult = shellProcess(shellRuleEntity, shelloutput, shellRuleOccurence, neName,
											neId);

									if (!"PASS".equalsIgnoreCase(shellResult)) {
										finalStatusResult = FAILURE;
									}

									RunTestResultEntity updatedRunTestResultEntity = null;
									
									

									RunTestResultEntity runTestResultEntity = new RunTestResultEntity();
									runTestResultEntity.setRunTestEntity(runTestEntity);

									runTestResultEntity.setUseCaseBuilderEntity(useCaseBuilderEntitybyId);
									runTestResultEntity.setUploadFileEntity(uploadFileEntity);

									runTestResultEntity.setShellCmdRuleBuilderEntity(shellRuleEntity);

									runTestResultEntity.setCurrentResult(shellResult);
									runTestResultEntity.setCurrentScriptOutput(newOutputFileDBPath.toString());
									runTestResultEntity.setCustomerDetailsEntity(customerDetailsEntity);
									runTestResultEntity.setMigrationType(migrationType);
									runTestResultEntity.setMigrationSubType(migrationSubType);
									runTestResultEntity.setNeName(neId);
									runTestResultEntity.setScriptExeSeq(iScriptExeSeq);

									if (runtestResultEntityListMap.containsKey(scriptId)) {
										if (updatedRunTestResultEntity != null) {
											runtestResultEntityListMap.get(scriptId).add(updatedRunTestResultEntity);
										} else {
											runtestResultEntityListMap.get(scriptId).add(runTestResultEntity);
										}
									} else {
										List<RunTestResultEntity> runtestResultEntityList = new ArrayList<>();
										if (updatedRunTestResultEntity != null) {
											runtestResultEntityList.add(updatedRunTestResultEntity);
										} else {
											runtestResultEntityList.add(runTestResultEntity);
										}
										runtestResultEntityListMap.put(scriptId, runtestResultEntityList);
									}
									if (updatedRunTestResultEntity != null) {
										runTestResultRepository.updateValueToPrevious(updatedRunTestResultEntity);
									} else {
										runTestResultRepository.createRunTestResult(runTestResultEntity);
									}

								}

								for (UseCaseCmdRuleEntity j : useCaseCmdRuleEntityset) {
									CmdRuleBuilderEntity cmdRuleEntity = j.getCmdRuleBuilderEntity();
									int cmRuleOccurence = j.getCommandRuleSequence();
									String cmdResult = "FAIL";

									

									cmdResult = cliProcess(cmdRuleEntity, shelloutput, cmRuleOccurence, neName, neId);

									Object obj = new JSONParser().parse(cmdResult);
									JSONObject jo = (JSONObject) obj;
									cmdResult = (String) jo.get("outputResult");
									Map ruleResultJsonMap = (Map) jo.get("ruleResultJson");
									String ruleResultJson = ruleResultJsonMap.toString();

									if (!"PASS".equalsIgnoreCase(cmdResult)) {
										finalStatusResult = FAILURE;
									}

									RunTestResultEntity updatedRunTestResultEntity = null;
									
									if ("NEGrow".equalsIgnoreCase(migrationSubType)
											&& !"CURRENT".equalsIgnoreCase(runType)) {
										Set<RunTestResultEntity> objListResultEntity = runTestEntity
												.getRunTestResultEntity();
										if (!ObjectUtils.isEmpty(objListResultEntity)) {

											for (RunTestResultEntity runTestResultEntitycmd : objListResultEntity)

											{
												if ((runTestResultEntitycmd.getUploadFileEntity() != null)
														&& (runTestResultEntitycmd.getCmdRuleBuilderEntity() != null)
														&& (runTestResultEntitycmd.getUseCaseBuilderEntity() != null)
														&& (uploadFileEntity.getId().intValue() == runTestResultEntitycmd
																.getUploadFileEntity().getId().intValue())
														&& (cmdRuleEntity.getId().intValue() == runTestResultEntitycmd
																.getShellCmdRuleBuilderEntity().getId().intValue())
														&& (useCaseBuilderEntitybyId.getId()
																.intValue() == runTestResultEntitycmd
																		.getUseCaseBuilderEntity().getId().intValue())) {
													updatedRunTestResultEntity = runTestResultEntitycmd;
													break;
												}

											}

											if (updatedRunTestResultEntity != null) {
												updatedRunTestResultEntity.setCurrentResult(cmdResult);
												updatedRunTestResultEntity
														.setCurrentScriptOutput(newOutputFileDBPath.toString());
												updatedRunTestResultEntity.setCustomerDetailsEntity(customerDetailsEntity);
												updatedRunTestResultEntity.setMigrationType(migrationType);
												updatedRunTestResultEntity.setMigrationSubType(migrationSubType);
												updatedRunTestResultEntity.setNeName(neId);
												updatedRunTestResultEntity.setRuleResultJson(ruleResultJson);
												updatedRunTestResultEntity.setScriptExeSeq(iScriptExeSeq);

											}
										}
									}

									RunTestResultEntity runTestResultEntity = new RunTestResultEntity();
									runTestResultEntity.setRunTestEntity(runTestEntity);

									runTestResultEntity.setUseCaseBuilderEntity(useCaseBuilderEntitybyId);
									runTestResultEntity.setUploadFileEntity(uploadFileEntity);

									runTestResultEntity.setCmdRuleBuilderEntity(cmdRuleEntity);

									runTestResultEntity.setCurrentResult(cmdResult);
									runTestResultEntity.setCurrentScriptOutput(newOutputFileDBPath.toString());
									runTestResultEntity.setCustomerDetailsEntity(customerDetailsEntity);
									runTestResultEntity.setMigrationType(migrationType);
									runTestResultEntity.setMigrationSubType(migrationSubType);
									runTestResultEntity.setNeName(neId);
									runTestResultEntity.setRuleResultJson(ruleResultJson);
									runTestResultEntity.setScriptExeSeq(iScriptExeSeq);

									if (runtestResultEntityListMap.containsKey(scriptId)) {
										if (updatedRunTestResultEntity != null) {
											runtestResultEntityListMap.get(scriptId).add(updatedRunTestResultEntity);
										} else {
											runtestResultEntityListMap.get(scriptId).add(runTestResultEntity);
										}
									} else {
										List<RunTestResultEntity> runtestResultEntityList = new ArrayList<>();
										if (updatedRunTestResultEntity != null) {
											runtestResultEntityList.add(updatedRunTestResultEntity);
										} else {
											runtestResultEntityList.add(runTestResultEntity);
										}
										runtestResultEntityListMap.put(scriptId, runtestResultEntityList);
									}

									if (updatedRunTestResultEntity != null) {
										runTestResultRepository.updateValueToPrevious(updatedRunTestResultEntity);
									} else {
										runTestResultRepository.createRunTestResult(runTestResultEntity);
									}

								}
								StringBuilder fileFinaloutput = new StringBuilder();
								for (UseCaseFileRuleEntity entity : useCaseFileRuleEntityset) {
									FileRuleBuilderEntity fileRuleEntity = entity.getFileRuleBuilderEntity();

									String fileName1 = "admin_" + fileRuleEntity.getFileName();
									// int count = fileRule.getOccCount();
									int count = 2;
									String serachParam = fileRuleEntity.getSearchParameter();
									String status = fileRuleEntity.getStatus();
									String finalResult = "FAIL";
									String outputString = null;

									boolean result = fileExists(fileName1);
									if (result) {
										Map finalResultMap = paramCount(fileName1, count, serachParam, status);
										outputString = (String) finalResultMap.get("outputString");

										fileFinaloutput = fileFinaloutput.append("\nfileName :").append(fileName1)
												.append("\n").append(outputString);

										FileWriter fileWriter = new FileWriter(descFinalPath, true);
										fileWriter.write(shelloutput);
										fileWriter.close();

										finalResult = (String) finalResultMap.get("status");
									}

									if (!"PASS".equalsIgnoreCase(finalResult)) {
										finalStatusResult = FAILURE;
									}

									RunTestResultEntity updatedRunTestResultEntity = null;
									
									

									RunTestResultEntity runTestResultEntity = new RunTestResultEntity();
									runTestResultEntity.setRunTestEntity(runTestEntity);

									runTestResultEntity.setUseCaseBuilderEntity(useCaseBuilderEntitybyId);
									runTestResultEntity.setUploadFileEntity(uploadFileEntity);

									runTestResultEntity.setFileRuleBuilderEntity(fileRuleEntity);

									runTestResultEntity.setCurrentResult(finalResult);
									runTestResultEntity.setCurrentScriptOutput(newOutputFileDBPath.toString());
									runTestResultEntity.setCustomerDetailsEntity(customerDetailsEntity);
									runTestResultEntity.setMigrationType(migrationType);
									runTestResultEntity.setMigrationSubType(migrationSubType);
									runTestResultEntity.setNeName(neId);
									runTestResultEntity.setScriptExeSeq(iScriptExeSeq);

									if (runtestResultEntityListMap.containsKey(scriptId)) {
										if (updatedRunTestResultEntity != null) {
											runtestResultEntityListMap.get(scriptId).add(updatedRunTestResultEntity);
										} else {
											runtestResultEntityListMap.get(scriptId).add(runTestResultEntity);
										}
									} else {
										List<RunTestResultEntity> runtestResultEntityList = new ArrayList<>();
										if (updatedRunTestResultEntity != null) {
											runtestResultEntityList.add(updatedRunTestResultEntity);
										} else {
											runtestResultEntityList.add(runTestResultEntity);
										}
										runtestResultEntityListMap.put(scriptId, runtestResultEntityList);
									}

									if (updatedRunTestResultEntity != null) {
										runTestResultRepository.updateValueToPrevious(updatedRunTestResultEntity);
									} else {
										runTestResultRepository.createRunTestResult(runTestResultEntity);
									}

										runTestResultRepository.createRunTestResult(runTestResultEntity);
									

								}

								if (useCaseFileRuleEntityset.isEmpty() && useCaseCmdRuleEntityset.isEmpty()
										&& useCaseXmlRuleEntityset.isEmpty() && useCaseShellRuleEntityset.isEmpty()) {
									RunTestResultEntity updatedRunTestResultEntity = null;
									
									

									RunTestResultEntity runTestResultEntity = new RunTestResultEntity();

									// runTestResultEntity.setRunTestId(runTestEntityMap.get(neId).getId());
									runTestResultEntity.setRunTestEntity(runTestEntity);

									runTestResultEntity.setUseCaseBuilderEntity(useCaseBuilderEntitybyId);
									runTestResultEntity.setUploadFileEntity(uploadFileEntity);

									runTestResultEntity.setCurrentResult("PASS");
									runTestResultEntity.setCurrentScriptOutput(newOutputFileDBPath.toString());
									runTestResultEntity.setCustomerDetailsEntity(customerDetailsEntity);
									runTestResultEntity.setMigrationType(migrationType);
									runTestResultEntity.setMigrationSubType(migrationSubType);
									runTestResultEntity.setNeName(neId);
									runTestResultEntity.setScriptExeSeq(iScriptExeSeq);

									if (runtestResultEntityListMap.containsKey(scriptId)) {
										runtestResultEntityListMap.get(scriptId).add(runTestResultEntity);
									} else {
										List<RunTestResultEntity> runtestResultEntityList = new ArrayList<>();
										runtestResultEntityList.add(runTestResultEntity);
										runtestResultEntityListMap.put(scriptId, runtestResultEntityList);
									}

									runTestResultRepository.createRunTestResult(runTestResultEntity);
								}
								// kannan
								// }
								List<RunTestResultEntity> resultList = runtestResultEntityListMap.get(scriptId);
								boolean status = false;
								for (RunTestResultEntity runTestResultEntity : resultList) {
									try {
										logger.error("final bala scriptname ==="
												+ runTestResultEntity.getUploadFileEntity().getFileName() + " status=== "
												+ runTestResultEntity.getCurrentResult());
									} catch (Exception e) {
										e.printStackTrace();
									}
									if (runTestResultEntity.getCurrentResult().equalsIgnoreCase("PASS")) {
										status = true;
									} else {
										status = false;
										break;
									}
								}

								
								 if (!status && "NEGrow".equalsIgnoreCase(migrationSubType)) {
									totalTestCompleted.set(true);
									LocalDateTime lshtool2 = LocalDateTime.now();
									long dshtool = Duration.between(lshtool1, lshtool2).getSeconds() - dshsec;
									logger.error("Duration for script in tool " + scriptEntity.getFileName() + " NE : "
											+ neId + "(HH:mm:ss) : " + String.format("%d:%02d:%02d", dshtool / 3600,
													(dshtool % 3600) / 60, dshtool % 60));
									continue mainloop1;	//break mainloop1;
								}
								LocalDateTime lshtool2 = LocalDateTime.now();
								long dshtool = Duration.between(lshtool1, lshtool2).getSeconds() - dshsec;
								logger.error("Duration for script in tool " + scriptEntity.getFileName() + " NE : " + neId
										+ "(HH:mm:ss) : " + String.format("%d:%02d:%02d", dshtool / 3600,
												(dshtool % 3600) / 60, dshtool % 60));
							}
							
							
							
						}

						StringBuilder comFilePath = new StringBuilder();
						comFilePath.append(LoadPropertyFiles.getInstance().getProperty("BASE_PATH"))
								.append(Constants.CUSTOMER).append(Constants.SEPARATOR).append(programId);

						StringBuilder outputFilePath = new StringBuilder();

						outputFilePath.append(comFilePath)
								.append(Constants.RUN_MIGRATION_OUTPUT.replace("migration", migrationType)
										.replace("enbId", StringUtils.substringBeforeLast(neId, "."))
										.replace("subtype", migrationSubType).replaceAll(" ", "_"));

						String outputFileName = outputFilePath + serviceToken + "_" + "output.txt";

						CommonUtil.removeCtrlChars(outputFileName);

						if (migrationType.equalsIgnoreCase(Constants.POST_MIGRATION)
								&& "AUDIT".equalsIgnoreCase(migrationSubType)) {
							// swetha
							if (networkConfigEntity.getNeTypeEntity().getNeType().equalsIgnoreCase("VLSM")) {
								createAuditHtmlFile(auditHtmlFilePath.toString(), runTestEntityMap.get(neId).getId(),
										ciqFileName, neId, neName, lsmName, scriptFilesDetails, networkConfigEntity,
										"xml");
							} else if (networkConfigEntity.getNeTypeEntity().getNeType().equalsIgnoreCase("USM")) {
								createAuditHtmlFile(auditHtmlFilePath.toString(), runTestEntityMap.get(neId).getId(),
										ciqFileName, neId, neName, lsmName, scriptFilesDetails, networkConfigEntity,
										"xml");
							} else {
								createAuditHtmlFile(auditHtmlFilePath.toString(), runTestEntityMap.get(neId).getId(),
										ciqFileName, neId, neName, lsmName, scriptFilesDetails, networkConfigEntity,
										"cli");
							}
						}
						// kannankumar ends

						int ucsleep = getUCSleepInterval(useCaseList, iUseCaseId);

						Thread.sleep(ucsleep);
						String fileSavePath = StringUtils.substringBeforeLast(auditHtmlFilePath.toString(), "/");
						fileSavePath = fileSavePath.replace(LoadPropertyFiles.getInstance().getProperty("BASE_PATH"),
								"");

						if ("PreCheck".equalsIgnoreCase(migrationSubType) && !"CURRENT".equalsIgnoreCase(runType)) {

							RunTestEntity finalStatusDataEntity = runTestRepository
									.getRunTestEntity(runTestEntityMap.get(neId).getId());
							Set<RunTestResultEntity> statusOutPutsEntity = finalStatusDataEntity
									.getRunTestResultEntity();
							AtomicBoolean finalResultOutPut = new AtomicBoolean();
							finalResultOutPut.set(false);
							for (RunTestResultEntity locRunTestResultEntity : statusOutPutsEntity) {

								if (!"PASS".equalsIgnoreCase(locRunTestResultEntity.getCurrentResult())) {
									finalResultOutPut.set(true);
								}

							}
							if (finalResultOutPut.get()) {
								finalStatusResult = FAILURE;
							} else {
								finalStatusResult = "Success";
							}

							runTestEntityMap.put(neId, finalStatusDataEntity);
						}
						if ("NEGrow".equalsIgnoreCase(migrationSubType) && !"CURRENT".equalsIgnoreCase(runType)) {

							RunTestEntity finalStatusDataEntity = runTestRepository
									.getRunTestEntity(runTestEntityMap.get(neId).getId());
							Set<RunTestResultEntity> statusOutPutsEntity = finalStatusDataEntity
									.getRunTestResultEntity();
							AtomicBoolean finalResultOutPut = new AtomicBoolean();
							finalResultOutPut.set(false);
							for (RunTestResultEntity locRunTestResultEntity : statusOutPutsEntity) {

								if (!"PASS".equalsIgnoreCase(locRunTestResultEntity.getCurrentResult())) {
									finalResultOutPut.set(true);
								}

							}
							if (finalResultOutPut.get()) {
								finalStatusResult = FAILURE;
							} else {
								finalStatusResult = "Success";
							}

							runTestEntityMap.put(neId, finalStatusDataEntity);
						}
						//update to OV mileStone code
					/*	boolean Type2 = false;
						if(run.containsKey("ovUpdate")) {
						Type2 = (boolean) run.get("ovUpdate");
						}

						if ( TotalScriptExecute && Type2 ) {
							JSONObject ovUpdateJson = new JSONObject();
							ovUpdateJson.put("neid", neId);
							ovUpdateJson.put("programName", programName);
							ovUpdateJson.put("programId", programId);
							ovUpdateJson.put("ciqFileName", ciqFileName);
							ovUpdateJson.put("enbName", neName);
							String orderNo;
							if(migrationSubType.equalsIgnoreCase("AUDIT")) {
								ProgramTemplateEntity programTemplateEntity = fileUploadService.getProgramTemplate(programId,
										Constants.POST_MIGRATION_MILESTONE);
								orderNo=programTemplateEntity.getValue();
							}else {
								ProgramTemplateEntity programTemplateEntity = fileUploadService.getProgramTemplate(programId,
										Constants.MIGRATION_MILESTONE);
								orderNo=programTemplateEntity.getValue().toString();
							}
							String[] Mile=orderNo.split(",");
							
							JSONObject trakerIdDetails = getTrakerIdList(ovUpdateJson,runTestEntityMap);
							logger.error("Tracker details:" + trakerIdDetails);
							String TrackerID="";
							String WorkplanID="";
							String date2=DateUtil.dateToString(new Date(), "yyyy-MM-dd HH:mm:ss");
							if (trakerIdDetails != null && trakerIdDetails.containsKey("trakerjson")) {
								List<TrackerDetailsModel> trakerdetails = (List<TrackerDetailsModel>) trakerIdDetails
										.get("trakerjson");
								if (!ObjectUtils.isEmpty(trakerdetails)) {
								for (TrackerDetailsModel locTrackerDetailsModel : trakerdetails) {
									 TrackerID=locTrackerDetailsModel.getTrackerId();
									 logger.error("TrackerID:" + TrackerID);
								}
								JSONObject workPlanDetailsObject = getWorkPlanIdList(TrackerID);
								
								if (workPlanDetailsObject != null
										&& workPlanDetailsObject.containsKey("workPlanjson")) {
									logger.error("Inside workPlanjson" + workPlanDetailsObject);
									TrackerDetailsModel workTrackerDetailsModel = (TrackerDetailsModel) workPlanDetailsObject
											.get("workPlanjson");
									if (!ObjectUtils.isEmpty(workTrackerDetailsModel)) {
									
									 WorkplanID= workTrackerDetailsModel.getWorkPlanId();
									 logger.error("WorkPlane ID is" + WorkplanID);
									 JSONObject updateJsonAPI = patchMileStone(WorkplanID,migrationSubType,programId,runTestEntityMap,neId,Mile);
									}else {
										 for(int i=0;i<=Mile.length-1;i++) {
										OvTestResultEntity ovTestResultEntity= new OvTestResultEntity();
										ovTestResultEntity.setCurrentResult("["+date2+"]"+"-"+"failed to fetch  workplan ID for Tracker ID:"+TrackerID+",workplane ID fetching API has  empty respond");
										RunTestEntity runTestEntity = getRunTestEntity(runTestEntityMap.get(neId).getId());
										ovTestResultEntity.setRunTestEntity(runTestEntity);
										ovTestResultEntity.setMilestone(Mile[i]);
										runTestRepository.updateRunTestov(ovTestResultEntity);
										runTestEntityMap.get(neId).setOvUpdateStatus("Failure");
										//runTestEntityMap.get(neId).setOvUpdateReason("failed to fetch  workplan ID for Tracker ID:"+TrackerID+",workplane ID fetching API has  empty respond");
										runTestRepository.updateRunTest(runTestEntityMap.get(neId));
										 }
										logger.error("fail in 2nd Api" );
									}
						}else {
							for(int i=0;i<=Mile.length-1;i++) {
							OvTestResultEntity ovTestResultEntity= new OvTestResultEntity();
							ovTestResultEntity.setCurrentResult("["+date2+"]"+"-"+"failed to fetch the workplan ID for Tracker ID:"+TrackerID);
							RunTestEntity runTestEntity = getRunTestEntity(runTestEntityMap.get(neId).getId());
							ovTestResultEntity.setRunTestEntity(runTestEntity);
							ovTestResultEntity.setMilestone(Mile[i]);
							runTestRepository.updateRunTestov(ovTestResultEntity);
							runTestEntityMap.get(neId).setOvUpdateStatus("Failure");
						//	runTestEntityMap.get(neId).setOvUpdateReason("failed to fetch the workplan ID for Tracker ID:"+TrackerID);
							runTestRepository.updateRunTest(runTestEntityMap.get(neId));
							}
							logger.error("fail in 2nd Api" );
						}
								}else{
									for(int i=0;i<=Mile.length-1;i++) {
									OvTestResultEntity ovTestResultEntity= new OvTestResultEntity();
									ovTestResultEntity.setCurrentResult("["+date2+"]"+"-"+"failed to fetch the Tracker ID/ No Tracker ID on OV");
									RunTestEntity runTestEntity = getRunTestEntity(runTestEntityMap.get(neId).getId());
									ovTestResultEntity.setRunTestEntity(runTestEntity);
									ovTestResultEntity.setMilestone(Mile[i]);
									runTestRepository.updateRunTestov(ovTestResultEntity);
									runTestEntityMap.get(neId).setOvUpdateStatus("Failure");
									runTestRepository.updateRunTest(runTestEntityMap.get(neId));
									}
									logger.error("fail in 1nd Api" );
								
								}}else {
									for(int i=0;i<=Mile.length-1;i++) {
									OvTestResultEntity ovTestResultEntity= new OvTestResultEntity();
									if(trakerIdDetails.containsKey("reason")) {
										String reason=trakerIdDetails.get("reason").toString();
												ovTestResultEntity.setCurrentResult("["+date2+"]"+"-"+reason);
									}else {
										ovTestResultEntity.setCurrentResult("["+date2+"]"+"-"+"failed to fetch the Tracker ID/ No Tracker ID on OV ");
									}
									
									//ovTestResultEntity.setCurrentResult("["+date2+"]"+"-"+"failed to fetch the Tracker ID");
									RunTestEntity runTestEntity = getRunTestEntity(runTestEntityMap.get(neId).getId());
									ovTestResultEntity.setRunTestEntity(runTestEntity);
									ovTestResultEntity.setMilestone(Mile[i]);
									runTestRepository.updateRunTestov(ovTestResultEntity);
								runTestEntityMap.get(neId).setOvUpdateStatus("Failure");
								runTestRepository.updateRunTest(runTestEntityMap.get(neId));
									}
								//runTestEntityMap.get(neId).setOvUpdateReason("failed to fetch the Tracker ID " );
								logger.error("fail in 1nd Api" );
								
							}
								
							}*/
						if ("PreCheck".equalsIgnoreCase(migrationSubType) && TotalScriptExecute && Type && 
								(programName.contains("5G-DSS")|| programName.toUpperCase().contains("5G-CBAND"))) {
							runTestEntityMap.get(neId).setResult(auditHtmlFileName.toString());
							runTestEntityMap.get(neId).setResultFilePath(fileSavePath);
							runTestEntityMap.get(neId).setProgressStatus("InProgress");
							runTestEntityMap.get(neId).setStatus(finalStatusResult);

							if (totalTestCompleted.get()) {
								runTestEntityMap.get(neId).setFailedScript("true");
								;
							} else {
								runTestEntityMap.get(neId).setFailedScript("false");
								
							}
							if (StringUtils.isNotEmpty(generateScriptPath)) {
								runTestEntityMap.get(neId).setGenerateScriptPath(
										generateScriptPath.substring(0, generateScriptPath.length() - 1));
							}
							runTestRepository.updateRunTest(runTestEntityMap.get(neId));

							JSONObject result = generatePostAudit(runTestParams, neid, runTestEntityMap);
							
							}else {
								if ("NEGrow".equalsIgnoreCase(migrationSubType) && !Info.isEmpty()) {
									finalStatusResult=FAILURE;	
									runTestEntityMap.get(neId).setTestInfo(Info);
								}
								System.out.println("INFO"+Info);
						runTestEntityMap.get(neId).setResult(auditHtmlFileName.toString());
						runTestEntityMap.get(neId).setResultFilePath(fileSavePath);
						runTestEntityMap.get(neId).setProgressStatus("Completed");
						runTestEntityMap.get(neId).setStatus(finalStatusResult);

						if (totalTestCompleted.get()) {
							runTestEntityMap.get(neId).setFailedScript("true");
							;
						} else {
							runTestEntityMap.get(neId).setFailedScript("false");
							;
						}

						if (StringUtils.isNotEmpty(generateScriptPath)) {
							runTestEntityMap.get(neId).setGenerateScriptPath(
									generateScriptPath.substring(0, generateScriptPath.length() - 1));
						}
						runTestRepository.updateRunTest(runTestEntityMap.get(neId));
							}
						User user = UserSessionPool.getInstance().getSessionUser(sessionId);
						if (migrationType.equalsIgnoreCase(Constants.POST_MIGRATION)
								&& "AUDIT".equalsIgnoreCase(migrationSubType)) {
							reportService.insertPostMigAuditReportDetails(neId, programId,
									customerDetailsEntity.getProgramName(), user.getUserName(), ciqFileName,
									scriptFilesDetails, finalStatusResult, migrationSubType);

							if (run.containsKey("trackerId")) {
								OvScheduledEntity ovScheduledEntity = ovScheduledTaskService
										.getOvScheduledServiceDetails(run.get("trackerId").toString(), neId);

								ovScheduledEntity.setPostMigAuditStatus(finalStatusResult);
								if (finalStatusResult.equals("Success")) {
									// ovScheduledEntity = fetchProcessService.statusUpdateApi(ovScheduledEntity,
									// "PostMigration","",runTestParams.get("programName").toString());
								}

								ovScheduledEntity = ovScheduledTaskService.mergeOvScheduledDetails(ovScheduledEntity);
							}
						} else {
							reportService.insertRunTestReportDetails(runTestParams.get("programName").toString(), neId,
									migType, migSubType, useCaseList, finalStatusResult, user.getUserName());

							if (run.containsKey("trackerId")) {
								OvScheduledEntity ovScheduledEntity = ovScheduledTaskService
										.getOvScheduledServiceDetails(run.get("trackerId").toString(), neId);
								if ("NEGrow".equalsIgnoreCase(migSubType)) {
									ovScheduledEntity.setNeGrowStatus(finalStatusResult);
								} else if ("Migration".equalsIgnoreCase(migType)) {
									ovScheduledEntity.setMigStatus(finalStatusResult);
									if (finalStatusResult.equals("Success")) {
										ovScheduledEntity = fetchProcessService.statusUpdateApi(ovScheduledEntity,
												"Migration", "", runTestParams.get("programName").toString());
									}
								}
								ovScheduledEntity = ovScheduledTaskService.mergeOvScheduledDetails(ovScheduledEntity);
							}
						}

						if ("PreCheck".equalsIgnoreCase(migrationSubType) && "CURRENT".equals(runType)) {
							String jsonText = runTestParams.toJSONString();
							RunTestInputEntity runTestInputEntity = new RunTestInputEntity();
							runTestInputEntity.setRunTestID(runTestEntityMap.get(neId).getId());
							runTestInputEntity.setRunTestInputJson(jsonText);
							runTestRepository.insertRunTestInputDetails(runTestInputEntity);

						} else if ("NEGrow".equalsIgnoreCase(migrationSubType) && "CURRENT".equals(runType)) {
							String jsonText = runTestParams.toJSONString();
							RunTestInputEntity runTestInputEntity = new RunTestInputEntity();
							runTestInputEntity.setRunTestID(runTestEntityMap.get(neId).getId());
							runTestInputEntity.setRunTestInputJson(jsonText);
							runTestRepository.insertRunTestInputDetails(runTestInputEntity);

						}
						auditCriticalParamsService.updateExecStatus(runTestEntityMap.get(neId).getId(), finalStatusResult);
					}
					catch (Exception e) {
						runTestEntityMap.get(neId).setProgressStatus("Completed");
						runTestEntityMap.get(neId).setStatus(FAILURE);
						runTestRepository.updateRunTest(runTestEntityMap.get(neId));
						auditCriticalParamsService.updateExecStatus(runTestEntityMap.get(neId).getId(), FAILURE);
						logger.error("Exception RunTestServiceImpl in getRuntestExecResult() "
								+ ExceptionUtils.getFullStackTrace(e));
					}
					LocalDateTime l2 = LocalDateTime.now();
					logger.error("Completed the thread for NE " + neId + " at : " + l2);
					long duthreadsec = Duration.between(l1, l2).getSeconds();
					logger.error("Duration for thread for NE " + neId + " (HH:mm:ss) : " + String.format("%d:%02d:%02d",
							duthreadsec / 3600, (duthreadsec % 3600) / 60, duthreadsec % 60));
					GlobalStatusMap.userNeQueue.get(userDetailsEntity2.getVpnUserName()).remove(neId);
					
					return Constants.SUCCESS;

				});

			}
			executorservice.shutdown();

		}

		catch (

		Exception e) {
			logger.error(
					"Exception RunTestServiceImpl in getRuntestExecResult() " + ExceptionUtils.getFullStackTrace(e));

			return e.getMessage();
		}

		return Constants.SUCCESS;
	}

	public JSONObject generatePostAudit(JSONObject runTestParams, Map neid, Map<String, RunTestEntity> runTestEntityMap) {
		// TODO Auto-generated method stub
		JSONObject resultMap = new JSONObject();
		JSONObject expiryDetails = null;
		String sessionId = null;
		boolean rfScriptsFlag = false;
		boolean Type = false;
		String serviceToken = null;
		boolean useCurrPassword;
		try {
			sessionId = runTestParams.get("sessionId").toString();
			serviceToken = runTestParams.get("serviceToken").toString();

			Map run = (Map) runTestParams.get("runTestFormDetails");
			useCurrPassword = (boolean) run.get("currentPassword");
			String sanePassword = run.get("password").toString();
			String subType = runTestParams.get("migrationSubType").toString();
			String programName = runTestParams.get("programName").toString();
			Type = (boolean) run.get("prePostAuditFlag");
			int programId = Integer.parseInt(runTestParams.get("programId").toString());
			JSONObject migrationInputs = null;
			JSONObject postmigrationInputs = null;
			List<Map<String, String>> enbList = null;
			// runTestFormDetails.
			Map<String, RunTestEntity> runTestEntity1 = runTestEntityMap;

			List<Map<String, String>> neids = new ArrayList<>();
			neids.add(neid);
			LinkedHashMap<String, String> list3 = new LinkedHashMap<String, String>();
			//list3 = (LinkedHashMap<String, String>) runTestParams.get("runTestFormDetails");
			run.put("neDetails", neids);
			run.remove("scripts");
			String neName = neid.get("neName").toString();
			List<String> neList1 = new ArrayList<>();
			List<Map> neList2 = (List<Map>) run.get("neDetails");
			for (Map neid1 : neList2) {
				String i = neid1.get("neId").toString();
				neList1.add(i);
			}
			List<Map> useCaseLst = null;
			List<Map> scripts = null;
			// if(migrationType.equalsIgnoreCase("PostMigration") &&
			// migrationSubType.equalsIgnoreCase("Audit")){

			// neList1 = (List) run.get("neDetails");
			String migrationType = "postmigration";
			String migrationSubType = "AUDIT";
			useCaseLst = runTestService.getPostMigrationUseCaseList(programId, migrationType, migrationSubType,
					neList1);
			runTestParams.put("migrationSubType", "AUDIT");
			runTestParams.put("migrationType", "postmigration");
			Map<String, String> mapDetails = new HashMap<>();
			Map<String, String> mapDetailsScript = new HashMap<>();
			String timeStampDate = new SimpleDateFormat("yyyy-MM-dd_HH:mm:ss").format(new Date());
			String lsmVersion1 = (String) run.get("lsmVersion1");
			List<Map<String, String>> listDetails = new ArrayList<>();
			List<Map<String, String>> ScriptDetails = new ArrayList<>();
			for (Map usecase : useCaseLst) {
				if (usecase.get("useCaseName").equals("eNB_PostAudit")) {
					String usecaseName = (String) usecase.get("useCaseName");
					mapDetails.put("useCaseName", usecaseName);
					int useCaseId = (int) usecase.get("useCaseId");
					String usID = String.valueOf(useCaseId);
					mapDetails.put("useCaseId", usID);
					int executionSequence = (int) usecase.get("executionSequence");
					String exeSeq = String.valueOf(executionSequence);
					mapDetails.put("executionSequence", exeSeq);
					String ucSleepInterval = (String) usecase.get("ucSleepInterval");
					mapDetails.put("ucSleepInterval", ucSleepInterval);
					listDetails.add(mapDetails);
					run.put("useCase", listDetails);
					scripts = (List<Map>) usecase.get("scripts");

					for (Map Script : scripts) {
						String scriptName = (String) Script.get("scriptName");
						mapDetailsScript.put("scriptName", scriptName);
						mapDetailsScript.put("useCaseName", usecaseName);
						int scriptId = (int) Script.get("scriptId");
						String scriptID = String.valueOf(scriptId);
						mapDetailsScript.put("scriptId", scriptID);
						String scriptSleepInterval = (String) Script.get("scriptSleepInterval");
						String scriptsleepID = String.valueOf(scriptSleepInterval);
						mapDetailsScript.put("scriptSleepInterval", scriptsleepID);
						String useGeneratedScript = (String) Script.get("useGeneratedScript");
						mapDetailsScript.put("useGeneratedScript", useGeneratedScript);
						int scriptExeSequence = (int) Script.get("scriptExeSequence");
						String scripexeseqID = String.valueOf(scriptExeSequence);
						mapDetailsScript.put("scriptExeSequence", scripexeseqID);
						ScriptDetails.add(mapDetailsScript);

					}
					run.put("scripts", ScriptDetails);
					String testName=(String) run.get("testname");
					if(!testName.contains("WFM_")) {
					run.put("lsmId", "");
					}
					String testname = "PostEnbAudit" +"_"+neName+"_"+ timeStampDate;
					run.put("testname", testname);
				}
			}
			runTestParams.put("runTestFormDetails", run);
			run = (Map) runTestParams.get("runTestFormDetails");
			migrationType = runTestParams.get("migrationType").toString();
			if (migrationType.equals("migration")) {
				rfScriptsFlag = (boolean) run.get("rfScriptFlag");
			}
			if (migrationType.equalsIgnoreCase("PreMigration")) {
				migrationType = "Premigration";
			}
			subType = runTestParams.get("migrationSubType").toString();
			expiryDetails = CommonUtil.getSessionExpirationDetails(sessionId);

			if (expiryDetails != null) {
				return expiryDetails;
			}

			JSONObject output = new JSONObject();

			if (useCurrPassword == false && sanePassword.isEmpty()) {

				output = runTestService.getSaneDetailsforPassword(runTestParams);

				if (!output.isEmpty()) {
					resultMap.put("status", "PROMPT");
					resultMap.put("password", output);
					resultMap.put("sessionId", sessionId);
					resultMap.put("serviceToken", serviceToken);
					resultMap.put("requestType", "RUN_TEST");

					return resultMap;
				}
			}

			int programIds = Integer.parseInt(runTestParams.get("programId").toString());
			List<Map> neList = (List<Map>) run.get("neDetails");
			Map runs = (Map) runTestParams.get("runTestFormDetails");
			if (!runs.get("lsmVersion").toString().isEmpty()
					|| migrationType.equalsIgnoreCase("postmigration")) {
				int count = 0;
				NetworkConfigEntity previousNetworkConfigEntity = null;
				for (Map neid2 : neList) {
					NeMappingModel neMappingModelversion = new NeMappingModel();
					CustomerDetailsEntity programDetailsEntityversion = new CustomerDetailsEntity();
					programDetailsEntityversion.setId(programIds);
					neMappingModelversion.setProgramDetailsEntity(programDetailsEntityversion);
					neMappingModelversion.setEnbId(neid2.get("neId").toString());
					NetworkConfigEntity neMappingEntitiesForVersion = runTestRepository
							.getNetWorkEntityDetails(neMappingModelversion);
					if (migrationType.equalsIgnoreCase("postmigration")) {
						if (count == 0) {
							previousNetworkConfigEntity = neMappingEntitiesForVersion;
						} else {
							if (previousNetworkConfigEntity != null && neMappingEntitiesForVersion != null
									&& (!previousNetworkConfigEntity.getId()
											.equals(neMappingEntitiesForVersion.getId()))) {
								resultMap.put("status", Constants.FAIL);
								resultMap.put("sessionId", sessionId);
								resultMap.put("serviceToken", serviceToken);
								resultMap.put("reason", "Selected Sites don't belong to the same SM Version");
								return resultMap;
							}
							previousNetworkConfigEntity = neMappingEntitiesForVersion;
						}
						count++;
					}
					if (neMappingEntitiesForVersion != null) {
						String lsmVersion = neMappingEntitiesForVersion.getNeVersionEntity().getNeVersion();
						if (!lsmVersion.equals(runs.get("lsmVersion"))
								&& !runs.get("lsmVersion").toString().isEmpty()) {
							resultMap.put("status", Constants.FAIL);
							resultMap.put("sessionId", sessionId);
							resultMap.put("serviceToken", serviceToken);
							resultMap.put("reason", "Selected Sites don't belong to the selected SM Version");
							return resultMap;
						}
					} else {
						if (runs.get("lsmVersion").toString().isEmpty()
								|| run.get("lsmName").toString().isEmpty()) {
							resultMap.put("status", Constants.FAIL);
							resultMap.put("sessionId", sessionId);
							resultMap.put("serviceToken", serviceToken);
							resultMap.put("reason", "NE is not Mapped");
							return resultMap;
						}
					}
				}
			}
			String htmlOutputFileName = "";
			if (migrationType.equalsIgnoreCase(Constants.POST_MIGRATION) && "AUDIT".equalsIgnoreCase(subType)) {
				String timeStamp = new SimpleDateFormat("yyyy-MM-dd_HH:mm:ss").format(new Date());
				htmlOutputFileName = "_ORAN_AUDIT_" + timeStamp + ".html";
			}

			String enbStatus = runTestService.getRuntestEnbProgressStatus(runTestParams);

			List<Map> scriptSeqDetails = (List<Map>) run.get("scripts");
			if (scriptSeqDetails.isEmpty()) {
				resultMap.put("status", Constants.FAIL);
				resultMap.put("reason", "No Scripts found to run");
				resultMap.put("sessionId", sessionId);
				resultMap.put("serviceToken", serviceToken);
				return resultMap;
			}
			int xmlScriptsCount = 0;
			if (programName.contains("4G-USM-LIVE") && "Audit".equalsIgnoreCase(subType)) {

				for (Map scriptInfoDetails : scriptSeqDetails) {
					String scriptname = scriptInfoDetails.get("scriptName").toString();
					if (FilenameUtils.getExtension(scriptname).equalsIgnoreCase("xml")) {
						xmlScriptsCount++;
					}
				}
				if (scriptSeqDetails.size() != xmlScriptsCount && xmlScriptsCount != 0) {
					resultMap.put("status", Constants.FAIL);
					resultMap.put("reason", "Select Usecases containing same type of extension");
					resultMap.put("sessionId", sessionId);
					resultMap.put("serviceToken", serviceToken);
					return resultMap;
				}
			}
			int time = 0;

			/*while (!enbStatus.equalsIgnoreCase(Constants.SUCCESS)) {
				Thread.sleep(500);
				time++;
				enbStatus = runTestService.getRuntestEnbProgressStatus(runTestParams);
				if (enbStatus.equalsIgnoreCase(Constants.SUCCESS)) {
					break;
				} else if (time == 24) {
					resultMap.put("status", Constants.FAIL);
					resultMap.put("sessionId", sessionId);
					resultMap.put("serviceToken", serviceToken);
					resultMap.put("reason", "Script is taking longer time to execute then usual");
					return resultMap;
				}
			}*/
			//if (enbStatus.equalsIgnoreCase(Constants.SUCCESS)) {

				programId = Integer.parseInt(runTestParams.get("programId").toString());
				Map runTestFormDetails = (Map) runTestParams.get("runTestFormDetails");

				String testname = runTestFormDetails.get("testname").toString();

				if (migrationType.equalsIgnoreCase(Constants.MIGRATION)) {
					migrationType = "Migration";
				} else if (migrationType.equalsIgnoreCase(Constants.POST_MIGRATION)) {
					migrationType = "PostMigration";
				} else if (migrationType.equalsIgnoreCase(Constants.PRE_MIGRATION)) {
					migrationType = "Premigration";
				}

				if ("precheck".equalsIgnoreCase(subType)) {
					subType = "PreCheck";
				} else if ("commission".equalsIgnoreCase(subType)) {
					subType = "Commission";
				} else if ("postcheck".equalsIgnoreCase(subType)) {
					subType = "PostCheck";
				} else if ("AUDIT".equalsIgnoreCase(subType)) {
					subType = "Audit";
				} else if ("RANATP".equalsIgnoreCase(subType)) {
					subType = "RanATP";
				} else if ("NEGrow".equalsIgnoreCase(subType)) {
					subType = "NEGrow";
				}

				String isTestNamePresent = runTestService.getRunTestEntity(programId, migrationType,
						subType, testname);
				if (isTestNamePresent != Constants.SUCCESS) {
					resultMap.put("status", Constants.FAIL);
					resultMap.put("reason", isTestNamePresent);
					resultMap.put("sessionId", sessionId);
					resultMap.put("serviceToken", serviceToken);
					return resultMap;
				}
				List<LinkedHashMap> useCaseList = (List) run.get("useCase");
				ArrayList<String> useList = new ArrayList<>();
				for (Map usecase : useCaseList) {
					useList.add(usecase.get("useCaseName").toString());
				}
				System.out.println(useCaseList);
				if (!(programName.equals("VZN-4G-FSU"))) {
					for (Map usecase : useCaseList) {
						String useCaseName = usecase.get("useCaseName").toString();
						String rfUseCaseName = useCaseName.replace("CommissionScriptUsecase", "RFUsecase");
						if (useCaseName.contains("CommissionScriptUsecase")
								&& !useList.contains(rfUseCaseName)) {
							String newUseCaseName = useCaseName.replace("CommissionScriptUsecase",
									"RFUsecase");
							boolean isuseCasePresent = runTestService.getusecaseDetails(programId,
									migrationType, subType, newUseCaseName);
							System.out.println(isuseCasePresent);
							if (!isuseCasePresent) {
								resultMap.put("status", Constants.FAIL);
								resultMap.put("reason",
										"Please complete the RF Scipts execution to execute the commission scripts");
								resultMap.put("sessionId", sessionId);
								resultMap.put("serviceToken", serviceToken);
								return resultMap;
							}
						}

					}
				}
				Map<String, RunTestEntity> runTestEntity = runTestService
						.insertRunTestDetails(runTestParams, "");
				Set<String> runtestNeidList = runTestEntity.keySet();
				if (runtestNeidList.size() != neList.size()) {
					List<Map> newNeidList = new ArrayList<>();
					for (Map neid3 : neList) {
						if (runtestNeidList.contains(neid3.get("neId"))) {
							newNeidList.add(neid3);
						}
					}
					runs.put("neDetails", newNeidList);
					runTestParams.put("runTestFormDetails", runs);
				}
				String result = null;

				if ("Audit".equalsIgnoreCase(subType) && (programName.contains("5G") || xmlScriptsCount != 0
						|| programName.contains("4G-FSU"))) {
					JSONObject resultAudit = runTestService.getRuntestExecResult5GDSSPrepost(runTestParams,
							runTestEntity, "CURRENT", htmlOutputFileName, null, rfScriptsFlag, null,
							runTestEntity1);
					result = (String) resultAudit.get("Status");

				} else {
					result = runTestService.getRuntestExecResult(runTestParams, runTestEntity, "CURRENT",
							htmlOutputFileName, null, rfScriptsFlag);
				}
				resultMap.put("runTestEntity", runTestEntity);
				resultMap.put("password", output);
				resultMap.put("sessionId", sessionId);
				resultMap.put("serviceToken", serviceToken);
				if (result.equalsIgnoreCase(Constants.SUCCESS)) {
					resultMap.put("status", Constants.SUCCESS);
				} else {
					resultMap.put("status", Constants.FAIL);
					resultMap.put("reason",
							GlobalInitializerListener.faultCodeMap.get(FaultCodes.COULD_NOT_CONNECT));
				}

			

			
		} catch (Exception e) {
			resultMap.put("sessionId", sessionId);
			resultMap.put("serviceToken", serviceToken);
			resultMap.put("status", Constants.FAIL);
			resultMap.put("reason", e.getMessage());
			logger.info("Exception in runTest() in RunTestController" + ExceptionUtils.getFullStackTrace(e));
		}
		return null;
	}
	
	@SuppressWarnings("unchecked")
	public JSONObject getWorkPlanIdList(String trackerID) {
		JSONObject objWorkplanIdDetails = new JSONObject();
		String URL = null;
		try {
			
			OvGeneralEntity objOvGeneralEntity = customerRepository.getOvlabelTemplate(Constants.OV_URL);
			StringBuilder urlBuilder = new StringBuilder();
			urlBuilder.append(objOvGeneralEntity.getValue());
			urlBuilder.append(Constants.OV_WORKPLANID_URL);
			urlBuilder.append("?");
			urlBuilder.append("wp_template=");
			urlBuilder.append("Project Workplan v2");
			urlBuilder.append("&");
			urlBuilder.append("trackor_id=");
			urlBuilder.append(trackerID);
			urlBuilder.append("&");
			urlBuilder.append("page=");
			urlBuilder.append("1");
			String trakerIdUrl = urlBuilder.toString();
			logger.error("2nd URL: "+trakerIdUrl);
			String authStr = getAuthencationString();
			HttpHeaders headers = new HttpHeaders();
			headers.setAccept(Arrays.asList(MediaType.APPLICATION_JSON));
			headers.setContentType(MediaType.APPLICATION_JSON);
			String base64Creds = Base64.getEncoder().encodeToString(authStr.getBytes());
			// create headers
			headers.add("Authorization", "Basic " + base64Creds);
			@SuppressWarnings("rawtypes")
			HttpEntity requestEntity = new HttpEntity(headers);
			HttpComponentsClientHttpRequestFactory requestFactory = getHttpsConfiguration();
			RestTemplate restTemplate = new RestTemplate(requestFactory);
			ResponseEntity<String> response = restTemplate.exchange(urlBuilder.toString(), HttpMethod.GET,
					requestEntity, String.class);
			int statusCode = response.getStatusCodeValue();

			
			if (200 == statusCode) {
				String trackerIdJson = response.getBody();
				
				logger.error("2nd Api Responce before ObjectMapper :"+ response);
				System.out.println(response);
				List<HashMap<String, String>> workPlanList = new ObjectMapper().readValue(trackerIdJson,
						new TypeReference<List<HashMap<String, String>>>() {
						});
				TrackerDetailsModel trackerDetailsModel = new TrackerDetailsModel();
				logger.error("OV Responce workplanJson :"+ trackerIdJson);
				if (!ObjectUtils.isEmpty(workPlanList)) {
					for (HashMap<String, String> entryData : workPlanList) {
						if(entryData.containsKey("active")&& StringUtils.isNotEmpty(entryData.get("active")) &&
								entryData.get("active").equalsIgnoreCase("true"))
						{
							if (entryData.containsKey("id") && StringUtils.isNotEmpty(entryData.get("id"))) {
								trackerDetailsModel.setWorkPlanId(entryData.get("id"));
								trackerDetailsModel.setWorkPlanStatus(entryData.get("active"));
								System.out.println("workplan Status : "+ entryData.get("active"));
							}
						}
					}
				}

				objWorkplanIdDetails.put("workPlanjson", trackerDetailsModel);
				objWorkplanIdDetails.put("statusCode", response.getStatusCode());
			}
		} catch (HttpClientErrorException e) {
			objWorkplanIdDetails.put("statusCode", e.getStatusCode());
			objWorkplanIdDetails.put("response", e.getResponseBodyAsString());
			logger.error(
					"Exception in connecting  2nd Api " + e);
		} catch (Exception e) {
			logger.info(
					"Exception in getTrakerIdList in FetchProcessServiceImpl " + ExceptionUtils.getFullStackTrace(e));
		}

		return objWorkplanIdDetails;
	}
	
	
	
		public JSONObject patchMileStone(String WorkplanID, String migrationSubType, int programId, Map<String, RunTestEntity> runTestEntityMap,String neId,String[] Mile) {
			 
			JSONObject objWorkplanIdDetails = new JSONObject();
			String orderNo; 
			int pId=programId;
			String date2=DateUtil.dateToString(new Date(), "yyyy-MM-dd HH:mm:ss");
			System.out.println(date2);
			try {
				/*if(migrationSubType.equalsIgnoreCase("AUDIT")) {
					ProgramTemplateEntity programTemplateEntity = fileUploadService.getProgramTemplate(pId,
							Constants.POST_MIGRATION_MILESTONE);
					orderNo=programTemplateEntity.getValue();
				}else {
					ProgramTemplateEntity programTemplateEntity = fileUploadService.getProgramTemplate(pId,
							Constants.MIGRATION_MILESTONE);
					orderNo=programTemplateEntity.getValue().toString();
				}
				String[] Mile=orderNo.split(",");*/
				
				for(int i=0;i<=Mile.length-1;i++) {
				OvGeneralEntity objOvGeneralEntity = customerRepository.getOvlabelTemplate(Constants.OV_URL);
				StringBuilder urlBuilder = new StringBuilder();
				//String authStr = getAuthencationString();
				urlBuilder.append(objOvGeneralEntity.getValue());
				urlBuilder.append(Constants.OV_TASKS_URL);
				urlBuilder.append(WorkplanID);
				urlBuilder.append("/tasks?order_number=");
				String milestone=Mile[i];
				
					urlBuilder.append(milestone);
					//urlBuilder.append("16300.05");
					String trakerIdUrl = urlBuilder.toString();
					logger.error("Tracker URL: "+trakerIdUrl);
				JSONObject body = new JSONObject();
				String actual_finish_date=DateUtil.dateToString(new Date(), Constants.YYYY_MM_DD);
				body.put("actual_finish_date",actual_finish_date);
				System.out.println(body);
				/*HttpHeaders headers = new HttpHeaders();
				headers.setAccept(Arrays.asList(MediaType.APPLICATION_JSON));
				headers.setContentType(MediaType.APPLICATION_JSON);
				String base64Creds = Base64.getEncoder().encodeToString(authStr.getBytes());*/
				// create headers
			//	headers.add("Authorization", "Basic " + base64Creds);
				@SuppressWarnings("rawtypes")
				//HttpEntity requestEntity = new HttpEntity(body,headers);
				
				String authStr = getAuthencationString();
				HttpHeaders headers = new HttpHeaders();
				headers.setAccept(Arrays.asList(MediaType.APPLICATION_JSON));
				headers.setContentType(MediaType.APPLICATION_JSON);
				String base64Creds = Base64.getEncoder().encodeToString(authStr.getBytes());
				headers.add("Authorization", "Basic " + base64Creds);
				HttpEntity<JSONObject> requestEntity = new HttpEntity<>(body, headers);

				HttpComponentsClientHttpRequestFactory requestFactory = new HttpComponentsClientHttpRequestFactory(HttpClients.createDefault());
                requestFactory = getHttpsConfiguration();
                RestTemplate restTemplate = new RestTemplate(new BufferingClientHttpRequestFactory(requestFactory)); 
                List<ClientHttpRequestInterceptor> interceptors = new ArrayList<>();
				interceptors.add(new LoggingRequestInterceptor());
				restTemplate.setInterceptors(interceptors);
				
				
				/*
				HttpComponentsClientHttpRequestFactory requestFactory = new HttpComponentsClientHttpRequestFactory(HttpClients.createDefault());
                requestFactory = getHttpsConfiguration();
                RestTemplate restTemplate = new RestTemplate(new BufferingClientHttpRequestFactory(requestFactory)); 
                List<ClientHttpRequestInterceptor> interceptors = new ArrayList<>();
				interceptors.add(new LoggingRequestInterceptor());
				restTemplate.setInterceptors(interceptors);*/
				try {
				ResponseEntity<String> response = restTemplate.exchange(urlBuilder.toString(), HttpMethod.PATCH,
						requestEntity, String.class);
				logger.error("3rd API Responce without objectmapper :"+ response);
				System.out.println(response);
				int statusCode = response.getStatusCodeValue();
				if (200 == statusCode) {
					String trackerIdJson = response.getBody();
					
					logger.error("OV Responce workplanJson :"+ trackerIdJson);
					if (!ObjectUtils.isEmpty(trackerIdJson)) {
						
						OvTestResultEntity ovTestResultEntity= new OvTestResultEntity();
						ovTestResultEntity.setCurrentResult("["+date2+"]"+"-"+"Successfully MileStone: "+Mile[i]+" Updated for NeId: "+neId);
						ovTestResultEntity.setMilestone(Mile[i]);

						RunTestEntity runTestEntity = getRunTestEntity(runTestEntityMap.get(neId).getId());
						ovTestResultEntity.setRunTestEntity(runTestEntity);
						runTestRepository.updateRunTestov(ovTestResultEntity);
						runTestEntityMap.get(neId).setOvUpdateStatus("Success");
						runTestRepository.updateRunTest(runTestEntityMap.get(neId));
					}else {
						OvTestResultEntity ovTestResultEntity= new OvTestResultEntity();
						ovTestResultEntity.setCurrentResult("["+date2+"]"+"-"+"Failed to  updated the " +Mile[i]+" MileStone for NeId: "+neId+" update URL  is not responding");
						ovTestResultEntity.setMilestone(Mile[i]);

						RunTestEntity runTestEntity = getRunTestEntity(runTestEntityMap.get(neId).getId());
						ovTestResultEntity.setRunTestEntity(runTestEntity);
						runTestRepository.updateRunTestov(ovTestResultEntity);
						runTestEntityMap.get(neId).setOvUpdateStatus("Failure");
						//runTestEntityMap.get(neId).setOvUpdateReason("Failed to  updated the " +orderNo+" MileStone for NeId: "+neId+" update URL  is not responding" );
						runTestRepository.updateRunTest(runTestEntityMap.get(neId));
						logger.error("fail in 3rd Api" );
					}
				}else {
					OvTestResultEntity ovTestResultEntity= new OvTestResultEntity();
					ovTestResultEntity.setCurrentResult("["+date2+"]"+"-"+"Failed to  updated the " +Mile[i]+" MileStone for NeId: "+neId+" update URL  is not responding");
					ovTestResultEntity.setMilestone(Mile[i]);

					RunTestEntity runTestEntity = getRunTestEntity(runTestEntityMap.get(neId).getId());
					ovTestResultEntity.setRunTestEntity(runTestEntity);
					runTestRepository.updateRunTestov(ovTestResultEntity);
				
				runTestEntityMap.get(neId).setOvUpdateStatus("Failure");
				//runTestEntityMap.get(neId).setOvUpdateReason("Failed to  updated the " +orderNo+" MileStone for NeId: "+neId+" update URL  is not responding" );
				runTestRepository.updateRunTest(runTestEntityMap.get(neId));
				logger.error("fail in 3rd Api" );
				}
			} catch (HttpClientErrorException e) {
				objWorkplanIdDetails.put("statusCode", e.getStatusCode());
				objWorkplanIdDetails.put("response", e.getResponseBodyAsString());
				OvTestResultEntity ovTestResultEntity= new OvTestResultEntity();
				ovTestResultEntity.setCurrentResult("["+date2+"]"+"-"+"Failed to  updated the " +Mile[i]+" MileStone for NeId: "+neId+" update URL  is not responding");
				ovTestResultEntity.setMilestone(Mile[i]);

				RunTestEntity runTestEntity = getRunTestEntity(runTestEntityMap.get(neId).getId());
				ovTestResultEntity.setRunTestEntity(runTestEntity);
				runTestRepository.updateRunTestov(ovTestResultEntity);
				runTestEntityMap.get(neId).setOvUpdateStatus("Failure");
				//runTestEntityMap.get(neId).setOvUpdateReason("Failed to  update "+Mile[i]+" MileStone for NeId " + neId +" update URL  is not responding");
				runTestRepository.updateRunTest(runTestEntityMap.get(neId));
				logger.error("fail in 3rd Api" );
			}catch (HttpServerErrorException e) {
				objWorkplanIdDetails.put("statusCode", e.getStatusCode());
				objWorkplanIdDetails.put("response", e.getResponseBodyAsString());
				OvTestResultEntity ovTestResultEntity= new OvTestResultEntity();
				ovTestResultEntity.setCurrentResult("["+date2+"]"+"-"+"Failed to  updated the " +Mile[i]+" MileStone for NeId: "+neId+" update URL  is not responding");
				ovTestResultEntity.setMilestone(Mile[i]);

				RunTestEntity runTestEntity = getRunTestEntity(runTestEntityMap.get(neId).getId());
				ovTestResultEntity.setRunTestEntity(runTestEntity);
				runTestRepository.updateRunTestov(ovTestResultEntity);
				runTestEntityMap.get(neId).setOvUpdateStatus("Failure");
				//runTestEntityMap.get(neId).setOvUpdateReason("Failed to  update "+Mile[i]+" MileStone for NeId " + neId +" update URL  is not responding");
				runTestRepository.updateRunTest(runTestEntityMap.get(neId));
				logger.error("fail in 3rd Api" );
			}
				}} catch (Exception e) {
				logger.info(
						"Exception in getTrakerIdList in FetchProcessServiceImpl " + ExceptionUtils.getFullStackTrace(e));
				OvTestResultEntity ovTestResultEntity= new OvTestResultEntity();
				ovTestResultEntity.setCurrentResult("["+date2+"]"+"-"+"Failed to  updated the  MileStone for NeId: "+neId+" MileStone is missing ");
				//ovTestResultEntity.setMilestone(Mile[i]);

				RunTestEntity runTestEntity = getRunTestEntity(runTestEntityMap.get(neId).getId());
				ovTestResultEntity.setRunTestEntity(runTestEntity);
				runTestRepository.updateRunTestov(ovTestResultEntity);
			
			runTestEntityMap.get(neId).setOvUpdateStatus("Failure");
			//runTestEntityMap.get(neId).setOvUpdateReason("Failed to  updated the " +orderNo+" MileStone for NeId: "+neId+" update URL  is not responding" );
			runTestRepository.updateRunTest(runTestEntityMap.get(neId));
			}

		return objWorkplanIdDetails;
	}
	public JSONObject getTrakerIdList(JSONObject ovUpdateJson, Map<String, RunTestEntity> runTestEntityMap) {
		// TODO Auto-generated method stub
		JSONObject objTrackerIdDetails = new JSONObject();
		String URL = null;
		try {
			OvGeneralEntity objOvGeneralEntity = customerRepository.getOvlabelTemplate(Constants.OV_URL);
			StringBuilder urlBuilder = new StringBuilder();
			urlBuilder.append(objOvGeneralEntity.getValue());
			String authStr = getAuthencationString();
			String enbName=ovUpdateJson.get("enbName").toString();
			String programName =ovUpdateJson.get("programName").toString();
			String programId =ovUpdateJson.get("programId").toString();
			String ciqFileName =ovUpdateJson.get("ciqFileName").toString();
			String neId = ovUpdateJson.get("neid").toString().replaceAll("^0+(?!$)", "");
			
			String dbcollectionFileName = CommonUtil.createMongoDbFileName(String.valueOf(programId),ciqFileName);
			
			String  FuzeProjectID="";//=listCIQDetailsModel.get(0).getCiqMap().get("EquipmentLocation").getHeaderValue();
			System.out.println(FuzeProjectID);
				if (programName.contains("MM")) {
					List<CIQDetailsModel> listCIQDetailsModelDay01 = fileUploadRepository.getEnbTableDetailsRanConfig(ciqFileName, neId, enbName, dbcollectionFileName, "5GNRCIQAU", "");

					FuzeProjectID=listCIQDetailsModelDay01.get(0).getCiqMap().get("FuzeProjId").getHeaderValue();
					URL = Constants.OV_TRACKERID_URL +"P_FUZE_PROJECT_ID_FZ="+FuzeProjectID+"&P_5G_MMW_SCOPE=1";
						
				}
				if (programName.contains("USM-LIVE")) {
					List<CIQDetailsModel> listCIQDetailsModelDay01 = fileUploadRepository.getEnbTableDetailsRanConfig(ciqFileName, neId, enbName, dbcollectionFileName, "CIQUpstateNY", "");
					FuzeProjectID=listCIQDetailsModelDay01.get(0).getCiqMap().get("FuzeProjId").getHeaderValue();
					//FuzeProjectID="2718124";
					URL = Constants.OV_TRACKERID_URL1 +"Project.P_FUZE_PROJECT_ID_FZ="+FuzeProjectID;

				}
				if (programName.contains("DSS")) {
					List<CIQDetailsModel> listCIQDetailsModelDay1 = fileUploadRepository.getEnbTableDetailsRanConfig(ciqFileName, neId, enbName, dbcollectionFileName, "vDUGrowSiteLevel(Day1)CQ", "");
					FuzeProjectID=listCIQDetailsModelDay1.get(0).getCiqMap().get("EquipmentLocation").getHeaderValue();
					URL = Constants.OV_TRACKERID_URL  +"P_FUZE_PROJECT_ID_FZ="+FuzeProjectID+"&P_5G_DSS_SCOPE=1";
					//URL = Constants.OV_TRACKERID_URL + "view=L:SRCTDSS&filter=L:SRCTDSS"+"D-0";
				}
				if (programName.contains("CBAND")) {
					List<CIQDetailsModel> listCIQDetailsModelDay01 = fileUploadRepository.getEnbTableDetailsRanConfig(ciqFileName, neId, enbName, dbcollectionFileName, "Day0_1", "");
					FuzeProjectID=listCIQDetailsModelDay01.get(0).getCiqMap().get("fuzeProjectId").getHeaderValue();
					URL = Constants.OV_TRACKERID_URL + "view=L:SRCT_SN_CBAND_AUDIT&page=1&per_page=1&Project.P_FUZE_PROJECT_ID_FZ="+FuzeProjectID;
							
				}				https://seavizion.onevizion.com/api/v3/trackor_types/project/trackors?view=L:SRCT_SN_CBAND_AUDIT&page=1&per_page=1&Project.P_FUZE_PROJECT_ID_FZ=16273512
				if (programName.contains("FSU")) {
				List<CIQDetailsModel> listCIQDetailsModelDay01 = fileUploadRepository.getEnbTableDetailsRanConfig(ciqFileName, neId, enbName, dbcollectionFileName, "FSUCIQ", "");
				FuzeProjectID=listCIQDetailsModelDay01.get(0).getCiqMap().get("FuzeProjId").getHeaderValue();
					// view=L%3ASRCTCBAND&filter=L%3ASRCTCBANDD5'
					URL = Constants.OV_TRACKERID_URL +"P_FUZE_PROJECT_ID_FZ="+FuzeProjectID+"&P_4G_LTE_SCOPE=1";
							//P_FUZE_PROJECT_ID_FZ=16228992&P_4G_LTE_SCOPE=1
				}
				List<TrackerDetailsModel> listTrackerDetailsModel = new ArrayList<>();
				if(!FuzeProjectID.isEmpty()&&FuzeProjectID !=null) {
			urlBuilder.append(URL);
			String trakerIdUrl = urlBuilder.toString();
			logger.error("Tracker URL: "+trakerIdUrl);
			HttpHeaders headers = new HttpHeaders();
			headers.setAccept(Arrays.asList(MediaType.APPLICATION_JSON));
			headers.setContentType(MediaType.APPLICATION_JSON);
			String base64Creds = Base64.getEncoder().encodeToString(authStr.getBytes());
			// create headers
			headers.add("Authorization", "Basic " + base64Creds);
			HttpEntity requestEntity = new HttpEntity<>(headers);
			HttpComponentsClientHttpRequestFactory requestFactory = getHttpsConfiguration();
			
			RestTemplate restTemplate = new RestTemplate(requestFactory);
			logger.error("RequestEntity:  from SRCT",requestEntity);
			
			ResponseEntity<String> response = restTemplate.exchange(trakerIdUrl, HttpMethod.GET, requestEntity,
					String.class);
			logger.error("1st Api Response :",response);
			System.out.println(response);
			int statusCode = response.getStatusCodeValue();

			if (200 == statusCode) {
				String trackerIdJson = response.getBody();
				List<HashMap<String, Object>> trakerList = new ObjectMapper().readValue(trackerIdJson,
						new TypeReference<List<HashMap<String, Object>>>() {
						});
				logger.error("OV Responce Json :"+ trackerIdJson);
				
				

				if (!ObjectUtils.isEmpty(trakerList)) {
					for (HashMap<String, Object> entryData : trakerList) {
						if (entryData.containsKey("TRACKOR_ID")
								&& StringUtils.isNotEmpty(entryData.get("TRACKOR_ID").toString())) {
							TrackerDetailsModel trackerDetailsModel = new TrackerDetailsModel();
							trackerDetailsModel.setTrackerId(entryData.get("TRACKOR_ID").toString());
							listTrackerDetailsModel.add(trackerDetailsModel);
						}
					}
				}

				objTrackerIdDetails.put("trakerjson", listTrackerDetailsModel);
				objTrackerIdDetails.put("statusCode", response.getStatusCode());
			}
				}else {
					//objTrackerIdDetails.put("trakerjson", listTrackerDetailsModel);
					objTrackerIdDetails.put("reason", "Fuze ID is Empty for "+neId);
				}
		} catch (HttpClientErrorException e) {
			objTrackerIdDetails.put("sta'tusCode", e.getStatusCode());
			objTrackerIdDetails.put("response", e.getResponseBodyAsString());
		} catch (Exception e) {
			logger.error("error:"+ e);
			logger.info(
					"Exception in getTrakerIdList in FetchProcessServiceImpl " + ExceptionUtils.getFullStackTrace(e));
		}

		return objTrackerIdDetails;
	}

	public JSONObject patchMileStoneIndividual(String workplanID, String migrationSubType, int programId,
			Map<String, RunTestEntity> runTestEntityMap, String neId, String milestone) {
		 
		JSONObject objWorkplanIdDetails = new JSONObject();
		String orderNo;
		int pId=programId;
		String date2=DateUtil.dateToString(new Date(), "yyyy-MM-dd HH:mm:ss");
		System.out.println(date2);
		try {
			/*if(migrationSubType.equalsIgnoreCase("AUDIT")) {
				ProgramTemplateEntity programTemplateEntity = fileUploadService.getProgramTemplate(pId,
						Constants.POST_MIGRATION_MILESTONE);
				orderNo=programTemplateEntity.getValue();
			}else {
				ProgramTemplateEntity programTemplateEntity = fileUploadService.getProgramTemplate(pId,
						Constants.MIGRATION_MILESTONE);
				orderNo=programTemplateEntity.getValue().toString();
			}
			String[] Mile=orderNo.split(",");*/
			
			//for(int i=0;i<=Mile.length-1;i++) {
			OvGeneralEntity objOvGeneralEntity = customerRepository.getOvlabelTemplate(Constants.OV_URL);
			StringBuilder urlBuilder = new StringBuilder();
			//String authStr = getAuthencationString();
			urlBuilder.append(objOvGeneralEntity.getValue());
			urlBuilder.append(Constants.OV_TASKS_URL);
			urlBuilder.append(workplanID);
			urlBuilder.append("/tasks?order_number=");
			//String milestone=milestone;
			
				urlBuilder.append(milestone);
				//urlBuilder.append("16300.05");
				String trakerIdUrl = urlBuilder.toString();
				logger.error("Tracker URL: "+trakerIdUrl);
			JSONObject body = new JSONObject();
			String actual_finish_date=DateUtil.dateToString(new Date(), Constants.YYYY_MM_DD);
			body.put("actual_finish_date",actual_finish_date);
			System.out.println(body);
			/*HttpHeaders headers = new HttpHeaders();
			headers.setAccept(Arrays.asList(MediaType.APPLICATION_JSON));
			headers.setContentType(MediaType.APPLICATION_JSON);
			String base64Creds = Base64.getEncoder().encodeToString(authStr.getBytes());*/
			// create headers
		//	headers.add("Authorization", "Basic " + base64Creds);
			@SuppressWarnings("rawtypes")
			//HttpEntity requestEntity = new HttpEntity(body,headers);
			
			String authStr = getAuthencationString();
			HttpHeaders headers = new HttpHeaders();
			headers.setAccept(Arrays.asList(MediaType.APPLICATION_JSON));
			headers.setContentType(MediaType.APPLICATION_JSON);
			String base64Creds = Base64.getEncoder().encodeToString(authStr.getBytes());
			headers.add("Authorization", "Basic " + base64Creds);
			HttpEntity<JSONObject> requestEntity = new HttpEntity<>(body, headers);

			HttpComponentsClientHttpRequestFactory requestFactory = new HttpComponentsClientHttpRequestFactory(HttpClients.createDefault());
            requestFactory = getHttpsConfiguration();
            RestTemplate restTemplate = new RestTemplate(new BufferingClientHttpRequestFactory(requestFactory)); 
            List<ClientHttpRequestInterceptor> interceptors = new ArrayList<>();
			interceptors.add(new LoggingRequestInterceptor());
			restTemplate.setInterceptors(interceptors);
			
			
			/*
			HttpComponentsClientHttpRequestFactory requestFactory = new HttpComponentsClientHttpRequestFactory(HttpClients.createDefault());
            requestFactory = getHttpsConfiguration();
            RestTemplate restTemplate = new RestTemplate(new BufferingClientHttpRequestFactory(requestFactory)); 
            List<ClientHttpRequestInterceptor> interceptors = new ArrayList<>();
			interceptors.add(new LoggingRequestInterceptor());
			restTemplate.setInterceptors(interceptors);*/
			try {
			ResponseEntity<String> response = restTemplate.exchange(urlBuilder.toString(), HttpMethod.PATCH,
					requestEntity, String.class);
			logger.error("3rd API Responce without objectmapper :"+ response);
			System.out.println(response);
			int statusCode = response.getStatusCodeValue();
			if (200 == statusCode) {
				String trackerIdJson = response.getBody();
				
				logger.error("OV Responce workplanJson :"+ trackerIdJson);
				if (!ObjectUtils.isEmpty(trackerIdJson)) {
					
					OvTestResultEntity ovTestResultEntity= new OvTestResultEntity();
					ovTestResultEntity.setCurrentResult("["+date2+"]"+"-"+"Successfully MileStone: "+milestone+" Updated for NeId: "+neId);
					ovTestResultEntity.setMilestone(milestone);

					RunTestEntity runTestEntity = getRunTestEntity(runTestEntityMap.get(neId).getId());
					ovTestResultEntity.setRunTestEntity(runTestEntity);
					runTestRepository.updateRunTestov(ovTestResultEntity);
					runTestEntityMap.get(neId).setOvUpdateStatus("Success");
					runTestRepository.updateRunTest(runTestEntityMap.get(neId));
				}else {
					OvTestResultEntity ovTestResultEntity= new OvTestResultEntity();
					ovTestResultEntity.setCurrentResult("["+date2+"]"+"-"+"Failed to  updated the " +milestone+" MileStone for NeId: "+neId+" update URL  is not responding");
					ovTestResultEntity.setMilestone(milestone);

					RunTestEntity runTestEntity = getRunTestEntity(runTestEntityMap.get(neId).getId());
					ovTestResultEntity.setRunTestEntity(runTestEntity);
					runTestRepository.updateRunTestov(ovTestResultEntity);
					runTestEntityMap.get(neId).setOvUpdateStatus("Failure");
					//runTestEntityMap.get(neId).setOvUpdateReason("Failed to  updated the " +orderNo+" MileStone for NeId: "+neId+" update URL  is not responding" );
					runTestRepository.updateRunTest(runTestEntityMap.get(neId));
					logger.error("fail in 3rd Api" );
				}
			}else {
				OvTestResultEntity ovTestResultEntity= new OvTestResultEntity();
				ovTestResultEntity.setCurrentResult("["+date2+"]"+"-"+"Failed to  updated the " +milestone+" MileStone for NeId: "+neId+" update URL  is not responding");
				ovTestResultEntity.setMilestone(milestone);

				RunTestEntity runTestEntity = getRunTestEntity(runTestEntityMap.get(neId).getId());
				ovTestResultEntity.setRunTestEntity(runTestEntity);
				runTestRepository.updateRunTestov(ovTestResultEntity);
			
			runTestEntityMap.get(neId).setOvUpdateStatus("Failure");
			//runTestEntityMap.get(neId).setOvUpdateReason("Failed to  updated the " +orderNo+" MileStone for NeId: "+neId+" update URL  is not responding" );
			runTestRepository.updateRunTest(runTestEntityMap.get(neId));
			logger.error("fail in 3rd Api" );
			}
		} catch (HttpClientErrorException e) {
			objWorkplanIdDetails.put("statusCode", e.getStatusCode());
			objWorkplanIdDetails.put("response", e.getResponseBodyAsString());
			OvTestResultEntity ovTestResultEntity= new OvTestResultEntity();
			ovTestResultEntity.setCurrentResult("["+date2+"]"+"-"+"Failed to  updated the " +milestone+" MileStone for NeId: "+neId+" update URL  is not responding");
			ovTestResultEntity.setMilestone(milestone);

			RunTestEntity runTestEntity = getRunTestEntity(runTestEntityMap.get(neId).getId());
			ovTestResultEntity.setRunTestEntity(runTestEntity);
			runTestRepository.updateRunTestov(ovTestResultEntity);
			runTestEntityMap.get(neId).setOvUpdateStatus("Failure");
			//runTestEntityMap.get(neId).setOvUpdateReason("Failed to  update "+Mile[i]+" MileStone for NeId " + neId +" update URL  is not responding");
			runTestRepository.updateRunTest(runTestEntityMap.get(neId));
			logger.error("fail in 3rd Api" );
		}catch (HttpServerErrorException e) {
			objWorkplanIdDetails.put("statusCode", e.getStatusCode());
			objWorkplanIdDetails.put("response", e.getResponseBodyAsString());
			OvTestResultEntity ovTestResultEntity= new OvTestResultEntity();
			ovTestResultEntity.setCurrentResult("["+date2+"]"+"-"+"Failed to  updated the " +milestone+" MileStone for NeId: "+neId+" update URL  is not responding");
			ovTestResultEntity.setMilestone(milestone);

			RunTestEntity runTestEntity = getRunTestEntity(runTestEntityMap.get(neId).getId());
			ovTestResultEntity.setRunTestEntity(runTestEntity);
			runTestRepository.updateRunTestov(ovTestResultEntity);
			runTestEntityMap.get(neId).setOvUpdateStatus("Failure");
			//runTestEntityMap.get(neId).setOvUpdateReason("Failed to  update "+Mile[i]+" MileStone for NeId " + neId +" update URL  is not responding");
			runTestRepository.updateRunTest(runTestEntityMap.get(neId));
			logger.error("fail in 3rd Api" );
		}
			} catch (Exception e) {
			logger.info(
					"Exception in getTrakerIdList in FetchProcessServiceImpl " + ExceptionUtils.getFullStackTrace(e));
			OvTestResultEntity ovTestResultEntity= new OvTestResultEntity();
			ovTestResultEntity.setCurrentResult("["+date2+"]"+"-"+"Failed to  updated the  MileStone for NeId: "+neId+" MileStone is missing ");
			ovTestResultEntity.setMilestone(milestone);

			RunTestEntity runTestEntity = getRunTestEntity(runTestEntityMap.get(neId).getId());
			ovTestResultEntity.setRunTestEntity(runTestEntity);
			runTestRepository.updateRunTestov(ovTestResultEntity);
		
		runTestEntityMap.get(neId).setOvUpdateStatus("Failure");
		//runTestEntityMap.get(neId).setOvUpdateReason("Failed to  updated the " +orderNo+" MileStone for NeId: "+neId+" update URL  is not responding" );
		runTestRepository.updateRunTest(runTestEntityMap.get(neId));
		}

	return objWorkplanIdDetails;
}

	public JSONObject patchMileStoneRSSI(String workplanID, String migrationSubType, int programId,
			Map<String, RunTestEntity> runTestEntityMap, String neId, String milestone) {
		 
		JSONObject objWorkplanIdDetails = new JSONObject();
		String orderNo;
		int pId=programId;
		String date2=DateUtil.dateToString(new Date(), "yyyy-MM-dd HH:mm:ss");
		System.out.println(date2);
		try {
			
			OvGeneralEntity objOvGeneralEntity = customerRepository.getOvlabelTemplate(Constants.OV_URL);
			StringBuilder urlBuilder = new StringBuilder();
			//String authStr = getAuthencationString();
			urlBuilder.append(objOvGeneralEntity.getValue());
			urlBuilder.append("trackors/");
			urlBuilder.append(workplanID);
			
			String trakerIdUrl = urlBuilder.toString();
			logger.error("RSSI PUT URL: "+trakerIdUrl);
			JSONObject body = new JSONObject();
			String actual_finish_date=DateUtil.dateToString(new Date(), Constants.YYYY_MM_DD);
			body.put("P_PREEXISTING_RSSI",milestone);
			System.out.println(body);
			/*HttpHeaders headers = new HttpHeaders();
			headers.setAccept(Arrays.asList(MediaType.APPLICATION_JSON));
			headers.setContentType(MediaType.APPLICATION_JSON);
			String base64Creds = Base64.getEncoder().encodeToString(authStr.getBytes());*/
			// create headers
		//	headers.add("Authorization", "Basic " + base64Creds);
			@SuppressWarnings("rawtypes")
			//HttpEntity requestEntity = new HttpEntity(body,headers);
			
			String authStr = getAuthencationString();
			HttpHeaders headers = new HttpHeaders();
			headers.setAccept(Arrays.asList(MediaType.APPLICATION_JSON));
			headers.setContentType(MediaType.APPLICATION_JSON);
			String base64Creds = Base64.getEncoder().encodeToString(authStr.getBytes());
			headers.add("Authorization", "Basic " + base64Creds);
			HttpEntity<JSONObject> requestEntity = new HttpEntity<>(body, headers);

			HttpComponentsClientHttpRequestFactory requestFactory = new HttpComponentsClientHttpRequestFactory(HttpClients.createDefault());
            requestFactory = getHttpsConfiguration();
            RestTemplate restTemplate = new RestTemplate(new BufferingClientHttpRequestFactory(requestFactory)); 
            List<ClientHttpRequestInterceptor> interceptors = new ArrayList<>();
			interceptors.add(new LoggingRequestInterceptor());
			restTemplate.setInterceptors(interceptors);
			try {
			ResponseEntity<String> response = restTemplate.exchange(urlBuilder.toString(), HttpMethod.PUT,
					requestEntity, String.class);
			logger.error("2nd API Responce without objectmapper :"+ response);
			System.out.println(response);
			int statusCode = response.getStatusCodeValue();
			if (200 == statusCode) {
				String trackerIdJson = response.getBody();
				
				logger.error("OV Responce workplanJson :"+ trackerIdJson);
				if (!ObjectUtils.isEmpty(trackerIdJson)) {
					
					OvTestResultEntity ovTestResultEntity= new OvTestResultEntity();
					ovTestResultEntity.setCurrentResult("["+date2+"]"+"-"+"Successfully MileStone: "+"P_PREEXISTING_RSSI"+" Updated for NeId: "+neId);
					ovTestResultEntity.setMilestone("P_PREEXISTING_RSSI");
					ovTestResultEntity.setRssiContant(milestone);
					RunTestEntity runTestEntity = getRunTestEntity(runTestEntityMap.get(neId).getId());
					ovTestResultEntity.setRunTestEntity(runTestEntity);
					runTestRepository.updateRunTestov(ovTestResultEntity);
					runTestEntityMap.get(neId).setOvUpdateStatus("Success");
					runTestRepository.updateRunTest(runTestEntityMap.get(neId));
				}else {
					OvTestResultEntity ovTestResultEntity= new OvTestResultEntity();
					ovTestResultEntity.setCurrentResult("["+date2+"]"+"-"+"Failed to  updated the " +"P_PREEXISTING_RSSI"+" MileStone for NeId: "+neId+" update URL  is not responding");
					ovTestResultEntity.setMilestone("P_PREEXISTING_RSSI");
					ovTestResultEntity.setRssiContant(milestone);
					RunTestEntity runTestEntity = getRunTestEntity(runTestEntityMap.get(neId).getId());
					ovTestResultEntity.setRunTestEntity(runTestEntity);
					runTestRepository.updateRunTestov(ovTestResultEntity);
					runTestEntityMap.get(neId).setOvUpdateStatus("Failure");
					//runTestEntityMap.get(neId).setOvUpdateReason("Failed to  updated the " +orderNo+" MileStone for NeId: "+neId+" update URL  is not responding" );
					runTestRepository.updateRunTest(runTestEntityMap.get(neId));
					logger.error("fail in 2nd Api" );
				}
			}else {
				OvTestResultEntity ovTestResultEntity= new OvTestResultEntity();
				ovTestResultEntity.setCurrentResult("["+date2+"]"+"-"+"Failed to  updated the " +"P_PREEXISTING_RSSI"+" MileStone for NeId: "+neId+" update URL  is not responding");
				ovTestResultEntity.setMilestone("P_PREEXISTING_RSSI");
				ovTestResultEntity.setRssiContant(milestone);
				RunTestEntity runTestEntity = getRunTestEntity(runTestEntityMap.get(neId).getId());
				ovTestResultEntity.setRunTestEntity(runTestEntity);
				runTestRepository.updateRunTestov(ovTestResultEntity);
			
			runTestEntityMap.get(neId).setOvUpdateStatus("Failure");
			//runTestEntityMap.get(neId).setOvUpdateReason("Failed to  updated the " +orderNo+" MileStone for NeId: "+neId+" update URL  is not responding" );
			runTestRepository.updateRunTest(runTestEntityMap.get(neId));
			logger.error("fail in 2nd Api" );
			}
		} catch (HttpClientErrorException e) {
			objWorkplanIdDetails.put("statusCode", e.getStatusCode());
			objWorkplanIdDetails.put("response", e.getResponseBodyAsString());
			OvTestResultEntity ovTestResultEntity= new OvTestResultEntity();
			ovTestResultEntity.setCurrentResult("["+date2+"]"+"-"+"Failed to  updated the " +"P_PREEXISTING_RSSI"+" MileStone for NeId: "+neId+" update URL  is not responding");
			ovTestResultEntity.setMilestone("P_PREEXISTING_RSSI");
			ovTestResultEntity.setRssiContant(milestone);
			RunTestEntity runTestEntity = getRunTestEntity(runTestEntityMap.get(neId).getId());
			ovTestResultEntity.setRunTestEntity(runTestEntity);
			runTestRepository.updateRunTestov(ovTestResultEntity);
			runTestEntityMap.get(neId).setOvUpdateStatus("Failure");
			//runTestEntityMap.get(neId).setOvUpdateReason("Failed to  update "+Mile[i]+" MileStone for NeId " + neId +" update URL  is not responding");
			runTestRepository.updateRunTest(runTestEntityMap.get(neId));
			logger.error("fail in 2nd Api" );
		}catch (HttpServerErrorException e) {
			objWorkplanIdDetails.put("statusCode", e.getStatusCode());
			objWorkplanIdDetails.put("response", e.getResponseBodyAsString());
			OvTestResultEntity ovTestResultEntity= new OvTestResultEntity();
			ovTestResultEntity.setCurrentResult("["+date2+"]"+"-"+"Failed to  updated the " +"P_PREEXISTING_RSSI"+" MileStone for NeId: "+neId+" update URL  is not responding");
			ovTestResultEntity.setMilestone(milestone);
			ovTestResultEntity.setRssiContant(milestone);
			RunTestEntity runTestEntity = getRunTestEntity(runTestEntityMap.get(neId).getId());
			ovTestResultEntity.setRunTestEntity(runTestEntity);
			runTestRepository.updateRunTestov(ovTestResultEntity);
			runTestEntityMap.get(neId).setOvUpdateStatus("Failure");
			//runTestEntityMap.get(neId).setOvUpdateReason("Failed to  update "+Mile[i]+" MileStone for NeId " + neId +" update URL  is not responding");
			runTestRepository.updateRunTest(runTestEntityMap.get(neId));
			logger.error("fail in 2nd Api" );
		}
			} catch (Exception e) {
			logger.info(
					"Exception in getTrakerIdList in FetchProcessServiceImpl " + ExceptionUtils.getFullStackTrace(e));
			OvTestResultEntity ovTestResultEntity= new OvTestResultEntity();
			ovTestResultEntity.setCurrentResult("["+date2+"]"+"-"+"Failed to  updated the  MileStone for NeId: "+neId+" MileStone is missing ");
			ovTestResultEntity.setMilestone("P_PREEXISTING_RSSI");

			RunTestEntity runTestEntity = getRunTestEntity(runTestEntityMap.get(neId).getId());
			ovTestResultEntity.setRunTestEntity(runTestEntity);
			runTestRepository.updateRunTestov(ovTestResultEntity);
		
		runTestEntityMap.get(neId).setOvUpdateStatus("Failure");
		//runTestEntityMap.get(neId).setOvUpdateReason("Failed to  updated the " +orderNo+" MileStone for NeId: "+neId+" update URL  is not responding" );
		runTestRepository.updateRunTest(runTestEntityMap.get(neId));
		}

	return objWorkplanIdDetails;
}
	@Override
	public JSONObject HTMLUploadToOV(JSONObject ovUpdateJson, Map<String, RunTestEntity> runTestEntityMap) {
		JSONObject result = new JSONObject();
		try {
			String neId=ovUpdateJson.get("neid").toString();
			JSONObject trakerIdDetails  =getTrakerIdList(ovUpdateJson, runTestEntityMap);
			String TrackerID="";
			String WorkplanID="";
			String date2=DateUtil.dateToString(new Date(), "yyyy-MM-dd HH:mm:ss'");
			if (trakerIdDetails != null && trakerIdDetails.containsKey("trakerjson")) {
				List<TrackerDetailsModel> trakerdetails = (List<TrackerDetailsModel>) trakerIdDetails
						.get("trakerjson");
				if (!ObjectUtils.isEmpty(trakerdetails)) 
				{
									for (TrackerDetailsModel locTrackerDetailsModel : trakerdetails)
									{
										TrackerID=locTrackerDetailsModel.getTrackerId();
										logger.error("TrackerID:" + TrackerID);
									}
									ovUpdateJson.put("TrackerID",TrackerID);
									JSONObject updateJsonAPI = getHTMLUploadDetails(ovUpdateJson, runTestEntityMap);
								
				}else
				{	
					
				
					OvTestResultEntity ovTestResultEntity= new OvTestResultEntity();
					
					ovTestResultEntity.setCurrentResult("["+date2+"]"+"-"+"failed to fetch the Tracker ID/ No Tracker ID on OV for: "+neId);
					RunTestEntity runTestEntity = getRunTestEntity(runTestEntityMap.get(neId).getId());				
					ovTestResultEntity.setRunTestEntity(runTestEntity);
					ovTestResultEntity.setMilestone(runTestEntity.getResult());
					ovTestResultEntity.setRssiContant(runTestEntity.getResultFilePath());
					runTestRepository.updateRunTestov(ovTestResultEntity);
					runTestEntityMap.get(neId).setOvUpdateStatus("Failure");
					runTestRepository.updateRunTest(runTestEntityMap.get(neId));
					
					
					
					logger.error("fail in 1nd Api" );
				}
				}else
				{
					 date2=DateUtil.dateToString(new Date(), "yyyy-MM-dd HH:mm:ss");
					 System.out.println(date2);
					 OvTestResultEntity ovTestResultEntity= new OvTestResultEntity();
					if(trakerIdDetails.containsKey("reason")) {
					String reason=trakerIdDetails.get("reason").toString();
					ovTestResultEntity.setCurrentResult("["+date2+"]"+"-"+reason);
					}else {
						ovTestResultEntity.setCurrentResult("["+date2+"]"+"-"+"failed to fetch the Tracker ID/ No Tracker ID on OV for: "+neId);
					}
				
					//ovTestResultEntity.setCurrentResult("failed to fetch the Tracker ID");
					RunTestEntity runTestEntity = getRunTestEntity(runTestEntityMap.get(neId).getId());				
					ovTestResultEntity.setRunTestEntity(runTestEntity);
					ovTestResultEntity.setMilestone(runTestEntity.getResult());
					ovTestResultEntity.setRssiContant(runTestEntity.getResultFilePath());
					runTestRepository.updateRunTestov(ovTestResultEntity);
					runTestEntityMap.get(neId).setOvUpdateStatus("Failure");
					runTestRepository.updateRunTest(runTestEntityMap.get(neId));
					
					logger.error("fail in 1nd Api" );
				}
			
		} catch(Exception e) {
			result.put("status", Constants.FAIL);
			result.put("reason", e.getMessage());
			logger.info("Exception in runReTest() in RunTestController UpdateENV from PreMigration API" + ExceptionUtils.getFullStackTrace(e));
		}
		return result;
	}
	@SuppressWarnings("unchecked")
	public JSONObject getHTMLUploadDetails(JSONObject ovUpdateJson, Map<String, RunTestEntity> runTestEntityMap) {
		JSONObject objStatus = new JSONObject();
		StringBuilder envUpdateJson = new StringBuilder();
		try {
			String programName =ovUpdateJson.get("programName").toString();
			String neId=ovUpdateJson.get("neid").toString();
			RunTestEntity runTestEntity = getRunTestEntity(runTestEntityMap.get(neId).getId());	
			String date2=DateUtil.dateToString(new Date(), "yyyy-MM-dd HH:mm:ss");
				OvGeneralEntity objOvGeneralEntity = customerRepository.getOvlabelTemplate(Constants.OV_URL);
				StringBuilder urlBuilder = new StringBuilder();
				urlBuilder.append(objOvGeneralEntity.getValue());
				urlBuilder.append(Constants.ENV_UPLOAD_URL);
				String url = urlBuilder.toString();
				System.out.println("Ov upload url : "+url);
				String authStr = getAuthencationString();
				StringBuilder filePath = new StringBuilder();
				HttpHeaders headers = new HttpHeaders();
				headers.setAccept(Arrays.asList(MediaType.APPLICATION_JSON));
				headers.setContentType(MediaType.MULTIPART_FORM_DATA);
				String base64Creds = Base64.getEncoder().encodeToString(authStr.getBytes());

				headers.add("Authorization", "Basic " + base64Creds);

				MultiValueMap<String, Object> body = new LinkedMultiValueMap<>();
				filePath.append(LoadPropertyFiles.getInstance().getProperty(Constants.BASE_PATH)).append(runTestEntity.getResultFilePath()).append(Constants.SEPARATOR).append(runTestEntity.getResult());
				FileSystemResource file = new FileSystemResource(filePath.toString());
				body.add("file", file);

				Map<String, String> urlParams = new HashMap<>();
				urlParams.put("trackor_id", ovUpdateJson.get("TrackerID").toString());
				if (programName.contains("MM")){
					urlParams.put("field_name", "P_MMW_5G_CI_REPORT");
				}
				if (programName.contains("USM-LIVE")) {
				
				urlParams.put("field_name", "P_LTE_4G_CI_REPORT");
				}
				if (programName.contains("DSS")) {
					urlParams.put("field_name", "P_DSS_CI_REPORT");
				}
				if (programName.contains("CBAND")) {
					urlParams.put("field_name", "P_CBAND_CI_REPORT");
				}
				if (programName.contains("FSU")) {
					urlParams.put("field_name", "P_FSU_CI_REPORT");
				}

				//urlParams.put("field_name",MileStonesModel.getEnvMode().toString());
				
				HttpEntity<MultiValueMap<String, Object>> requestEntity = new HttpEntity<>(body, headers);
				HttpComponentsClientHttpRequestFactory requestFactory = getHttpsConfiguration();
				
				UriComponentsBuilder builder = UriComponentsBuilder.fromUriString(url)
						// add Querry params
						.queryParam("file_name", file.getFilename());

				System.out.println(builder.buildAndExpand(urlParams).toUri());
				envUpdateJson.append("Request:").append(builder.buildAndExpand(urlParams).toUri()).append("\n");
				RestTemplate restTemplate = new RestTemplate(requestFactory);
				String FileName=runTestEntity.getResult().toString();
			logger.error("request Entity: "+ requestEntity);
				ResponseEntity<String> response = restTemplate.postForEntity(builder.buildAndExpand(urlParams).toUri(),
						requestEntity, String.class);
				logger.error("ENV Upload API Response: "+ response);
				int statusCode = response.getStatusCodeValue();
				logger.error("Status Code for Upload ENV: "+ statusCode);
				if (200 == statusCode) {
					
					OvTestResultEntity ovTestResultEntity= new OvTestResultEntity();
					
					ovTestResultEntity.setCurrentResult("["+date2+"]"+"-"+"Successfully File :"+FileName +" Uploaded To OV");

					//RunTestEntity runTestEntity = getRunTestEntity(runTestEntityMap.get(neId).getId());				
					ovTestResultEntity.setRunTestEntity(runTestEntity);
					ovTestResultEntity.setMilestone(runTestEntity.getResult());
					//ovTestResultEntity.setHtmlFilePath(runTestEntity.getResultFilePath());
					runTestRepository.updateRunTestov(ovTestResultEntity);
					runTestEntityMap.get(neId).setOvUpdateStatus("Success");
					runTestRepository.updateRunTest(runTestEntityMap.get(neId));
				
					objStatus.put("statusCode", response.getStatusCode());
					objStatus.put("response", response.getBody());
				} else {
					OvTestResultEntity ovTestResultEntity= new OvTestResultEntity();
				//	RunTestEntity runTestEntity = getRunTestEntity(runTestEntityMap.get(neId).getId());				
					ovTestResultEntity.setRunTestEntity(runTestEntity);
					ovTestResultEntity.setMilestone(runTestEntity.getResult());
					ovTestResultEntity.setRssiContant(runTestEntity.getResultFilePath());
					ovTestResultEntity.setCurrentResult("["+date2+"]"+"-"+"Failed to  updated the " +FileName);
					runTestRepository.updateRunTestov(ovTestResultEntity);
					runTestEntityMap.get(neId).setOvUpdateStatus("Failure");
					runTestRepository.updateRunTest(runTestEntityMap.get(neId));				}
			}//envUpdateJson.append("Response:").append(response.getStatusCode());
			 catch (HttpClientErrorException e) {
			objStatus.put("statusCode", e.getStatusCode());
			objStatus.put("response", e.getResponseBodyAsString());
		} catch (Exception e) {
			logger.error("Exception in deleteCiqDir in UploadCIQController " + ExceptionUtils.getFullStackTrace(e));
		}
		return objStatus;

	}

	// swetha
	@SuppressWarnings("unchecked")
	private void createAuditHtmlFile(String htmlOutputFilPath, Integer runTestId, String ciqName, String enbId,
			String enbName, String lsmName, Map<String, String> scriptFilesDetails,
			NetworkConfigEntity networkConfigEntity, String type) {

		StringBuilder htmlContent = new StringBuilder();
		String timeStamp = new SimpleDateFormat("MMddyyyy").format(new Timestamp(System.currentTimeMillis()));
		String cascasdeId = "";
		BufferedReader bufferedReader = null;
		FileReader fileReader = null;
		String line = "";
		String scriptFilePath = "";
		String prompt = "";
		Map<String, Integer> cmdOccurances = new HashMap<>();
		try {
			String dbcollectionFileName = CommonUtil.createMongoDbFileName(
					String.valueOf(networkConfigEntity.getProgramDetailsEntity().getId()), ciqName);
			cascasdeId = fileUploadRepository.getEnBDataByPath(dbcollectionFileName, Constants.AUDIT_FDD_TDD, enbId,
					Constants.AUDIT_CASCADE);
			if (!StringUtils.isNotEmpty(cascasdeId)) {
				cascasdeId = enbId;
			}
			List<RunTestResultEntity> runTestResultEntityList = runTestResultRepository.getRunTestResultList(runTestId);
			String filePath = runTestService.loadRunningLog(runTestId);
			filePath = LoadPropertyFiles.getInstance().getProperty("BASE_PATH") + filePath;
			/*** Testing Code Starts ***/
			/*
			 * filePath = "/home/user/Desktop/Sprint_Output_Log.txt"; if (type == "xml") {
			 * filePath = "/home/user/Desktop/Vzn_Output_Log.txt"; }
			 */

			if (type == "xml") {
				// filePath = "/home/user/Desktop/audit_response";
			}
			/*** Testing Code End ***/
			String fullOutputLog = runTestService.readOutputFile(filePath);

			htmlContent.append("<table width=100% cellspacing=0 cellpadding=5 border=0>\n");
			htmlContent.append("<tr><td align=center><font size=+3>" + cascasdeId + " " + enbName + " AUDIT REPORT "
					+ timeStamp + " </font></td></tr>\n");
			htmlContent.append("</table>\n");
			htmlContent.append("<br><br><table width=100% cellspacing=0 cellpadding=5 border=1 bordercolor=#000000>\n");
			htmlContent.append(
					"<tr><th align=center>CASCADE ID</th><th align=center>eNB ID</th><th align=center>eNB NAME</th><th align=center>LSM</th><th align=center>PACKAGE VERSION</th><th align=center>RELEASE VERSION</th></tr>\n");
			htmlContent.append("<tr><td align=center>" + cascasdeId + "</td>\n");
			htmlContent.append("<td align=center>" + enbId + "</td>\n");
			htmlContent.append("<td align=center>" + enbName + "</td>\n");
			htmlContent.append("<td align=center>" + networkConfigEntity.getNeName() + "</td>\n");
			htmlContent
					.append("<td align=center>" + networkConfigEntity.getNeVersionEntity().getNeVersion() + "</td>\n");
			htmlContent.append("<td align=center>" + networkConfigEntity.getNeRelVersion() + "</td>\n");
			htmlContent.append("</td>\n");
			htmlContent.append("</tr>\n");
			htmlContent.append("</table>\n");

			for (Entry<String, String> scriptFileDetails : scriptFilesDetails.entrySet()) {
				scriptFilePath = scriptFileDetails.getKey();
				prompt = scriptFileDetails.getValue().replace("enbname", enbName).replace("enbId", enbId);

				/*** Testing Code Starts ***/
				/*
				 * prompt = "[eNB_712832]"; if (type == "xml") { prompt =
				 * "vsmuser@116_00_00_LMD1_0"; }
				 */
				/*** Testing Code End ***/

				fileReader = new FileReader(scriptFilePath);
				bufferedReader = new BufferedReader(fileReader);
				while ((line = bufferedReader.readLine()) != null) {
					String command = line.trim();
					String resultNode = "";
					if (StringUtils.isNotEmpty(command) && command.contains(";")) {
						command = command.substring(0, command.indexOf(";") + 1);
					}
					if (StringUtils.isNotEmpty(command) && command.contains(":")) {
						resultNode = StringUtils.substringAfterLast(command, ":");
						resultNode = resultNode.trim();
						command = StringUtils.substringBeforeLast(command, ":");
					}

					List<JSONObject> cmdExecResultWithSeq = new ArrayList<>();
					UseCaseBuilderEntity useCaseBuilderEntity = null;
					String cmdName = line.trim();
					int currentCmdSeq = -1;
					int commandRuleSequence = -1;
					if (cmdOccurances.isEmpty() || !cmdOccurances.containsKey(cmdName)) {
						currentCmdSeq = 1;
						cmdOccurances.put(cmdName, currentCmdSeq);
					} else if (cmdOccurances.containsKey(cmdName)) {
						currentCmdSeq = cmdOccurances.get(cmdName) + 1;
						cmdOccurances.put(cmdName, currentCmdSeq);
					}

					int count = 0;
					for (RunTestResultEntity entity : runTestResultEntityList) {
						count++;
						String cmdCompareTo = "";
						if (CommonUtil.isValidObject(entity.getCmdRuleBuilderEntity())) {

							cmdCompareTo = entity.getCmdRuleBuilderEntity().getCmdName();
						} else if (CommonUtil.isValidObject(entity.getXmlRuleBuilderEntity())) {

							cmdCompareTo = entity.getXmlRuleBuilderEntity().getCmdName();
						}

						if (StringUtils.isNotEmpty(entity.getRuleResultJson())
								&& ("FAIL".equalsIgnoreCase(entity.getCurrentResult())
										|| "WARN".equalsIgnoreCase(entity.getCurrentResult()))) {
							commandRuleSequence = -1;
							if (cmdCompareTo.equalsIgnoreCase(command)) {
								/*
								 * useCaseBuilderEntity = useCaseBuilderService
								 * .getUseCaseBuilderEntity(entity.getUseCaseID());
								 */

								useCaseBuilderEntity = entity.getUseCaseBuilderEntity();

								if (CommonUtil.isValidObject(useCaseBuilderEntity.getUseCaseBuilderParamEntity())
										&& useCaseBuilderEntity.getUseCaseBuilderParamEntity().size() > 0) {
									for (UseCaseBuilderParamEntity useCaseBuilderParamEntity : useCaseBuilderEntity
											.getUseCaseBuilderParamEntity()) {
										Set<UseCaseCmdRuleEntity> useCaseCmdRuleEntitySet = useCaseBuilderParamEntity
												.getUseCaseCmdRuleEntitySet();
										Set<UseCaseXmlRuleEntity> useCaseXmlRuleEntitySet = useCaseBuilderParamEntity
												.getUseCaseXmlRuleEntitySet();
										for (UseCaseCmdRuleEntity useCaseCmdRuleEntity : useCaseCmdRuleEntitySet) {
											if (useCaseCmdRuleEntity.getCmdRuleBuilderEntity().getId() == entity
													.getCmdRuleBuilderEntity().getId()) {
												commandRuleSequence = useCaseCmdRuleEntity.getCommandRuleSequence();
												JSONObject cmdFinalResult = new JSONObject();
												cmdFinalResult.put("commandRuleSequence", commandRuleSequence);
												cmdFinalResult.put("result", entity.getCurrentResult());
												cmdFinalResult.put("resultJsons", entity.getRuleResultJson());
												cmdExecResultWithSeq.add(cmdFinalResult);

											}
										}

										for (UseCaseXmlRuleEntity useCaseXmlRuleEntity : useCaseXmlRuleEntitySet) {
											if (useCaseXmlRuleEntity.getXmlRuleBuilderEntity().getId() == entity
													.getXmlRuleBuilderEntity().getId()) {
												commandRuleSequence = useCaseXmlRuleEntity.getXmlRuleSequence();
												JSONObject cmdFinalResult = new JSONObject();
												cmdFinalResult.put("commandRuleSequence", commandRuleSequence);
												cmdFinalResult.put("result", entity.getCurrentResult());
												cmdFinalResult.put("resultJsons", entity.getRuleResultJson());
												cmdExecResultWithSeq.add(cmdFinalResult);

											}
										}
									}
								}
							}
						}
					}
					if (type == "xml") {
						if (line.contains("display xml")) {
							htmlContent.append(
									getXmlHtmlContent(fullOutputLog, command, resultNode, prompt, cmdExecResultWithSeq,
											commandRuleSequence, currentCmdSeq, enbId, dbcollectionFileName));
						}
					} else {
						htmlContent.append(getCliHtmlContent(fullOutputLog, command, prompt, cmdExecResultWithSeq,
								commandRuleSequence, currentCmdSeq));
					}

					htmlContent.append("</table>\n");
				}
			}

			try (Writer writer = new BufferedWriter(
					new OutputStreamWriter(new FileOutputStream(htmlOutputFilPath), "utf-8"))) {
				writer.write(htmlContent.toString());
			}

			// AuditHtml taking from basepath+customer location
			String auditHtmlHardcodePth = LoadPropertyFiles.getInstance().getProperty("BASE_PATH") + Constants.CUSTOMER
					+ Constants.SEPARATOR + Constants.AUDIT_HTML_FILE;
			File originalfile = new File(auditHtmlHardcodePth);

			// FileUtils.copyFile(originalfile, new File(htmlOutputFilPath));

		} catch (Exception e) {
			logger.error(
					"Exception RunTestServiceImpl in createAuditHtmlFile() " + ExceptionUtils.getFullStackTrace(e));
			e.printStackTrace();
		}

	}

	@SuppressWarnings("unchecked")
	private StringBuilder getXmlHtmlContent(String fullOutputLog, String command, String resultNode, String prompt,
			List<JSONObject> cmdExecResultWithSeq, int commandRuleSequence, int currentCmdSeq, String enbId,
			String dbcollectionFileName) {
		StringBuilder htmlContent = new StringBuilder();
		String outputLog = "";
		try {
			if (XmlCommandsConstants.ENB_FUNCTION_CALL_TRACE_CSL_INFO.equalsIgnoreCase(command)) {
				htmlContent = auditXmlRulesServiceUtil.getCommandHtmlEnbFunctionCallTraceCslInfo(fullOutputLog, command,
						enbId);
			} else if (XmlCommandsConstants.ENB_FUNCTION_RADIO_PATH_CONTROL.equalsIgnoreCase(command)) {

				htmlContent = auditXmlRulesServiceUtil.getCommandHtmlEnbFunctionPathControl(fullOutputLog, command,
						enbId);

			} /*else if (XmlCommandsConstants.RADIOUNIT_CARRIER_CONTROLINFO.equalsIgnoreCase(command)) {

				
				 * htmlContent =
				 * auditXmlRulesServiceUtil.getCommandHtmlRadioUnitCarrierControlInfo(
				 * fullOutputLog, command, enbId,dbcollectionFileName);
				 
				htmlContent = auditXmlRulesServiceUtil.getCommandHtmlRadioUnitCarrierControlInfoCpriInfo(fullOutputLog,
						command, enbId, dbcollectionFileName);

			}*/ else if (XmlCommandsConstants.RADIOUNIT_CPRIPORT.equalsIgnoreCase(command)) {

				htmlContent = auditXmlRulesServiceUtil.getCommandHtmlRadioUnitCpriPort(fullOutputLog, command, enbId, null);

			} else if (XmlCommandsConstants.RADIOUNIT_ANTENALINE_DEVICE_INFO.equalsIgnoreCase(command)) {

				htmlContent = auditXmlRulesServiceUtil.getCommandHtmlRadioUnitAntenaLineDevice(fullOutputLog, command,
						enbId);

			} else if (XmlCommandsConstants.DIGITALUNIT_CPRIPORT_ENTRIES.equalsIgnoreCase(command)) {

				htmlContent = auditXmlRulesServiceUtil.getCommandHtmlCiprPortDetails(fullOutputLog, command, enbId);

			} else if (XmlCommandsConstants.ENB_FUNCTION_IMS_EMERGENCY.equalsIgnoreCase(command)) {

				htmlContent = auditXmlRulesServiceUtil.getCommandHtmlImsEmergency(fullOutputLog, command, enbId,
						dbcollectionFileName,null);

			} else if (XmlCommandsConstants.ENB_FUNCTION_EARFCN_CELL_DL_TOTAL_POWER.equalsIgnoreCase(command)) {

				htmlContent = auditXmlRulesServiceUtil.getCommandHtmlCellDlTotalPower(fullOutputLog, command, enbId,
						dbcollectionFileName);

			} else if (XmlCommandsConstants.ENB_FUNCTION_EARFCN_EUTRAN_CELL_CONF_IDLE.equalsIgnoreCase(command)) {

				htmlContent = auditXmlRulesServiceUtil.getCommandHtmlCellConfIdle(fullOutputLog, command, enbId,
						dbcollectionFileName);

			} /*else if (XmlCommandsConstants.IPSYS_IPV6_STATICROUTE.equalsIgnoreCase(command)) {

				htmlContent = auditXmlRulesServiceUtil.getCommandHtmlStaticRoute(fullOutputLog, command, enbId,
						dbcollectionFileName);

			}*/ else if (XmlCommandsConstants.ENB_FUNCTION_OPERATIONAL_STATE.equalsIgnoreCase(command)) {

				htmlContent = auditXmlRulesServiceUtil.getCommandHtmlOperationalState(fullOutputLog, command, enbId,
						dbcollectionFileName);

			} /*else if (XmlCommandsConstants.ENB_FUNCTION_TERMPOINTMME.equalsIgnoreCase(command)) {

				htmlContent = auditXmlRulesServiceUtil.getCommandHtmlMmeUsage(fullOutputLog, command, enbId,
						dbcollectionFileName,null);

			}*/ /*else if (XmlCommandsConstants.REQUEST_THROUGHPUT.equalsIgnoreCase(command)) {

				htmlContent = auditXmlRulesServiceUtil.getCommandHtmlRequestThroughput(fullOutputLog, command, enbId,
						dbcollectionFileName);

			}*/ else if (XmlCommandsConstants.RADIOUNIT_ANTENALINE_DEVICE_INFO_RETINFO.equalsIgnoreCase(command)) {

				htmlContent = auditXmlRulesServiceUtil.getCommandHtmlRadioUnitAntenaLineDeviceRetInfo(fullOutputLog,
						command, enbId);

			} else if (XmlCommandsConstants.EUTRAN_CBRS_INFO.equalsIgnoreCase(command)) {

				htmlContent = auditXmlRulesServiceUtil.getCommandHtmlCbrsInfo(fullOutputLog, command, enbId,
						dbcollectionFileName);

			} else if (auditXmlRulesServiceUtil.deListCommands().contains(command)) {

				// ne need to print in html page
			} else {
				htmlContent.append(
						"<br><br><table cellspacing=0 cellpadding=5 border=1 bordercolor=#000000 style=\"min-width: 100%;table-layout: fixed;white-space: pre;\">\n");
				for (int logSeq = 1; logSeq <= currentCmdSeq; logSeq++) {

					fullOutputLog = StringUtils.substringAfter(fullOutputLog, command);
					String[] logArray = fullOutputLog.split("\n");
					if (logArray != null && logArray.length > 0 && logArray[1] != null && logArray[1].contains(prompt)
							&& logArray[1].contains(command)) {
						fullOutputLog = StringUtils.substringAfter(fullOutputLog, command);
					}
					outputLog = StringUtils.substringBefore(fullOutputLog, "[ok]");
					if (logSeq == currentCmdSeq) {
						break;
					}
				}
				outputLog = StringUtils.substringBefore(fullOutputLog, "[ok]");
				outputLog = StringUtils.substringAfter(outputLog, "<");
				outputLog = "<" + outputLog;
				int rowIndex = 0;
				boolean tableHeaderFound = false;
				String tableHeader = "";
				String tableData = "";
				int colSpanCount = 0;
				DocumentBuilderFactory factory = DocumentBuilderFactory.newInstance();
				DocumentBuilder builder = factory.newDocumentBuilder();
				outputLog = "<parent>" + outputLog + "</parent>";
				Document document = builder.parse(new InputSource(new StringReader(outputLog)));

				if (!StringUtils.isNotEmpty(resultNode)) {
					Element elements = document.getDocumentElement();
					int level = 1;
					NodeList childNodeList = elements.getChildNodes();
					depthOfXML = 0;
					resultNode = getResultNode(childNodeList, level);
				}

				String firstColumnName = null;
				if (resultNode.contains(",")) {
					String[] resultNodeArray = resultNode.split(",");
					firstColumnName = resultNodeArray[0];
					resultNode = resultNodeArray[1];
				}

				NodeList nodeList = document.getElementsByTagName(resultNode);

				List<Map<String, JSONObject>> dataList = new ArrayList<Map<String, JSONObject>>();
				List<String> headList = new ArrayList<String>();
				Map<Integer, Map<String, String>> rowColors = new HashMap<>();
				for (int k = 0; k < nodeList.getLength(); k++) {
					Node childNode = nodeList.item(k);
					if (Node.ELEMENT_NODE == childNode.getNodeType()) {
						NodeList childNodeList = childNode.getChildNodes();
						Map<String, String> columnColors = new HashMap<>();
						JSONArray columnIndexes = null;
						List<JSONObject> columnIndexesResultList = new ArrayList<JSONObject>();
						JSONObject columnIndexesResult = new JSONObject();
						int colIndex = 0;
						int columnCount = 0;
						String tempThString = "";
						List<String> tempHeadList = new ArrayList<String>();
						Map<String, JSONObject> data = new HashMap<>();

						if (!tableHeaderFound) {
							tableHeader = tableHeader + "<tr>\n";
						}
						if (CommonUtil.isValidObject(cmdExecResultWithSeq) && cmdExecResultWithSeq.size() > 0) {
							for (JSONObject cmdExecResult : cmdExecResultWithSeq) {
								if (currentCmdSeq != -1
										&& Integer.parseInt(cmdExecResult.get("commandRuleSequence").toString()) != -1
										&& currentCmdSeq == Integer
												.parseInt(cmdExecResult.get("commandRuleSequence").toString())
										&& ("FAIL".equalsIgnoreCase(cmdExecResult.get("result").toString())
												|| "WARN".equalsIgnoreCase(cmdExecResult.get("result").toString()))) {

									String cmdRuleResultJson = cmdExecResult.get("resultJsons").toString();
									JSONObject json = CommonUtil.parseDataToJSON(cmdRuleResultJson);
									JSONArray rows = (JSONArray) json.get("rows");
									if (rows != null && rows.size() > 0) {
										for (int i = 0; i < rows.size(); i++) {
											JSONObject row = (JSONObject) rows.get(i);
											String matchRowIndex = row.get("index").toString();
											if (StringUtils.isNotEmpty(matchRowIndex)
													&& rowIndex == Integer.parseInt(matchRowIndex)) {
												columnIndexes = (JSONArray) row.get("columnIndexes");
												columnIndexesResult = new JSONObject();
												columnIndexesResult.put("result", cmdExecResult.get("result"));
												columnIndexesResult.put("columnIndexes", row.get("columnNames"));
												columnIndexesResultList.add(columnIndexesResult);

												// break;
											}

										}
									}
								}
							}
						}

						if (StringUtils.isNotEmpty(firstColumnName)) {
							columnCount++;
							tempHeadList.add(firstColumnName);
							tempThString = tempThString + "<th align=center>" + firstColumnName + "</th>\n";
						}

						for (int j = 0; j < childNodeList.getLength(); j++) {
							Node inChildNode = childNodeList.item(j);
							if (Node.ELEMENT_NODE == inChildNode.getNodeType()) {
								columnCount++;
								tempHeadList.add(inChildNode.getNodeName().trim());

								if ("eutran-fa-prior-info-func".equalsIgnoreCase(inChildNode.getNodeName())
										&& (XmlCommandsConstants.EARFCN_CELL_FDD_TDD_EARFCN_UL.equalsIgnoreCase(command)
												|| XmlCommandsConstants.EARFCN_CELL_FDD_TDD_PRIORITY
														.equalsIgnoreCase(command)
												|| XmlCommandsConstants.EARFCN_CELL_FDD_TDD_EARFCN_DL
														.equalsIgnoreCase(command))) {
									if (command.contains("earfcn-ul")) {
										tempThString = tempThString + "<th align=center>earfcn-ul</th>\n";
									} else if (command.contains("priority")) {
										tempThString = tempThString + "<th align=center>priority</th>\n";
									} else if (command.contains("earfcn-dl")) {
										tempThString = tempThString + "<th align=center>earfcn-dl</th>\n";
									}

								} else {
									tempThString = tempThString + "<th align=center>" + inChildNode.getNodeName()
											+ "</th>\n";
								}

							}
						}

						if (columnCount > colSpanCount) {
							colSpanCount = columnCount;
							tableHeader = tempThString;
							headList = tempHeadList;
						}

						String tdBgColor = "";
						for (JSONObject result : columnIndexesResultList) {

							columnIndexes = (JSONArray) result.get("columnIndexes");
							if (columnIndexes != null && columnIndexes.size() > 0) {
								for (int j = 0; j < columnIndexes.size(); j++) {
									if ("FAIL".equalsIgnoreCase(result.get("result").toString())) {
										tdBgColor = "#FF0000";
									} else if ("WARN".equalsIgnoreCase(result.get("result").toString())) {
										tdBgColor = "#FFFF00";
									} else {
										tdBgColor = "";
									}

								}
							}

						}
						rowColors.put(rowIndex, columnColors);
						rowIndex++;
						colIndex = 0;

						for (int j = 0; j < childNodeList.getLength(); j++) {
							Node inChildNode = childNodeList.item(j);
							if (Node.ELEMENT_NODE == inChildNode.getNodeType()) {

								if (StringUtils.isNotEmpty(firstColumnName)) {
									Element eElement = (Element) inChildNode.getParentNode().getParentNode()
											.getParentNode();

									if (XmlCommandsConstants.ENB_FUNCTION_EARFCN_EUTRAN_CELL_CONF_IDLE
											.equalsIgnoreCase(command)
											|| XmlCommandsConstants.ENB_FUNCTION_EARFCN_CELL_DL_TOTAL_POWER
													.equalsIgnoreCase(command)
											|| XmlCommandsConstants.ENB_FUNCTION_EARFCN_CELL_PLMN_INFO
													.equalsIgnoreCase(command)
											|| XmlCommandsConstants.ENB_FUNCTION_CELL_CALL_COUNT
													.equalsIgnoreCase(command)) {
										eElement = (Element) inChildNode.getParentNode().getParentNode();

									}

									if (XmlCommandsConstants.ENB_FUNCTION_TRAFFIC_MANAGE_FUN_CELL_CONTROL
											.equalsIgnoreCase(command)
											|| XmlCommandsConstants.ENB_FUNCTION_PRACH_CONFIG_LOGIC
													.equalsIgnoreCase(command)) {

										eElement = (Element) inChildNode.getParentNode().getParentNode().getParentNode()
												.getParentNode();
									}

									JSONObject jsonObject = new JSONObject();
									String color = "";
									if (StringUtils.isNotEmpty(columnColors.get(firstColumnName))) {
										color = columnColors.get(firstColumnName);
									}
									jsonObject.put("color", color);
									jsonObject.put("text",
											eElement.getElementsByTagName(firstColumnName).item(0).getTextContent());
									data.put(firstColumnName, jsonObject);
								}

								JSONObject jsonObject = new JSONObject();
								String color = "";
								if (StringUtils.isNotEmpty(columnColors.get(inChildNode.getNodeName()))) {
									color = columnColors.get(inChildNode.getNodeName());
								}
								jsonObject.put("color", color);
								jsonObject.put("text", inChildNode.getTextContent());
								data.put(inChildNode.getNodeName(), jsonObject);
								colIndex++;
							}
						}
						dataList.add(data);
						if (!tableHeaderFound) {
							tableHeader = tableHeader + "</tr>\n";
						}
						tableHeaderFound = true;
					}
				}
				htmlContent.append(
						"<tr><td colspan=" + (colSpanCount) + " bgcolor=#EEEEEE><b>" + command + "</b></td></tr>\n");
				htmlContent.append(tableHeader);
				rowIndex = 0;
				for (Map<String, JSONObject> map : dataList) {
					tableData = tableData + "<tr>\n";
					Map<String, String> rowcolor = rowColors.get(rowIndex);
					for (int j = 0; j < headList.size(); j++) {
						String value = "";
						String color = rowcolor.get(headList.get(j));

						if (map.containsKey(headList.get(j))) {
							value = map.get(headList.get(j)).get("text").toString().trim();
							// color = map.get(headList.get(j)).get("color").toString();
						}
						if (StringUtils.isNotEmpty(value) && value.contains("--More--")) {
							value = value.replaceAll("--More--", "");
						}

						if (StringUtils.isNotEmpty(color)) {
							tableData = tableData + "<td align=center bgcolor =" + color + " >" + value + "</td>\n";
						} else {
							tableData = tableData + "<td align=center>" + value + "</td>\n";
						}
					}
					tableData = tableData + "</tr>\n";
					rowIndex++;
				}
				if (StringUtils.isNotEmpty(tableData) && tableData.length() > 0 && headList.size() > 0) {
					htmlContent.append(tableData);
				} else {
					htmlContent.append("<tr>\n<td align=center bgcolor=FFFF00>NO DATA</td></tr>\n");
				}
				htmlContent.append("</table>");
			}
		} catch (Exception e) {
			logger.error("Exception RunTestServiceImpl in getXmlHtmlContent() " + ExceptionUtils.getFullStackTrace(e));
			e.printStackTrace();
			htmlContent.setLength(0);
			htmlContent.append(
					"<br><br><table cellspacing=0 cellpadding=5 border=1 bordercolor=#000000 style=\"min-width: 100%;table-layout: fixed;white-space: pre;\">\n");
			htmlContent.append("<tr><td  bgcolor=#EEEEEE><b>" + command + "</b></td></tr>\n");
			htmlContent.append("<tr>\n<td align=center bgcolor=FFFF00>NO DATA</td></tr>\n");
			htmlContent.append("</table>");

		}
		return htmlContent;
	}

	private static String getResultNode(NodeList nodeList, int level) {
		level++;
		if (nodeList != null && nodeList.getLength() > 0) {
			for (int i = 0; i < nodeList.getLength(); i++) {

				Node node = nodeList.item(i);
				if (node.getNodeType() == Node.ELEMENT_NODE) {
					getResultNode(node.getChildNodes(), level);
					if (level > depthOfXML) {
						depthOfXML = level;
						resultNode = node.getParentNode().getNodeName();
					}

				}

			}

		}
		return resultNode;
	}

	@SuppressWarnings("unchecked")
	private StringBuilder getCliHtmlContent(String fullOutputLog, String command, String prompt,
			List<JSONObject> cmdExecResultWithSeq, int commandRuleSequence, int currentCmdSeq) {
		StringBuilder htmlContent = new StringBuilder();
		String outputLog = "";
		try {
			htmlContent.append(
					"<br><br><table cellspacing=0 cellpadding=5 border=1 bordercolor=#000000 style=\"min-width: 100%;table-layout: fixed;    white-space: pre;\">\n");
			for (int logSeq = 1; logSeq <= currentCmdSeq; logSeq++) {

				fullOutputLog = StringUtils.substringAfter(fullOutputLog, command);
				String[] logArray = fullOutputLog.split("\n");
				if (logArray != null && logArray.length > 0 && logArray[1].contains(prompt)
						&& logArray[1].contains(command)) {
					fullOutputLog = StringUtils.substringAfter(fullOutputLog, command);
				}
				outputLog = StringUtils.substringBefore(fullOutputLog, prompt);
				if (logSeq == currentCmdSeq) {
					break;
				}
			}
			int rowIndex = 0;
			if (outputLog.contains("======")) {
				String[] outputContent = outputLog.split("\n");
				boolean tableHeaderFound = false;
				boolean tableHeaderEnd = false;
				int colSpanCount = 0;
				for (String outputLine : outputContent) {
					String[] outputTableHeaders = null;
					if (outputLine.contains("======")) {
						tableHeaderFound = true;
						continue;
					}
					if (tableHeaderFound && !tableHeaderEnd) {
						outputTableHeaders = outputLine.split(" " + "\\s+");

						for (String outputTableHeader : outputTableHeaders) {
							if (outputTableHeader != null && outputTableHeader.length() > 0) {
								colSpanCount++;
							}
						}
						htmlContent.append("<tr><td colspan=" + (colSpanCount) + " bgcolor=#EEEEEE><b>" + command
								+ "</b></td></tr>\n");
						htmlContent.append("<tr>\n");
						for (String outputTableHeader : outputTableHeaders) {
							if (outputTableHeader != null && outputTableHeader.length() > 0) {
								htmlContent.append("<th align=center>" + outputTableHeader + "</th>\n");
							}

						}
						htmlContent.append("</tr>\n");
						tableHeaderEnd = true;
						continue;
					}
					if (outputLine.contains("RESULT = ")) {
						break;
					}
					if (tableHeaderEnd && !outputLine.contains("RESULT = ")) {
						int colIndex = 0;
						Map<Integer, String> columnColors = new HashMap<>();
						JSONArray columnIndexes = null;
						List<JSONObject> columnIndexesResultList = new ArrayList<JSONObject>();
						JSONObject columnIndexesResult = new JSONObject();
						String[] outputTableData = outputLine.split(" " + "\\s+");
						htmlContent.append("<tr>\n");

						if (CommonUtil.isValidObject(cmdExecResultWithSeq) && cmdExecResultWithSeq.size() > 0) {
							for (JSONObject cmdExecResult : cmdExecResultWithSeq) {
								if (currentCmdSeq != -1 && commandRuleSequence != -1
										&& currentCmdSeq == Integer
												.parseInt(cmdExecResult.get("commandRuleSequence").toString())
										&& ("FAIL".equalsIgnoreCase(cmdExecResult.get("result").toString())
												|| "WARN".equalsIgnoreCase(cmdExecResult.get("result").toString()))) {

									String cmdRuleResultJson = cmdExecResult.get("resultJsons").toString();
									JSONObject json = CommonUtil.parseDataToJSON(cmdRuleResultJson);
									JSONArray rows = (JSONArray) json.get("rows");
									if (rows != null && rows.size() > 0) {
										for (int i = 0; i < rows.size(); i++) {
											JSONObject row = (JSONObject) rows.get(i);
											String matchRowIndex = row.get("index").toString();
											if (StringUtils.isNotEmpty(matchRowIndex)
													&& rowIndex == Integer.parseInt(matchRowIndex)) {
												columnIndexes = (JSONArray) row.get("columnIndexes");
												columnIndexesResult = new JSONObject();
												columnIndexesResult.put("result", cmdExecResult.get("result"));
												columnIndexesResult.put("columnIndexes", row.get("columnIndexes"));
												columnIndexesResultList.add(columnIndexesResult);
												// logger.info("createAuditHtmlFile columnIndexesResultList Before
												// rowIndex:
												// " + rowIndex +", result: " + columnIndexesResult);
												// break;
											}

										}
									}
								}
							}
						}
						for (int i = 1; i < colSpanCount + 1; i++) {
							String tdBgColor = "";
							for (JSONObject result : columnIndexesResultList) {
								// logger.info("createAuditHtmlFile columnIndexesResultList After rowIndex: " +
								// rowIndex +", result: " + result);
								columnIndexes = (JSONArray) result.get("columnIndexes");
								if (columnIndexes != null && columnIndexes.size() > 0) {
									for (int j = 0; j < columnIndexes.size(); j++) {
										String matchColumnIndex = columnIndexes.get(j).toString();
										if (colIndex == Integer.parseInt(matchColumnIndex)) {
											if ("FAIL".equalsIgnoreCase(result.get("result").toString())) {
												tdBgColor = "#FF0000";
											} else if ("WARN".equalsIgnoreCase(result.get("result").toString())) {
												tdBgColor = "#FFFF00";
											}
										}
									}
								}

							}
							columnColors.put(colIndex, tdBgColor);
							colIndex++;
						}
						colIndex = 0;
						// logger.info("createAuditHtmlFile rowIndex: " + rowIndex +", columnIndexes:
						// "+columnIndexes+", columnColors: "+columnColors);
						for (int i = 1; i < colSpanCount + 1; i++) {
							if (StringUtils.isNotEmpty(columnColors.get(colIndex))) {
								htmlContent.append("<td align=center bgcolor =" + columnColors.get(colIndex) + " >"
										+ outputTableData[i] + "</td>\n");
							} else {
								htmlContent.append("<td align=center>" + outputTableData[i] + "</td>\n");
							}
							colIndex++;
						}
						htmlContent.append("</tr>\n");
						rowIndex++;
					}
				}

			} else {
				htmlContent.append("<tr><td  bgcolor=#EEEEEE><b>" + command + "</b></td></tr>\n");
				htmlContent.append("<tr>\n");
				if (StringUtils.isNotEmpty(outputLog) && outputLog.length() > 0) {
					htmlContent.append("<td>" + outputLog + "</td>\n");
				} else {
					htmlContent.append("<td align=center bgcolor=FFFF00>NO DATA</td>\n");
				}
				htmlContent.append("</tr>\n");
			}

		} catch (Exception e) {
			logger.error("Exception RunTestServiceImpl in getCliHtmlContent() " + ExceptionUtils.getFullStackTrace(e));
			e.printStackTrace();
		}
		return htmlContent;
	}
	/*
	 * @Override public String generateScript(JSONObject runTestParams) throws
	 * RctException {
	 * 
	 * Map run = (Map) runTestParams.get("runTestFormDetails"); List<Map>
	 * scriptSeqDetails = (List<Map>) run.get("scripts"); List<Map> neList =
	 * (List<Map>) run.get("neDetails"); List<LinkedHashMap> useCaseList = (List)
	 * run.get("useCase"); int programId = (int) runTestParams.get("programId"); int
	 * lsmId = (int) run.get("lsmId"); boolean useCurrPassword = (boolean)
	 * run.get("currentPassword"); String sanePassword =
	 * run.get("password").toString(); String migType =
	 * runTestParams.get("migrationType").toString(); String migSubType =
	 * runTestParams.get("migrationSubType").toString(); String userName =
	 * runTestParams.get("userName").toString(); String ciqFileName =
	 * run.get("ciqName").toString(); String sProgramId =
	 * runTestParams.get("programId").toString(); String lsmVersion =
	 * run.get("lsmVersion").toString(); String lsmName =
	 * run.get("lsmName").toString(); String sessionId =
	 * runTestParams.get("sessionId").toString();
	 * 
	 * try {
	 * 
	 * Map<Integer, Integer> usecaseIdAndSeqmap = new HashMap<>(); Map<Integer,
	 * String> usecaseIdAndNamemap = new HashMap<>();
	 * 
	 * ExecutorService executorservice =
	 * Executors.newFixedThreadPool(neList.size());
	 * 
	 * for (Map neid : neList) {
	 * 
	 * executorservice.submit(() -> {
	 * 
	 * NetworkConfigEntity neEntity = null;
	 * 
	 * neEntity = uploadFileServiceImpl.getNeEntity(lsmVersion, lsmName, programId);
	 * 
	 * String migrationType = null; String migrationSubType = null;
	 * 
	 * if (migType.equalsIgnoreCase(Constants.MIGRATION)) { migrationType =
	 * "Migration"; } else if (migType.equalsIgnoreCase(Constants.POST_MIGRATION)) {
	 * migrationType = "PostMigration"; }
	 * 
	 * if (migSubType.equalsIgnoreCase("precheck")) { migrationSubType = "PreCheck";
	 * } else if ("commission".equalsIgnoreCase(migSubType)) { migrationSubType =
	 * "Commission"; } else if ("postcheck".equalsIgnoreCase(migSubType)) {
	 * migrationSubType = "PostCheck"; } else if
	 * ("AUDIT".equalsIgnoreCase(migSubType)) { migrationSubType = "Audit"; } else
	 * if ("RANATP".equalsIgnoreCase(migSubType)) { migrationSubType = "RanATP"; }
	 * 
	 * try {
	 * 
	 * int useCaseBuilderId = 0; for (Map usecase : useCaseList) { useCaseBuilderId
	 * = Integer.valueOf(usecase.get("useCaseId").toString()); Integer useCaseExeSeq
	 * = Integer.valueOf(usecase.get("executionSequence").toString()); String uCName
	 * = (String) usecase.get("useCaseName");
	 * usecaseIdAndSeqmap.put(useCaseBuilderId, useCaseExeSeq);
	 * usecaseIdAndNamemap.put(useCaseBuilderId, uCName); } Map<Integer, Integer>
	 * usecaseSortedByExeSeqMap = usecaseIdAndSeqmap.entrySet().stream()
	 * .sorted(Map.Entry.comparingByValue()).collect(Collectors.toMap(Map.Entry::
	 * getKey, Map.Entry::getValue, (e1, e2) -> e1, LinkedHashMap::new));
	 * 
	 * String neId = neid.get("neId").toString(); String neName =
	 * neid.get("neName").toString(); mainloop: for (Entry<Integer, Integer> h :
	 * usecaseSortedByExeSeqMap.entrySet()) { int useCaseId = h.getKey(); String
	 * useCaseName = usecaseIdAndNamemap.get(useCaseId); String sUseCase =
	 * useCaseName; String sLsmName = lsmName; int useCaseExeSeq =
	 * usecaseIdAndSeqmap.get(useCaseId); // get script details by passin the usecse
	 * id List<UseCaseBuilderParamEntity> scriptDetails = runTestRepository
	 * .getScriptDetails(useCaseId); Map<Integer, Integer> scriptIdAndSeqmap = new
	 * HashMap<>(); Map<Integer, Integer> useCaseScriptIdAnduploadedscriptIdmap =
	 * new HashMap<>(); ArrayList scriptFinalLst = new ArrayList<ArrayList>();
	 * 
	 * try {
	 * 
	 * for (UseCaseBuilderParamEntity scriptInfo : scriptDetails) { List scriptLst =
	 * new ArrayList<>(); Integer scriptId = scriptInfo.getScriptsDetails().getId();
	 * 
	 * int scriptUiExeSeq = getScriptExeSeq(scriptSeqDetails, scriptId);
	 * 
	 * Integer scriptExeSeq = scriptUiExeSeq;
	 * 
	 * Integer uploadedscriptId = scriptInfo.getId(); if (scriptExeSeq != 0) {
	 * 
	 * scriptLst.add(scriptId); scriptLst.add(scriptExeSeq);
	 * scriptLst.add(uploadedscriptId); scriptFinalLst.add(scriptLst);
	 * scriptIdAndSeqmap.put(scriptId, scriptExeSeq);
	 * 
	 * }
	 * 
	 * useCaseScriptIdAnduploadedscriptIdmap.put(uploadedscriptId, scriptId); }
	 * 
	 * Map<Integer, Integer> scriptSortedByExeSeqMap =
	 * scriptIdAndSeqmap.entrySet().stream() .sorted(Map.Entry.comparingByValue())
	 * .collect(Collectors.toMap(Map.Entry::getKey, Map.Entry::getValue, (e1, e2) ->
	 * e1, LinkedHashMap::new));
	 * 
	 * for (Entry<Integer, Integer> i : scriptSortedByExeSeqMap.entrySet()) { String
	 * scriptName = null; String text = ""; String scriptPath = null;
	 * 
	 * Integer scriptId = i.getKey(); int scriptExeSeq =
	 * scriptSortedByExeSeqMap.get(scriptId); // get script path by passing the
	 * script id UploadFileEntity scriptEntity =
	 * runTestRepository.getScriptInfo(i.getKey());
	 * 
	 * String enbIP = "127.0.0.1";
	 * 
	 * 
	 * enbIP = fileUploadRepository.getEnBDataByPath(ciqPgmIdAndCiqName, "IPPLAN",
	 * neId,"eNB_OAM_IP&eNB_S&B_IP");
	 * 
	 * 
	 * StringBuilder sourcePath = new StringBuilder(); StringBuilder destPath = new
	 * StringBuilder();
	 * 
	 * sourcePath = sourcePath
	 * .append(LoadPropertyFiles.getInstance().getProperty("BASE_PATH")); destPath =
	 * destPath .append(LoadPropertyFiles.getInstance().getProperty("BASE_PATH"));
	 * scriptName = scriptEntity.getFileName(); scriptPath =
	 * scriptEntity.getFilePath();
	 * 
	 * if (useCaseName.contains(Constants.RF_USECASE) ||
	 * useCaseName.contains(Constants.COMMISION_USECASE)) {
	 * sourcePath.append(Constants.CUSTOMER).append(Constants.SEPARATOR)
	 * .append(Constants.UPLOAD_FILE_PATH_WITHOUT_VERSION .replace("programId",
	 * Integer.toString(programId)) .replace("migrationType",
	 * Constants.MIGRATION_TYPE) .replace("subType", Constants.SUB_TYPE))
	 * .append(Constants.SEPARATOR).append(sUseCase)
	 * .append(Constants.SEPARATOR).append(scriptName); } else {
	 * sourcePath.append(scriptPath).append(File.separator)
	 * .append(useCaseName.replaceAll(" ", "_")).append(File.separator)
	 * .append(scriptName); }
	 * 
	 * destPath.append(Constants.CUSTOMER)
	 * .append(Constants.GENERATE_SCRIPT.replace("programId", sProgramId)
	 * .replace("migrationType", migrationType).replace("neId", neId)
	 * .replace("subType", migrationSubType));
	 * 
	 * File folder = new File(destPath.toString());
	 * 
	 * if (!folder.exists()) { FileUtil.createDirectory(destPath.toString()); }
	 * 
	 * String[] fileName = scriptName.split("\\.");
	 * 
	 * String scriptAbsFileName =
	 * LoadPropertyFiles.getInstance().getProperty("BASE_PATH") +
	 * scriptEntity.getFilePath() + "/" + useCaseName.replaceAll(" ", "_") + "/" +
	 * scriptEntity.getFileName();
	 * 
	 * if ("BatchFile".equalsIgnoreCase(scriptEntity.getScriptType()) &&
	 * scriptEntity
	 * .getConnectionTerminal().equalsIgnoreCase(Constants.CLI_TERMINAL)) {
	 * 
	 * String timeStamp = new SimpleDateFormat("MMddyyyy_HH_mm_ss") .format(new
	 * Timestamp(System.currentTimeMillis())); String cliFileName =
	 * LoadPropertyFiles.getInstance().getProperty("BASE_PATH") +
	 * scriptEntity.getFilePath() + "/" + useCaseName.replaceAll(" ", "_") + "/" +
	 * StringUtils.substringBeforeLast(scriptEntity.getFileName(), ".") + "_" +
	 * timeStamp + ".sh";
	 * 
	 * String relVersion = runTestRepository.getNeRelVer(programId, lsmVersion);
	 * 
	 * ProgramTemplateEntity programTemplateEntity = fileUploadService
	 * .getProgramTemplate(programId, Constants.SCRIPT_STORE_TEMPLATE);
	 * CommonUtil.createCliFromBatch(scriptAbsFileName, cliFileName, lsmVersion,
	 * relVersion, programTemplateEntity, ciqFileName, neId, neName); text =
	 * readFile(cliFileName, useCaseName, scriptEntity);
	 * 
	 * } else if (scriptEntity.getScriptType().equalsIgnoreCase("BatchFile") &&
	 * scriptEntity.getConnectionTerminal()
	 * .equalsIgnoreCase(Constants.CMD_SYS_TERMINAL)) {
	 * 
	 * String timeStamp = new SimpleDateFormat("MMddyyyy_HH_mm_ss") .format(new
	 * Timestamp(System.currentTimeMillis()));
	 * 
	 * String cmdSysFileName =
	 * LoadPropertyFiles.getInstance().getProperty("BASE_PATH") +
	 * scriptEntity.getFilePath() + "/" + useCaseName.replaceAll(" ", "_") + "/" +
	 * StringUtils.substringBeforeLast(scriptEntity.getFileName(), ".") + "_" +
	 * timeStamp + ".sh";
	 * 
	 * ProgramTemplateEntity programTemplateEntity = fileUploadService
	 * .getProgramTemplate(programId, Constants.SCRIPT_STORE_TEMPLATE);
	 * CommonUtil.createCmdSysFromBatch(scriptAbsFileName, cmdSysFileName,
	 * programTemplateEntity, ciqFileName, neId, neName);
	 * 
	 * text = readFile(cmdSysFileName, useCaseName, scriptEntity);
	 * 
	 * } else {
	 * 
	 * text = readFile(sourcePath.toString(), useCaseName, scriptEntity); }
	 * 
	 * if (sLsmName.contains("_")) { sLsmName = charRemoveAt(sLsmName); }
	 * 
	 * if (useCaseName.contains("_")) { useCaseName = charRemoveAt(useCaseName); }
	 * 
	 * if (fileName[0].contains("_")) { fileName[0] = charRemoveAt(fileName[0]); }
	 * 
	 * sLsmName = sLsmName.replaceAll("\\s", ""); useCaseName =
	 * useCaseName.replaceAll("\\s", ""); fileName[0] =
	 * fileName[0].replaceAll("\\s", "");
	 * 
	 * String descFileName = scriptExeSeq + "_" + sessionId + "_" + sLsmName + "_" +
	 * useCaseName + "_" + useCaseId + "_" + fileName[0] + "_" + scriptId + "." +
	 * fileName[1]; String descFinalPath = destPath.toString() + "/" + descFileName;
	 * 
	 * if ("py".equalsIgnoreCase(fileName[1].toString()) ||
	 * "perl".equalsIgnoreCase(fileName[1].toString())) {
	 * 
	 * File file = new File(descFinalPath); if (!file.exists()) {
	 * file.createNewFile(); } FileWriter fw = new FileWriter(descFinalPath);
	 * fw.write(text); fw.close();
	 * 
	 * } else {
	 * 
	 * writefile(text, lsmId, useCurrPassword, enbIP, descFinalPath, sanePassword,
	 * userName, scriptEntity, useCaseName, neId, programId, neName);
	 * 
	 * } } } catch (Exception e) {
	 * logger.error("Exception RunTestServiceImpl in getRuntestExecResult() " +
	 * ExceptionUtils.getFullStackTrace(e)); } }
	 * 
	 * } catch (Exception e) {
	 * logger.error("Exception RunTestServiceImpl in generateScript() " +
	 * ExceptionUtils.getFullStackTrace(e)); } return Constants.SUCCESS;
	 * 
	 * }); } }
	 * 
	 * catch (Exception e) { logger.error(
	 * "Exception RunTestServiceImpl in getRuntestExecResult() " +
	 * ExceptionUtils.getFullStackTrace(e));
	 * 
	 * return e.getMessage(); } return Constants.SUCCESS; }
	 */

	@Override
	public String generateScript(JSONObject runTestParams) throws RctException {

		Map run = (Map) runTestParams.get("runTestFormDetails");
		List<Map> scriptSeqDetails = (List<Map>) run.get("scripts");
		List<Map> neList = (List<Map>) run.get("neDetails");
		List<LinkedHashMap> useCaseList = (List) run.get("useCase");
		int programId = (int) runTestParams.get("programId");
		int lsmId = (int) run.get("lsmId");
		boolean useCurrPassword = (boolean) run.get("currentPassword");
		String sanePassword = run.get("password").toString();
		String migType = runTestParams.get("migrationType").toString();
		String migSubType = runTestParams.get("migrationSubType").toString();
		String userName = runTestParams.get("userName").toString();
		String ciqFileName = run.get("ciqName").toString();
		String sProgramId = runTestParams.get("programId").toString();
		String lsmVersion = run.get("lsmVersion").toString();
		String lsmName = run.get("lsmName").toString();

		try {

			Map<Integer, Integer> usecaseIdAndSeqmap = new HashMap<>();
			Map<Integer, String> usecaseIdAndNamemap = new HashMap<>();

			ExecutorService executorservice = Executors.newFixedThreadPool(neList.size());

			for (Map neid : neList) {

				executorservice.submit(() -> {

					String migrationType = null;
					String migrationSubType = null;

					if (migType.equalsIgnoreCase(Constants.MIGRATION)) {
						migrationType = "Migration";
					} else if (migType.equalsIgnoreCase(Constants.POST_MIGRATION)) {
						migrationType = "PostMigration";
					} else if (migType.equalsIgnoreCase(Constants.PRE_MIGRATION)) {
						migrationType = "Premigration";
					}

					if ("precheck".equalsIgnoreCase(migSubType)) {
						migrationSubType = "PreCheck";
					} else if ("commission".equalsIgnoreCase(migSubType)) {
						migrationSubType = "Commission";
					} else if ("postcheck".equalsIgnoreCase(migSubType)) {
						migrationSubType = "PostCheck";
					} else if ("AUDIT".equalsIgnoreCase(migSubType)) {
						migrationSubType = "Audit";
					} else if ("RANATP".equalsIgnoreCase(migSubType)) {
						migrationSubType = "RanATP";
					} else if ("NEGrow".equalsIgnoreCase(migSubType)) {
						migrationSubType = "NEGrow";
					}

					try {

						int useCaseBuilderId = 0;
						for (Map usecase : useCaseList) {
							useCaseBuilderId = Integer.valueOf(usecase.get("useCaseId").toString());
							Integer useCaseExeSeq = Integer.valueOf(usecase.get("executionSequence").toString());
							String uCName = (String) usecase.get("useCaseName");
							usecaseIdAndSeqmap.put(useCaseBuilderId, useCaseExeSeq);
							usecaseIdAndNamemap.put(useCaseBuilderId, uCName);
						}
						Map<Integer, Integer> usecaseSortedByExeSeqMap = usecaseIdAndSeqmap.entrySet().stream()
								.sorted(Map.Entry.comparingByValue()).collect(Collectors.toMap(Map.Entry::getKey,
										Map.Entry::getValue, (e1, e2) -> e1, LinkedHashMap::new));

						String neId = neid.get("neId").toString();
						String neName = neid.get("neName").toString();
						mainloop: for (Entry<Integer, Integer> h : usecaseSortedByExeSeqMap.entrySet()) {
							int useCaseId = h.getKey();
							String useCaseName = usecaseIdAndNamemap.get(useCaseId);
							String sLsmName = lsmName;
							// get script details by passin the usecse id
							List<UseCaseBuilderParamEntity> scriptDetails = runTestRepository
									.getScriptDetails(useCaseId);
							Map<Integer, Integer> scriptIdAndSeqmap = new HashMap<>();
							Map<Integer, Integer> useCaseScriptIdAnduploadedscriptIdmap = new HashMap<>();
							ArrayList scriptFinalLst = new ArrayList<ArrayList>();

							for (UseCaseBuilderParamEntity scriptInfo : scriptDetails) {
								List scriptLst = new ArrayList<>();
								Integer scriptId = scriptInfo.getScriptsDetails().getId();

								int scriptUiExeSeq = getScriptExeSeq(scriptSeqDetails, scriptId);

								Integer scriptExeSeq = scriptUiExeSeq;

								Integer uploadedscriptId = scriptInfo.getId();
								if (scriptExeSeq != 0) {

									scriptLst.add(scriptId);
									scriptLst.add(scriptExeSeq);
									scriptLst.add(uploadedscriptId);
									scriptFinalLst.add(scriptLst);
									scriptIdAndSeqmap.put(scriptId, scriptExeSeq);

								}

								useCaseScriptIdAnduploadedscriptIdmap.put(uploadedscriptId, scriptId);
							}

							Map<Integer, Integer> scriptSortedByExeSeqMap = scriptIdAndSeqmap.entrySet().stream()
									.sorted(Map.Entry.comparingByValue()).collect(Collectors.toMap(Map.Entry::getKey,
											Map.Entry::getValue, (e1, e2) -> e1, LinkedHashMap::new));

							for (Entry<Integer, Integer> i : scriptSortedByExeSeqMap.entrySet()) {
								String scriptName = null;
								String text;
								String scriptPath = null;

								Integer scriptId = i.getKey();
								int scriptExeSeq = scriptSortedByExeSeqMap.get(scriptId);
								// get script path by passing the script id
								UploadFileEntity scriptEntity = runTestRepository.getScriptInfo(i.getKey());

								String dbcollectionFileName = CommonUtil
										.createMongoDbFileName(String.valueOf(programId), ciqFileName);
								String vznEnbIP = fileUploadRepository.getEnBDataByPath(dbcollectionFileName,
										Constants.VZ_GROW_IPPLAN, neId,
										Constants.ORAN_SPRINT_COMM_SCRIPT_eNB_OAM_IP_eNB_S_B_IP);
								String eNB_OAM_IP = fileUploadRepository.getEnBDataByPath(dbcollectionFileName,
										Constants.SPT_GROW_SHEET_FDD_TDD, neId,
										Constants.ORAN_SPRINT_COMM_SCRIPT_8_CHG_IP_ADDR);
								String enbIP = "127.0.0.1";

								String CSR_OAM_IP = fileUploadRepository.getEnBDataByPath(dbcollectionFileName,
										Constants.SPT_GROW_SHEET_FDD_TDD, neId,
										Constants.ORAN_SPRINT_COMM_SCRIPT_9_CSR_OAM_IP);

								NeMappingModel neMappingModel = new NeMappingModel();
								CustomerDetailsEntity programDetailsEntity = new CustomerDetailsEntity();
								programDetailsEntity.setId(programId);
								neMappingModel.setProgramDetailsEntity(programDetailsEntity);
								neMappingModel.setEnbId(neId);
								List<NeMappingEntity> neMappingEntities = neMappingService.getNeMapping(neMappingModel);

								String neType = "ENB";
								if (scriptEntity.getFileName().contains(Constants.PRECHECK_CSR_FILE_NAME)
										|| scriptEntity.getFileName().contains(Constants.POSTCHECK_CSR_FILE_NAME)
										|| scriptEntity.getFileName().contains(Constants.NEGROW_CSR_FILE_NAME)) {
									enbIP = CommonUtil.getLeftSubStringWithLen(CSR_OAM_IP, 3);
									neType = "CSR";
								} else if (scriptEntity.getFileName().contains(Constants.PRECHECK_BSM_FILE_NAME)
										|| scriptEntity.getFileName().contains(Constants.POSTCHECK_BSM_FILE_NAME)
										|| scriptEntity.getFileName().contains(Constants.NEGROW_BSM_FILE_NAME)) {
									enbIP = neMappingEntities.get(0).getBsmIp();
								}

								if (StringUtils.isNotEmpty(vznEnbIP)) {
									enbIP = vznEnbIP;
								} else if (StringUtils.isNotEmpty(eNB_OAM_IP)) {
									String sprintEnbIP = CommonUtil.getLeftSubStringWithLen(eNB_OAM_IP, 3);
									if (StringUtils.isNotEmpty(sprintEnbIP)) {
										enbIP = sprintEnbIP;
									} else {
										enbIP = eNB_OAM_IP;
									}
								}

								StringBuilder sourcePath = new StringBuilder();
								StringBuilder destPath = new StringBuilder();

								sourcePath = sourcePath
										.append(LoadPropertyFiles.getInstance().getProperty("BASE_PATH"));
								destPath = destPath.append(LoadPropertyFiles.getInstance().getProperty("BASE_PATH"));
								scriptName = scriptEntity.getFileName();
								scriptPath = scriptEntity.getFilePath();
								if (migrationType.equalsIgnoreCase("Premigration")) {
									migrationType = "PreMigration";
								}

								useCaseName = usecaseIdAndNamemap.get(useCaseId);
								sourcePath.append(scriptPath).append(File.separator)
										.append(useCaseName.trim().replaceAll(" ", "_")).append(File.separator)
										.append(scriptName);

								destPath.append(Constants.CUSTOMER)
										.append(Constants.GENERATE_SCRIPT.replace("programId", sProgramId)
												.replace("migrationType", migrationType).replace("neId", neId)
												.replace("subType", migrationSubType));

								File folder = new File(destPath.toString());

								if (!folder.exists()) {
									FileUtil.createDirectory(destPath.toString());
								}

								String[] fileName = scriptName.split("\\.");
								String[] exactFileName = scriptName.split("\\.");
								String scriptAbsFileName = "";
								if (useCaseName.contains(Constants.COMMISION_USECASE)
										|| useCaseName.contains(Constants.RF_USECASE)
										|| useCaseName.contains(Constants.GROWCELLUSECASE)
										|| useCaseName.contains(Constants.GROWENBUSECASE)
										|| useCaseName.contains(Constants.PNPUSECASE)
										|| useCaseName.contains("AUCaCell") || useCaseName.contains("AU20B")
										|| useCaseName.contains("AU20A") || useCaseName.contains("pnp20BUsecase")
										|| useCaseName.contains("pnp20AUsecase")
										|| useCaseName.contains("pnp20CUsecase") || useCaseName.contains("AU20C")) {
									scriptAbsFileName = LoadPropertyFiles.getInstance().getProperty("BASE_PATH")
											+ Constants.CUSTOMER + "/"
											+ Constants.UPLOAD_FILE_PATH_WITHOUT_VERSION
													.replace("programId", String.valueOf(programId))
													.replace("migrationType", migrationType)
													.replace("subType", scriptEntity.getSubType())
											+ (usecaseIdAndNamemap.get(useCaseId)).trim().replaceAll(" ", "_") + "/"
											+ scriptEntity.getFileName();
								} else {
									scriptAbsFileName = LoadPropertyFiles.getInstance().getProperty("BASE_PATH")
											+ scriptEntity.getFilePath() + "/" + useCaseName.trim().replaceAll(" ", "_")
											+ "/" + scriptEntity.getFileName();
								}

								String timeStamp = new SimpleDateFormat("MMddyyyy_HH_mm_ss")
										.format(new Timestamp(System.currentTimeMillis()));

								String convertFileName = LoadPropertyFiles.getInstance().getProperty("BASE_PATH")
										+ scriptEntity.getFilePath() + "/" + useCaseName.trim().replaceAll(" ", "_")
										+ "/" + StringUtils.substringBeforeLast(scriptEntity.getFileName(), ".") + "_"
										+ timeStamp + ".sh";

								ProgramTemplateEntity programTemplateEntity = fileUploadService
										.getProgramTemplate(programId, Constants.SCRIPT_STORE_TEMPLATE);

								if ("BatchFile".equalsIgnoreCase(scriptEntity.getScriptType()) && scriptEntity
										.getConnectionTerminal().equalsIgnoreCase(Constants.CLI_TERMINAL)) {

									String relVersion = runTestRepository.getNeRelVer(programId, lsmVersion);

									CommonUtil.createCliFromBatch(scriptAbsFileName, convertFileName, lsmVersion,
											relVersion, programTemplateEntity, ciqFileName, neId, neName);
									text = readFile(convertFileName);

								} else if ("BatchFile".equalsIgnoreCase(scriptEntity.getScriptType()) && scriptEntity
										.getConnectionTerminal().equalsIgnoreCase(Constants.CMD_SYS_TERMINAL)) {

									CommonUtil.createCmdSysFromBatch(scriptAbsFileName, convertFileName,
											programTemplateEntity, ciqFileName, neId, neName);

									text = readFile(convertFileName);

								} else if ("BatchFile".equalsIgnoreCase(scriptEntity.getScriptType()) && scriptEntity
										.getConnectionTerminal().equalsIgnoreCase(Constants.CONFDCLI_TERMINAL)) {

									CommonUtil.createConfdCliFromBatch(scriptAbsFileName, convertFileName,
											programTemplateEntity, ciqFileName, neId, neName);

									text = readFile(convertFileName);

								} else if ("VbsFile".equalsIgnoreCase(scriptEntity.getScriptType()) && scriptEntity
										.getConnectionTerminal().equalsIgnoreCase(Constants.BASH_TERMINAL)) {

									CommonUtil.createBashFromVbs(scriptAbsFileName, convertFileName,
											programTemplateEntity, ciqFileName, neId, neName);

									text = readFile(convertFileName);

								} else if ("VbsFile".equalsIgnoreCase(scriptEntity.getScriptType()) && scriptEntity
										.getConnectionTerminal().equalsIgnoreCase(Constants.CLI_TERMINAL)) {
									String relVersion = runTestRepository.getNeRelVer(programId, lsmVersion);
									CommonUtil.createCliFromVbs(scriptAbsFileName, convertFileName, lsmVersion,
											relVersion, programTemplateEntity, ciqFileName, neId, neName);

									text = readFile(convertFileName);

								} else if ("XML".equalsIgnoreCase(scriptEntity.getScriptType())
										|| "CSV".equalsIgnoreCase(scriptEntity.getScriptType()) && (scriptEntity
												.getConnectionTerminal().equalsIgnoreCase(Constants.BASH_TERMINAL)
												|| scriptEntity.getConnectionTerminal()
														.equalsIgnoreCase(Constants.CURL_TERMINAL))) {

									String mcmip = "";
									NeMappingEntity neMappingEntity = neMappingEntities.get(0);

									if (CommonUtil.isValidObject(neMappingEntity.getNetworkConfigEntity())
											&& CommonUtil.isValidObject(
													neMappingEntity.getNetworkConfigEntity().getNeTypeEntity())
											&& neMappingEntity.getNetworkConfigEntity().getNeTypeEntity()
													.getId() == Constants.NW_CONFIG_VLSM_ID
											&& CommonUtil.isValidObject(
													neMappingEntity.getNetworkConfigEntity().getNeDetails())) {
										for (NetworkConfigDetailsEntity detailsEntity : neMappingEntity
												.getNetworkConfigEntity().getNeDetails()) {
											if (CommonUtil.isValidObject(detailsEntity.getServerTypeEntity())) {
												if (detailsEntity.getServerTypeEntity()
														.getId() == Constants.NW_CONFIG_VLSM_MCMA_ID
														&& CommonUtil.isValidObject(detailsEntity.getServerIp())
														&& detailsEntity.getServerIp().length() > 0) {
													mcmip = detailsEntity.getServerIp();
													break;
												}
											}
										}
									}
									if (CommonUtil.isValidObject(neMappingEntity.getNetworkConfigEntity())
											&& CommonUtil.isValidObject(
													neMappingEntity.getNetworkConfigEntity().getNeTypeEntity())
											&& neMappingEntity.getNetworkConfigEntity().getNeTypeEntity()
													.getId() == Constants.NW_CONFIG_USM_ID) {
										mcmip = neMappingEntity.getNetworkConfigEntity().getNeIp();
									}
									if (migrationType.equalsIgnoreCase("Premigration")) {
										List<CIQDetailsModel> listCIQDetailsModel = null;
										if (neId.length() > 7) {
											String programId1 = Integer.toString(programId);

											String dbcollectionFileName1 = CommonUtil.createMongoDbFileName(programId1,
													ciqFileName);
											listCIQDetailsModel = getCIQDetailsModelList(neId, dbcollectionFileName);
										}
										CommonUtil.createBashFromCSV(scriptAbsFileName, convertFileName, mcmip, neId,
												listCIQDetailsModel, neName);
									} else {
										CommonUtil.createBashFromXml(scriptAbsFileName, convertFileName, mcmip, neId);
									}
									text = readFile(convertFileName);

								} else if ("py".equalsIgnoreCase(fileName[1]) || "perl".equalsIgnoreCase(fileName[1])
										|| "pl".equalsIgnoreCase(fileName[1])) {

									text = readFile(scriptAbsFileName);
								} else if (useCaseName.contains(Constants.COMMISION_USECASE)
										|| useCaseName.contains(Constants.GROWCELLUSECASE)
										|| useCaseName.contains(Constants.GROWENBUSECASE)
										|| useCaseName.contains(Constants.PNPUSECASE)
										|| useCaseName.contains(Constants.RF_USECASE)
										|| useCaseName.contains("ACPF_A1A2") || useCaseName.contains("CSLUsecase")
										|| useCaseName.contains("Comm") || useCaseName.contains("ENDC")
										|| useCaseName.contains("Anchor") || useCaseName.contains("NBR")
										|| useCaseName.contains("RF_Scripts_Usecase")
										|| useCaseName.contains("RFScriptsUsecase") || useCaseName.contains("GP_Script")
										|| useCaseName.contains("GPScript") || useCaseName.contains("AUCaCell")
										|| useCaseName.contains("AUCaCell") || useCaseName.contains("AU20B")
										|| useCaseName.contains("AU20A") || useCaseName.contains("pnp20BUsecase")
										|| useCaseName.contains("pnp20AUsecase")
										|| useCaseName.contains("vDU_RF_Scripts_Usecase")
										|| useCaseName.contains("eNB_RF_Scripts_Usecase")
										|| useCaseName.contains("ACPF_RF_Scripts_Usecase")
										|| useCaseName.contains("AUPF_RF_Scripts_Usecase")
										|| useCaseName.contains("FSU_RF_Scripts_Usecase")
										|| useCaseName.contains("vDURFScriptsUsecase")
										|| useCaseName.contains("eNBRFScriptsUsecase")
										|| useCaseName.contains("ACPFRFScriptsUsecase")
										|| useCaseName.contains("AUPFRFScriptsUsecase")
										|| useCaseName.contains("FSURFScriptsUsecase")
										|| useCaseName.contains("Extended_Usecase")
										|| useCaseName.contains("ExtendedUsecase")
										|| useCaseName.contains("Pre-Check_RF_Scripts_Usecase")
										|| useCaseName.contains("Cutover_RF_Scripts_Usecase")
										|| useCaseName.contains("Rollback_RF_Scripts_Usecase")
										|| useCaseName.contains("AU20C") || useCaseName.contains("pnp20CUsecase")) {
									text = readFile(scriptAbsFileName);
								} else {
									CommonUtil.createExpect(scriptAbsFileName, convertFileName, scriptEntity, neId,
											neName);
									text = readFile(convertFileName);

								}

								if (sLsmName.contains("_")) {
									sLsmName = charRemoveAt(sLsmName);
								}

								if (useCaseName.contains("_")) {
									useCaseName = charRemoveAt(useCaseName);
								}

								if (fileName[0].contains("_")) {
									fileName[0] = charRemoveAt(fileName[0]);
								}

								sLsmName = sLsmName.replaceAll("\\s", "");
								useCaseName = useCaseName.replaceAll("\\s", "");
								fileName[0] = fileName[0].replaceAll("\\s", "_");

								String descFileName = scriptExeSeq + "_" + sLsmName + "_" + useCaseName + "_"
										+ useCaseId + "_" + fileName[0] + "_" + scriptId + "." + fileName[1];
								String descFinalPath = destPath.toString() + "/" + descFileName;

								if ("py".equalsIgnoreCase(fileName[1]) || "perl".equalsIgnoreCase(fileName[1])) {

									File file = new File(descFinalPath);
									if (!file.exists()) {
										file.createNewFile();
									}
									FileWriter fw = new FileWriter(descFinalPath);
									fw.write(text);
									fw.close();

								} else {

									descFileName = scriptExeSeq + "_" + sLsmName + "_" + useCaseName + "_" + useCaseId
											+ "_" + fileName[0] + "_" + scriptId + "." + "sh";
									descFinalPath = destPath.toString() + "/" + descFileName;
									String descFileNames = scriptExeSeq + "_" + sLsmName + "_" + useCaseName + "_"
											+ useCaseId + "_" + exactFileName[0] + "_" + scriptId + "." + "xml";
									String descFinalPaths = destPath.toString() + "/" + descFileNames;

									writefile(text, lsmId, useCurrPassword, enbIP, descFinalPath, sanePassword,
											userName, scriptEntity, useCaseName, neId, programId, neName, neType,
											descFinalPaths, false);

								}
							}
						}

					} catch (Exception e) {
						logger.error("Exception RunTestServiceImpl in generateScript() "
								+ ExceptionUtils.getFullStackTrace(e));
					}
					return Constants.SUCCESS;

				});
			}
			logger.error("Completed the Thread at " + LocalTime.now());
			executorservice.shutdown();
		}

		catch (Exception e) {
			logger.error(
					"Exception RunTestServiceImpl in getRuntestExecResult() " + ExceptionUtils.getFullStackTrace(e));

			return e.getMessage();
		}
		return Constants.SUCCESS;
	}

	public synchronized void generateScriptWithOutExe(String neId, String neName, String sProgramId,
			String migrationType, String migrationSubType, UploadFileEntity scriptEntity, String enbIP,
			NetworkConfigEntity neEntity, String useCaseName, String sessionId, String lsmName, int useCaseId,
			int useCaseExeSeq, int scriptId, int scriptExeSeq, int lsmId, boolean useCurrPassword, String sanePassword,
			String userName, String lsmVersion, String ciqFileName, String neType, boolean rfScriptFlag)
			throws RctException {

		try {
			int programId = Integer.parseInt(sProgramId);
			StringBuilder sourcePath = new StringBuilder();
			StringBuilder destPath = new StringBuilder();
			String text;

			sourcePath = sourcePath.append(LoadPropertyFiles.getInstance().getProperty("BASE_PATH"));
			destPath = destPath.append(LoadPropertyFiles.getInstance().getProperty("BASE_PATH"));
			String scriptName = scriptEntity.getFileName();
			String scriptPath = scriptEntity.getFilePath();

			sourcePath.append(scriptPath).append(File.separator).append(useCaseName.trim().replaceAll(" ", "_"))
					.append(File.separator).append(scriptName);

			destPath.append(Constants.CUSTOMER)
					.append(Constants.GENERATE_SCRIPT.replace("programId", sProgramId)
							.replace("migrationType", migrationType).replace("neId", neId)
							.replace("subType", migrationSubType));

			File folder = new File(destPath.toString());

			if (!folder.exists()) {
				FileUtil.createDirectory(destPath.toString());
			}

			String[] fileName = scriptName.split("\\.");
			String[] exactFileName = scriptName.split("\\.");

			String scriptAbsFileName = "";
			if (useCaseName.contains(Constants.COMMISION_USECASE) || useCaseName.contains(Constants.RF_USECASE)
					|| useCaseName.contains(Constants.GROWCELLUSECASE) || useCaseName.contains(Constants.GROWENBUSECASE)
					|| useCaseName.contains(Constants.PNPUSECASE) || useCaseName.contains("AUCaCell")
					|| useCaseName.contains("AU20B") || useCaseName.contains("AU20A")
					|| useCaseName.contains("pnp20BUsecase") || useCaseName.contains("pnp20AUsecase")
					|| useCaseName.contains("AU20C") || useCaseName.contains("pnp20CUsecase")
					|| useCaseName.contains("vDUCellGrow_cband") || useCaseName.contains("vDUGrow_cband")
					|| useCaseName.contains("pnpGrow_cband") || useCaseName.contains("GrowFSU")
					|| useCaseName.contains("pnpGrow") || useCaseName.contains("vDUCellGrow")
					|| useCaseName.contains("vDUGrow")
					|| useCaseName.contains("CA_Usecase")
					|| useCaseName.contains(Constants.ENDC_USECASE)
					||useCaseName.contains("DeleteNEUsecase")
					|| useCaseName.contains("NeCreationTimeUsecase")
					||useCaseName.contains("DeleteNE21AUsecase")
					|| useCaseName.contains("NeCreationTime21AUsecase")
					||useCaseName.contains("DeleteNE21BUsecase")
					|| useCaseName.contains("NeCreationTime21BUsecase")
					||useCaseName.contains("DeleteNE21CUsecase")
					|| useCaseName.contains("NeCreationTime21CUsecase")
					||useCaseName.contains("DeleteNE21DUsecase")
					|| useCaseName.contains("NeCreationTime21DUsecase")
					||useCaseName.contains("DeleteNE22AUsecase")
					|| useCaseName.contains("NeCreationTime22AUsecase")
					|| useCaseName.contains("DeleteNE22CUsecase")
					|| useCaseName.contains("NeCreationTime22CUsecase")) {

				scriptAbsFileName = LoadPropertyFiles.getInstance().getProperty("BASE_PATH") + Constants.CUSTOMER + "/"
						+ Constants.UPLOAD_FILE_PATH_WITHOUT_VERSION.replace("programId", String.valueOf(programId))
								.replace("migrationType", migrationType).replace("subType", scriptEntity.getSubType())
						+ useCaseName.trim().replaceAll(" ", "_") + "/" + scriptEntity.getFileName();
			} else {
				scriptAbsFileName = LoadPropertyFiles.getInstance().getProperty("BASE_PATH")
						+ scriptEntity.getFilePath() + "/" + useCaseName.trim().replaceAll(" ", "_") + "/"
						+ scriptEntity.getFileName();
			}
			/*
			 * String scriptAbsFileName =
			 * LoadPropertyFiles.getInstance().getProperty("BASE_PATH") +
			 * scriptEntity.getFilePath() + "/" + useCaseName.trim().replaceAll(" ", "_") +
			 * "/" + scriptEntity.getFileName();
			 */

			String timeStamp = new SimpleDateFormat("MMddyyyy_HH_mm_ss")
					.format(new Timestamp(System.currentTimeMillis()));

			String convertFileName = LoadPropertyFiles.getInstance().getProperty("BASE_PATH")
					+ scriptEntity.getFilePath() + "/" + useCaseName.trim().replaceAll(" ", "_") + "/"
					+ StringUtils.substringBeforeLast(scriptEntity.getFileName(), ".") + "_" + timeStamp + ".sh";

			ProgramTemplateEntity programTemplateEntity = fileUploadService.getProgramTemplate(programId,
					Constants.SCRIPT_STORE_TEMPLATE);

			if ("BatchFile".equalsIgnoreCase(scriptEntity.getScriptType())
					&& scriptEntity.getConnectionTerminal().equalsIgnoreCase(Constants.CLI_TERMINAL)) {

				String relVersion = runTestRepository.getNeRelVer(programId, lsmVersion);

				CommonUtil.createCliFromBatch(scriptAbsFileName, convertFileName, lsmVersion, relVersion,
						programTemplateEntity, ciqFileName, neId, neName);
				text = readFile(convertFileName);

			} else if ("BatchFile".equalsIgnoreCase(scriptEntity.getScriptType())
					&& scriptEntity.getConnectionTerminal().equalsIgnoreCase(Constants.CMD_SYS_TERMINAL)) {

				CommonUtil.createCmdSysFromBatch(scriptAbsFileName, convertFileName, programTemplateEntity, ciqFileName,
						neId, neName);

				text = readFile(convertFileName);

			} else if ("BatchFile".equalsIgnoreCase(scriptEntity.getScriptType())
					&& scriptEntity.getConnectionTerminal().equalsIgnoreCase(Constants.CONFDCLI_TERMINAL)) {

				CommonUtil.createConfdCliFromBatch(scriptAbsFileName, convertFileName, programTemplateEntity,
						ciqFileName, neId, neName);

				text = readFile(convertFileName);

			} else if ("VbsFile".equalsIgnoreCase(scriptEntity.getScriptType())
					&& scriptEntity.getConnectionTerminal().equalsIgnoreCase(Constants.BASH_TERMINAL)) {

				CommonUtil.createBashFromVbs(scriptAbsFileName, convertFileName, programTemplateEntity, ciqFileName,
						neId, neName);

				text = readFile(convertFileName);

			} else if ("VbsFile".equalsIgnoreCase(scriptEntity.getScriptType())
					&& scriptEntity.getConnectionTerminal().equalsIgnoreCase(Constants.CLI_TERMINAL)) {
				String relVersion = runTestRepository.getNeRelVer(programId, lsmVersion);
				CommonUtil.createCliFromVbs(scriptAbsFileName, convertFileName, lsmVersion, relVersion,
						programTemplateEntity, ciqFileName, neId, neName);

				text = readFile(convertFileName);

			} else if ("XML".equalsIgnoreCase(scriptEntity.getScriptType())
					&& (scriptEntity.getConnectionTerminal().equalsIgnoreCase(Constants.BASH_TERMINAL)
							|| scriptEntity.getConnectionTerminal().equalsIgnoreCase(Constants.CURL_TERMINAL))) {

				String mcmip = "";

				if (CommonUtil.isValidObject(neEntity) && CommonUtil.isValidObject(neEntity.getNeTypeEntity())
						&& neEntity.getNeTypeEntity().getId() == Constants.NW_CONFIG_VLSM_ID
						&& CommonUtil.isValidObject(neEntity.getNeDetails())) {
					for (NetworkConfigDetailsEntity detailsEntity : neEntity.getNeDetails()) {
						if (CommonUtil.isValidObject(detailsEntity.getServerTypeEntity())) {
							if (detailsEntity.getServerTypeEntity().getId() == Constants.NW_CONFIG_VLSM_MCMA_ID
									&& CommonUtil.isValidObject(detailsEntity.getServerIp())
									&& detailsEntity.getServerIp().length() > 0) {
								mcmip = detailsEntity.getServerIp();
								break;
							}
						}
					}
				}
				if (CommonUtil.isValidObject(neEntity) && CommonUtil.isValidObject(neEntity.getNeTypeEntity())
						&& neEntity.getNeTypeEntity().getId() == Constants.NW_CONFIG_USM_ID) {
					mcmip = neEntity.getNeIp();
				}

				CommonUtil.createBashFromXml(scriptAbsFileName, convertFileName, mcmip, neId);

				text = readFile(convertFileName);

			} else if ("py".equalsIgnoreCase(fileName[1]) || "perl".equalsIgnoreCase(fileName[1])
					|| "pl".equalsIgnoreCase(fileName[1])) {

				text = readFile(scriptAbsFileName);
			} else if (useCaseName.contains(Constants.COMMISION_USECASE) || useCaseName.contains(Constants.RF_USECASE)
					|| useCaseName.contains(Constants.ENDC_USECASE)
					|| useCaseName.contains("ACPF_A1A2") || useCaseName.contains("CSL") || useCaseName.contains("Comm")
					|| useCaseName.contains("ENDC") || useCaseName.contains("Anchor") || useCaseName.contains("NBR")
					|| useCaseName.contains("RF_Scripts_Usecase") || useCaseName.contains("RFScriptsUsecase")
					|| useCaseName.contains("GP_Script") || useCaseName.contains("GPScript")
					|| useCaseName.contains("vDU_RF_Scripts_Usecase") || useCaseName.contains("eNB_RF_Scripts_Usecase")
					|| useCaseName.contains("ACPF_RF_Scripts_Usecase")
					|| useCaseName.contains("AUPF_RF_Scripts_Usecase") || useCaseName.contains("FSU_RF_Scripts_Usecase")
					|| useCaseName.contains("vDURFScriptsUsecase") || useCaseName.contains("eNBRFScriptsUsecase")
					|| useCaseName.contains("ACPFRFScriptsUsecase") || useCaseName.contains("AUPFRFScriptsUsecase")
					|| useCaseName.contains("FSURFScriptsUsecase") || useCaseName.contains(Constants.GROWCELLUSECASE)
					|| useCaseName.contains(Constants.GROWENBUSECASE) || useCaseName.contains(Constants.PNPUSECASE)
					|| useCaseName.contains("AUCaCell") || useCaseName.contains("AU20B")
					|| useCaseName.contains("AU20A") || useCaseName.contains("pnp20BUsecase")
					|| useCaseName.contains("pnp20AUsecase") || useCaseName.contains("Pre-Check_RF_Scripts_Usecase")
					|| useCaseName.contains("Cutover_RF_Scripts_Usecase") || useCaseName.contains("Extended_Usecase")
					|| useCaseName.contains("ExtendedUsecase") || useCaseName.contains("Rollback_RF_Scripts_Usecase")
					|| useCaseName.contains("AU20C") || useCaseName.contains("pnp20CUsecase")
					|| useCaseName.contains("AU21A") || useCaseName.contains("pnp21AUsecase")
					|| useCaseName.contains("AU21B") || useCaseName.contains("pnp21BUsecase")
					|| useCaseName.contains("AU21C") || useCaseName.contains("pnp21CUsecase")
					|| useCaseName.contains("AU21D") || useCaseName.contains("pnp21DUsecase")
					|| useCaseName.contains("AU22A") || useCaseName.contains("pnp22AUsecase") //22A
					|| useCaseName.contains("AU22C") || useCaseName.contains("pnp22CUsecase") //22A
					|| useCaseName.contains("vDUCellGrow_cband") || useCaseName.contains("vDUGrow_cband")
					|| useCaseName.contains("pnpGrow_cband") || useCaseName.contains("GrowFSU")
					|| useCaseName.contains("pnpGrow") || useCaseName.contains("vDUCellGrow") 
					|| useCaseName.contains("vDUGrow")|| useCaseName.contains("CA_Usecase")
					|useCaseName.contains("DeleteNEUsecase")
					|| useCaseName.contains("NeCreationTimeUsecase")
					||useCaseName.contains("DeleteNE21AUsecase")
					|| useCaseName.contains("NeCreationTime21AUsecase")
					||useCaseName.contains("DeleteNE21BUsecase")
					|| useCaseName.contains("NeCreationTime21BUsecase")
					||useCaseName.contains("DeleteNE21CUsecase")
					|| useCaseName.contains("NeCreationTime21CUsecase")
					||useCaseName.contains("DeleteNE21DUsecase")
					|| useCaseName.contains("NeCreationTime21DUsecase")
					||useCaseName.contains("DeleteNE22CUsecase")
					|| useCaseName.contains("NeCreationTime22CUsecase")
					||useCaseName.contains("DeleteNE22AUsecase")
					|| useCaseName.contains("NeCreationTime22AUsecase"))  {
				text = readFile(scriptAbsFileName);
			} else {
				CommonUtil.createExpect(scriptAbsFileName, convertFileName, scriptEntity, neId, neName);
				text = readFile(convertFileName);
			}

			if (lsmName.contains("_")) {
				lsmName = charRemoveAt(lsmName);
			}

			if (useCaseName.contains("_")) {
				useCaseName = charRemoveAt(useCaseName);
			}

			if (fileName[0].contains("_")) {
				fileName[0] = charRemoveAt(fileName[0]);
			}
			if (useCaseName.contains("AUCommision")) {
				String dbcollectionFileName = CommonUtil.createMongoDbFileName(String.valueOf(programId), ciqFileName);
				List<CIQDetailsModel> listCIQDetailsModel = fileUploadRepository.getEnbTableDetails(ciqFileName, neId,
						"", dbcollectionFileName);
				String CC0_Offset = listCIQDetailsModel.get(0).getCiqMap().get("CC0 Cell Identity").getHeaderValue();
				String CC1_Offset = listCIQDetailsModel.get(0).getCiqMap().get("CC1 Cell Identity").getHeaderValue();
				String CC2_Offset = listCIQDetailsModel.get(0).getCiqMap().get("CC2 Cell Identity").getHeaderValue();
				String CC3_Offset = listCIQDetailsModel.get(0).getCiqMap().get("CC3 Cell Identity").getHeaderValue();
				String CC4_Offset = listCIQDetailsModel.get(0).getCiqMap().get("CC4 Cell Identity").getHeaderValue();
				String CC5_Offset = listCIQDetailsModel.get(0).getCiqMap().get("CC5 Cell Identity").getHeaderValue();
				String CC6_Offset = listCIQDetailsModel.get(0).getCiqMap().get("CC6 Cell Identity").getHeaderValue();
				String CC7_Offset = listCIQDetailsModel.get(0).getCiqMap().get("CC7 Cell Identity").getHeaderValue();
				if (useCaseName.contains("Comm")) {
					if (text.contains("${cell-num=0}"))
						text = text.replace("${cell-num=0}", CC0_Offset);
					if (text.contains("${cell-num=1}"))
						text = text.replace("${cell-num=1}", CC1_Offset);
					if (text.contains("${cell-num=2}"))
						text = text.replace("${cell-num=2}", CC2_Offset);
					if (text.contains("${cell-num=3}"))
						text = text.replace("${cell-num=3}", CC3_Offset);
					if (text.contains("${cell-num=4}"))
						text = text.replace("${cell-num=4}", CC4_Offset);
					if (text.contains("${cell-num=5}"))
						text = text.replace("${cell-num=5}", CC5_Offset);
					if (text.contains("${cell-num=6}"))
						text = text.replace("${cell-num=6}", CC6_Offset);
					if (text.contains("${cell-num=7}"))
						text = text.replace("${cell-num=7}", CC7_Offset);
				}
			}
			lsmName = lsmName.replaceAll("\\s", "");
			useCaseName = useCaseName.replaceAll("\\s", "");
			fileName[0] = fileName[0].replaceAll("\\s", "");

			String descFileName = scriptExeSeq + "_" + lsmName + "_" + useCaseName + "_" + useCaseId + "_" + fileName[0]
					+ "_" + scriptId + "." + fileName[1];
			String descFinalPath = destPath.toString() + "/" + descFileName;

			if ("py".equalsIgnoreCase(fileName[1]) || "perl".equalsIgnoreCase(fileName[1])
					|| "pl".equalsIgnoreCase(fileName[1])) {

				File file = new File(descFinalPath);
				if (!file.exists()) {
					file.createNewFile();
				}
				FileWriter fw = new FileWriter(descFinalPath);
				fw.write(text);
				fw.close();

			} else {

				descFileName = scriptExeSeq + "_" + lsmName + "_" + useCaseName + "_" + useCaseId + "_" + fileName[0]
						+ "_" + scriptId + "." + "sh";
				descFinalPath = destPath.toString() + "/" + descFileName;
				String descFileNames = scriptExeSeq + "_" + lsmName + "_" + useCaseName + "_" + useCaseId + "_"
						+ exactFileName[0] + "_" + scriptId + "." + "xml";
				String descFinalPaths = destPath.toString() + "/" + descFileNames;

				NeMappingModel neMappingModel = new NeMappingModel();
				CustomerDetailsEntity programDetailsEntity = new CustomerDetailsEntity();
				programDetailsEntity.setId(programId);
				neMappingModel.setProgramDetailsEntity(programDetailsEntity);
				neMappingModel.setEnbId(neId);
				List<NeMappingEntity> neMappingEntities = neMappingService.getNeMapping(neMappingModel);
				if (neEntity != null && neMappingEntities.size() > 0
						&& neMappingEntities.get(0).getNetworkConfigEntity() != null) {
					if (!neEntity.getNeIp().equals(neMappingEntities.get(0).getNetworkConfigEntity().getNeIp())) {
						String texts = null;
						texts = text.replaceAll(neMappingEntities.get(0).getNetworkConfigEntity().getNeIp(),
								neEntity.getNeIp());
						writefile(texts, lsmId, useCurrPassword, enbIP, descFinalPath, sanePassword, userName,
								scriptEntity, useCaseName, neId, programId, neName, neType, descFinalPaths,
								rfScriptFlag);
					} else {
						writefile(text, lsmId, useCurrPassword, enbIP, descFinalPath, sanePassword, userName,
								scriptEntity, useCaseName, neId, programId, neName, neType, descFinalPaths,
								rfScriptFlag);
					}
				} else {
					writefile(text, lsmId, useCurrPassword, enbIP, descFinalPath, sanePassword, userName, scriptEntity,
							useCaseName, neId, programId, neName, neType, descFinalPaths, rfScriptFlag);
				}
			}

		} catch (Exception e) {
			logger.error("Exception RunTestServiceImpl in generateScriptWithOutExe() "
					+ ExceptionUtils.getFullStackTrace(e));
		}

	}

	public static String charRemoveAt(String str) {
		StringBuilder finalString = new StringBuilder();
		String[] splitString = str.split("_");
		for (String sString : splitString) {
			finalString = finalString.append(sString);
		}
		return finalString.toString();
	}

	public String executeCommand(String command, String outputFileName, String scriptArguments, String useCaseName)
			throws RctException {
		StringBuilder output = new StringBuilder();
		Process p = null;
		try {
			String[] fileName = command.split("\\.");
			String cmdExe = command;
			String[] cmdToExec = { "timeout", Constants.SSH_TIMEOUT.toString(), "/bin/sh", "-c", cmdExe };
			if (scriptArguments != null) {
				if ("py".equalsIgnoreCase(fileName[1])) {
					cmdExe = "python ".concat(command).concat(" ").concat(scriptArguments);
				} else if ("perl".equalsIgnoreCase(fileName[1]) || "pl".equalsIgnoreCase(fileName[1])) {
					cmdExe = "perl ".concat(command).concat(" ").concat(scriptArguments);
				} else if ("sh".equalsIgnoreCase(fileName[1])) {
					cmdExe = command.concat(" ").concat(scriptArguments);
				}
			}
			Runtime.getRuntime().exec("chmod -R 777 " + cmdExe);
			Thread.sleep(1000);

			p = Runtime.getRuntime().exec(cmdToExec);

			Thread.sleep(2000);
			BufferedReader reader = new BufferedReader(new InputStreamReader(p.getInputStream()));
			BufferedReader error = new BufferedReader(new InputStreamReader(p.getErrorStream()));

			OutputStream os = new FileOutputStream(outputFileName, true);

			String[] paths = command.split("/");

			String exeFileString = "Executing " + paths[paths.length - 1] + "\n";

			os.write(exeFileString.getBytes());
			output.append(exeFileString);

			if (reader != null) {
				String line;
				while ((line = reader.readLine()) != null) {

					if (line.contains("Permission denied, please try again")) {
						os.write("Operation Failed wrong password : Permission denied, please try again.".getBytes());
					}
					if (line.contains("No route to host")) {
						os.write("Operation Failed No route to host :ssh connect to host IP port 22: No route to host."
								.getBytes());
					}

					String lineData = line + "\n";

					String resultString = lineData.replaceAll("\\[\\dm", "").replaceAll("\\[[\\d;]*m", "")
							.replaceAll("\\u0007", "").replaceAll("\\u001B", "").replaceAll("\\]\\d;", "")
							.replaceAll("[*\\[]K", "");

					try {
						if (resultString.contains("display") && resultString.contains("xml")) {
							resultString = resultString.replaceAll("\\s+", " ");
							String[] newlines = resultString.split("display");
							resultString = newlines[0] + "display xml";

							if (resultString.contains("request retrieve-processor-firmware-inventory")) {
								resultString = "request retrieve-processor-firmware-inventory | display xml";
							}

							if (resultString.contains(
									"show managed-element hardware-management radio-unit radio-unit-info antenna-unit antenna-line-device antenna-line-device-info")
									&& resultString.contains("ret-info")) {
								resultString = "show managed-element hardware-management radio-unit radio-unit-info antenna-unit antenna-line-device antenna-line-device-info ret ret-info | display xml";
							} else if (resultString.contains(
									"show managed-element hardware-management radio-unit radio-unit-info antenna-unit antenna-line-device antenna-line-device-info")) {
								resultString = "show managed-element hardware-management radio-unit radio-unit-info antenna-unit antenna-line-device antenna-line-device-info | display xml";
							}
							resultString = resultString + "\n";

						}
					} catch (Exception e) {
						logger.error("Exception RunTestServiceImpl in executeCommand()  parsing error"
								+ ExceptionUtils.getFullStackTrace(e));
					}

					output.append(resultString);
					os.write(resultString.getBytes());
				}
			}
			if (error != null) {
				String line;
				while ((line = error.readLine()) != null) {
					String lineData = line + "\n";

					String resultString = lineData.replaceAll("\\[\\dm", "").replaceAll("\\[[\\d;]*m", "")
							.replaceAll("\\u0007", "").replaceAll("\\u001B", "").replaceAll("\\]\\d;", "")
							.replaceAll("[*\\[]K", "");

					output.append(resultString);
					os.write(resultString.getBytes());
				}
			}
			os.close();

		} catch (Exception e) {
			logger.error("Exception RunTestServiceImpl in executeCommand() " + ExceptionUtils.getFullStackTrace(e));
		} finally {
			if (CommonUtil.isValidObject(p)) {
				p.destroyForcibly();
			}
		}

		return output.toString();
	}

	public String executePlAuditCommand(String command, String outputFileName, String cduIp, String eNodeID,
			String eNodeName, NetworkConfigEntity networkConfigEntity, String htmlOutputFileName) {
		StringBuilder output = new StringBuilder();

		String cascadeId = eNodeID;
		String adid = eNodeID;
		String lsmUserName = networkConfigEntity.getNeUserName();
		String lsmPassword = networkConfigEntity.getNePassword();
		String dir = LoadPropertyFiles.getInstance().getProperty("BASE_PATH") + Constants.SEPARATOR + "AuditTest";
		String market = networkConfigEntity.getNeMarket().replaceAll(" ", "_");

		Process p;
		try {
			Runtime.getRuntime().exec("chmod -R 777 " + command);
			Thread.sleep(2000);

			StringBuilder cmd = new StringBuilder();

			cmd.append("perl").append(" ").append(command).append(" ").append(cduIp).append(" ").append(eNodeID)
					.append(" ").append(eNodeName).append(" ").append(cascadeId).append(" ").append(adid).append(" ")
					.append(lsmUserName).append(" ").append(lsmPassword).append(" ").append(dir).append(" ")
					.append(market).append(" ").append(htmlOutputFileName);

			p = Runtime.getRuntime().exec(command);

			BufferedReader error = new BufferedReader(new InputStreamReader(p.getErrorStream()));
			BufferedReader reader = new BufferedReader(new InputStreamReader(p.getInputStream()));

			OutputStream os = new FileOutputStream(outputFileName);

			if (reader != null) {
				String line;
				while ((line = reader.readLine()) != null) {
					String lineData = line + "\n";

					String resultString = lineData.replaceAll("\\[\\dm", "").replaceAll("\\[[\\d;]*m", "")
							.replaceAll("\\u0007", "").replaceAll("\\u001B", "").replaceAll("\\]\\d;", "")
							.replaceAll("[*\\[]K", "");

					output.append(resultString);
					os.write(resultString.getBytes(), 0, resultString.length());
				}
			}
			if (error != null) {
				String line;
				while ((line = error.readLine()) != null) {
					String lineData = line + "\n";

					String resultString = lineData.replaceAll("\\[\\dm", "").replaceAll("\\[[\\d;]*m", "")
							.replaceAll("\\u0007", "").replaceAll("\\u001B", "").replaceAll("\\]\\d;", "")
							.replaceAll("[*\\[]K", "");

					output.append(resultString);
					os.write(resultString.getBytes(), 0, resultString.length());
				}
			}
			os.close();
		} catch (Exception e) {
			logger.error(
					"Exception RunTestServiceImpl in executePlAuditCommand() " + ExceptionUtils.getFullStackTrace(e));
		}

		return output.toString();

	}

	/*
	 * public String executePlRanAtpCommand(String command, String outputFileName,
	 * String cduIp, String eNodeID, String eNodeName, NetworkConfigEntity
	 * networkConfigEntity, String htmlOutputFileName) { StringBuffer output = new
	 * StringBuffer();
	 * 
	 * String cascadeId = eNodeID; String adid = eNodeID; String lsmUserName =
	 * networkConfigEntity.getNeUserName(); String lsmPassword =
	 * networkConfigEntity.getNePassword(); String dir =
	 * LoadPropertyFiles.getInstance().getProperty("BASE_PATH") +
	 * Constants.SEPARATOR + "ATPTest"; String Market =
	 * networkConfigEntity.getNeMarket().replaceAll(" ", "_");
	 * 
	 * Process p; try { System.out.println("bhuvana::::::: outputfileName" +
	 * outputFileName); Runtime.getRuntime().exec("chmod -R 777 " + command);
	 * Thread.sleep(2000); // String cmd = "perl " + command;
	 * 
	 * // final List<String> cmd = new ArrayList<String>();
	 * 
	 * 
	 * cmd.add("perl"); cmd.add(command); cmd.add(cduIp); cmd.add(eNodeID);
	 * cmd.add(eNodeName); cmd.add(cascadeId); cmd.add(adid); cmd.add(lsmUserName);
	 * cmd.add(lsmPassword); cmd.add(Market);
	 * 
	 * 
	 * StringBuilder cmd = new StringBuilder();
	 * 
	 * cmd.append("perl").append(" ").append(command).append(" ").append(cduIp).
	 * append(" ").append(eNodeID)
	 * .append(" ").append(eNodeName).append(" ").append(cascadeId).append(" ").
	 * append(adid).append(" ")
	 * .append(lsmUserName).append(" ").append(lsmPassword).append(" ").append(dir).
	 * append(" ") .append(Market).append(" ").append(htmlOutputFileName);
	 * 
	 * p = Runtime.getRuntime().exec(cmd.toString());
	 * 
	 * BufferedReader error = new BufferedReader(new
	 * InputStreamReader(p.getErrorStream())); BufferedReader reader = new
	 * BufferedReader(new InputStreamReader(p.getInputStream())); BufferedWriter
	 * writer = new BufferedWriter(new FileWriter(outputFileName));
	 * 
	 * OutputStream os = new FileOutputStream(outputFileName);
	 * 
	 * if (reader != null) { String line = ""; while ((line = reader.readLine()) !=
	 * null) { System.out.println(line + "\n"); String lineData = line + "\n";
	 * String resultString = lineData.replaceAll("[\\p{Cntrl}&&[^\r\n\t]]", "");
	 * output.append(resultString); os.write(resultString.getBytes(), 0,
	 * resultString.length()); } } if (error != null) { String line = ""; while
	 * ((line = error.readLine()) != null) { System.out.println(line + "\n"); String
	 * lineData = line + "\n"; String resultString =
	 * lineData.replaceAll("[\\p{Cntrl}&&[^\r\n\t]]", "");
	 * output.append(resultString); os.write(resultString.getBytes(), 0,
	 * resultString.length()); } } os.close(); } catch (Exception e) {
	 * logger.error("Exception RunTestServiceImpl in executePlRanAtpCommand() " +
	 * ExceptionUtils.getFullStackTrace(e)); }
	 * 
	 * return output.toString();
	 * 
	 * }
	 */

	private String executeCheckConnection(String command, String outputFileName) throws RctException {
		StringBuilder output = new StringBuilder();
		Process p;
		try {

			Runtime.getRuntime().exec("chmod -R 777 " + command);
			Thread.sleep(2000);
			p = Runtime.getRuntime().exec(command);
			BufferedReader reader = new BufferedReader(new InputStreamReader(p.getInputStream()));
			BufferedReader error = new BufferedReader(new InputStreamReader(p.getErrorStream()));

			OutputStream os = new FileOutputStream(outputFileName);

			if (reader != null) {
				String line;
				while ((line = reader.readLine()) != null) {
					if (line.contains("Permission denied, please try again")) {
						os.write("Operation Failed wrong password : Permission denied, please try again.".getBytes());
						os.close();
						throw new RctException(
								"Operation Failed wrong password : Permission denied, please try again.");

					}
					if (line.contains("No route to host")) {
						os.write("Operation Failed No route to host :ssh connect to host IP port 22: No route to host."
								.getBytes());
						os.close();
						throw new RctException(
								"Operation Failed No route to host :ssh connect to host IP port 22: No route to host.");
					}

					if (line.contains("Network is unreachable")) {
						String lineData = line + "\n";
						String resultString = lineData.replaceAll("\\[\\dm", "").replaceAll("\\[[\\d;]*m", "")
								.replaceAll("\\u0007", "").replaceAll("\\u001B", "").replaceAll("\\]\\d;", "")
								.replaceAll("[*\\[]K", "");
						os.write(lineData.getBytes());
						os.close();
						throw new RctException(
								"Operation Failed Unreachble : Network is unreachable, please try again.");

					}
					if (line.contains("Connection timed out")) {
						os.write("Operation Failed Connection timed out : Connection timed out, please try again."
								.getBytes());
						String lineData = line + "\n";
						String resultString = lineData.replaceAll("\\[\\dm", "").replaceAll("\\[[\\d;]*m", "")
								.replaceAll("\\u0007", "").replaceAll("\\u001B", "").replaceAll("\\]\\d;", "")
								.replaceAll("[*\\[]K", "");
						os.write(lineData.getBytes());
						os.close();
						throw new RctException(
								"Operation Failed Connection timed out : Connection timed out, please try again.");

					}
					String lineData = line + "\n";
					String resultString = lineData.replaceAll("\\[\\dm", "").replaceAll("\\[[\\d;]*m", "")
							.replaceAll("\\u0007", "").replaceAll("\\u001B", "").replaceAll("\\]\\d;", "")
							.replaceAll("[*\\[]K", "");
					output.append(resultString);
				}
				os.write(output.toString().getBytes(), 0, output.length());
			}
			if (error != null) {
				String line;
				while ((line = error.readLine()) != null) {
					String lineData = line + "\n";

					String resultString = lineData.replaceAll("\\[\\dm", "").replaceAll("\\[[\\d;]*m", "")
							.replaceAll("\\u0007", "").replaceAll("\\u001B", "").replaceAll("\\]\\d;", "")
							.replaceAll("[*\\[]K", "");
					output.append(resultString);
					os.write(resultString.getBytes(), 0, resultString.length());
				}
			}
			os.close();

		} catch (Exception e) {
			logger.error(
					"Exception RunTestServiceImpl in executeCheckConnection() " + ExceptionUtils.getFullStackTrace(e));
			throw new RctException(e.getMessage());
		}

		return output.toString();

	}

	public String readFiletmp(String filepath, String useCaseName, UploadFileEntity scriptEntity) {

		StringBuilder stringBuffer = new StringBuilder();
		try (BufferedReader bufferedReader = new BufferedReader(new FileReader(filepath))) {
			String line = null;
			boolean flag = true;
			boolean addSend = true;
			boolean addr = true;
			String scriptName = scriptEntity.getFileName();
			String[] fileName = scriptName.split("\\.");

			if ("BatchFile".equalsIgnoreCase(scriptEntity.getScriptType())
					&& scriptEntity.getConnectionTerminal().equalsIgnoreCase(Constants.CLI_TERMINAL)) {
				addSend = false;
				addr = false;
			}
			if ("BatchFile".equalsIgnoreCase(scriptEntity.getScriptType())
					&& scriptEntity.getConnectionTerminal().equalsIgnoreCase(Constants.CMD_SYS_TERMINAL)) {
				addSend = false;
				addr = false;
			}
			if ("BatchFile".equalsIgnoreCase(scriptEntity.getScriptType())
					&& scriptEntity.getConnectionTerminal().equalsIgnoreCase(Constants.CONFDCLI_TERMINAL)) {
				addSend = false;
				addr = false;
			}
			if ("py".equalsIgnoreCase(fileName[1]) || "perl".equalsIgnoreCase(fileName[1])
					|| "pl".equalsIgnoreCase(fileName[1])) {
				addSend = false;
				addr = false;
			}

			while ((line = bufferedReader.readLine()) != null) {
				if (flag) {
					if (addSend) {

						stringBuffer.append("send \"").append("\n");

					}

					flag = false;
				}
				stringBuffer.append(line).append("\n");
			}
			if (addr) {
				stringBuffer.append("\\r\"\n");
			}

		} catch (IOException e) {
			logger.error("Exception RunTestServiceImpl in readFile() " + ExceptionUtils.getFullStackTrace(e));
		}
		return stringBuffer.toString();
	}

	public String readFile(String filepath) {

		StringBuilder stringBuffer = new StringBuilder();
		try (BufferedReader bufferedReader = new BufferedReader(new FileReader(filepath))) {
			String line = null;
			while ((line = bufferedReader.readLine()) != null) {

				stringBuffer.append(line).append("\n");
			}

		} catch (IOException e) {
			logger.error("Exception RunTestServiceImpl in readFile() " + ExceptionUtils.getFullStackTrace(e));
		}
		return stringBuffer.toString();
	}

	public String readCurlFile(String filepath) {

		StringBuilder stringBuffer = new StringBuilder();
		try (BufferedReader bufferedReader = new BufferedReader(new FileReader(filepath))) {
			String line = null;
			while ((line = bufferedReader.readLine()) != null) {

				stringBuffer.append(line);
			}

		} catch (IOException e) {
			logger.error("Exception RunTestServiceImpl in readFile() " + ExceptionUtils.getFullStackTrace(e));
		}
		return stringBuffer.toString();
	}

	public void writefile(String text, int lsmId, boolean useCurrPassword, String eNBIp, String exeFileName,
			String sanePassword, String userName, UploadFileEntity scriptEntity, String useCaseName, String neId,
			int programId, String neName, String neType, String descFinalPaths, boolean rfScriptFlag) {

		NetworkConfigEntity networkConfigEntity = runTestRepository.getNeType(lsmId);
		StringBuilder sb = buildConnectionScript(networkConfigEntity, useCurrPassword, eNBIp, sanePassword, userName,
				scriptEntity, useCaseName, neId, text, neName, programId, neType);
		StringBuilder endSb = buildConnectionEndScript(networkConfigEntity, scriptEntity, programId, neType,
				useCaseName);
		try {
			/*
			 * StringBuilder commFilePath = new StringBuilder();
			 * commFilePath.append(LoadPropertyFiles.getInstance().getProperty("BASE_PATH"))
			 * .append(Constants.CUSTOMER); StringBuilder xmlFilePath = new StringBuilder();
			 * xmlFilePath.append(commFilePath).append(Constants.SEPARATOR).append(
			 * "xmlFlag.txt"); File xmlfile = new File(xmlFilePath.toString());
			 * BufferedReader br = new BufferedReader(new FileReader(xmlfile)); String line
			 * = br.readLine(); br.close();
			 */
			if (scriptEntity.getConnectionTerminal().equalsIgnoreCase(Constants.CLI_TERMINAL)
					|| scriptEntity.getConnectionTerminal().equalsIgnoreCase(Constants.CONFDCLI_TERMINAL)) {
				sb.append(text);
				sb.append(endSb);
			} else if (useCaseName.contains(Constants.COMMISION_USECASE) || useCaseName.contains("ACPFA1A2")
					|| useCaseName.contains("CSLUsecase") || useCaseName.contains("Comm")
					|| useCaseName.contains("ENDC") || useCaseName.contains("Anchor")
					|| useCaseName.contains("GP_Script") || useCaseName.contains("GPScript")
					|| useCaseName.contains("NBR") || useCaseName.contains("vDURFScriptsUsecase")
					|| useCaseName.contains("RF_Scripts_Usecase") || useCaseName.contains("RFScriptsUsecase")
					|| useCaseName.contains("eNBRFScriptsUsecase") || useCaseName.contains("ACPFRFScriptsUsecase")
					|| useCaseName.contains("AUPFRFScriptsUsecase") || useCaseName.contains("FSURFScriptsUsecase")
					|| useCaseName.contains(Constants.GROWCELLUSECASE) || useCaseName.contains(Constants.GROWENBUSECASE)
					|| useCaseName.contains(Constants.PNPUSECASE) || useCaseName.contains("AUCaCell")
					|| useCaseName.contains("AU20B") || useCaseName.contains("AU20A")
					|| useCaseName.contains("pnp20BUsecase") || useCaseName.contains("pnp20AUsecase")
					|| useCaseName.contains("Pre-CheckRFScriptsUsecase")
					|| useCaseName.contains("CutoverRFScriptsUsecase") || useCaseName.contains("Extended_Usecase")
					|| useCaseName.contains("ExtendedUsecase") || useCaseName.contains("RollbackRFScriptsUsecase")
					|| useCaseName.contains("AU20C") || useCaseName.contains("pnp20CUsecase")
					|| useCaseName.contains("AU21A") || useCaseName.contains("pnp21AUsecase")
					|| useCaseName.contains("AU21B") || useCaseName.contains("pnp21BUsecase")
					|| useCaseName.contains("AU21C") || useCaseName.contains("pnp21CUsecase") 
                                        || useCaseName.contains("AU21D") 
                                        || useCaseName.contains("pnp21DUsecase")
                    			|| useCaseName.contains("AU22A") || useCaseName.contains("pnp22AUsecase")  //22A
                    			|| useCaseName.contains("AU22C") || useCaseName.contains("pnp22CUsecase")  //22A
                                        || useCaseName.contains("CA_Usecase")
                                        || useCaseName.contains(Constants.ENDC_USECASE)
                                        ||useCaseName.contains("DeleteNEUsecase")
                                        || useCaseName.contains("NeCreationTimeUsecase")
                                        ||useCaseName.contains("DeleteNE21AUsecase")
                    					|| useCaseName.contains("NeCreationTime21AUsecase")
                    					||useCaseName.contains("DeleteNE21BUsecase")
                    					|| useCaseName.contains("NeCreationTime21BUsecase")
                    					||useCaseName.contains("DeleteNE21CUsecase")
                    					|| useCaseName.contains("NeCreationTime21CUsecase")
                    					||useCaseName.contains("DeleteNE21DUsecase")
                    					|| useCaseName.contains("NeCreationTime21DUsecase")
                    					||useCaseName.contains("DeleteNE22AUsecase")
                    					|| useCaseName.contains("NeCreationTime22AUsecase")
                    					||useCaseName.contains("DeleteNE22CUsecase")
                    					|| useCaseName.contains("NeCreationTime22CUsecase")) {
				sb.append(text);
				sb.append(endSb);
			} else if (useCaseName.contains(Constants.GROWCELLUSECASE)) {
				sb.append(text);
				sb.append(endSb);
			} else if (useCaseName.contains(Constants.GROWENBUSECASE)) {
				sb.append(text);
				sb.append(endSb);
			} else if (useCaseName.contains(Constants.PNPUSECASE)) {
				sb.append(text);
				sb.append(endSb);
			} else if (useCaseName.contains("AUCaCell")) {
				sb.append(text);
				sb.append(endSb);
			} else if (useCaseName.contains("AU20B")) {
				sb.append(text);
				sb.append(endSb);
			} else if (useCaseName.contains("AU20A")) {
				sb.append(text);
				sb.append(endSb);
			} else if (useCaseName.contains("pnp20AUsecase")) {
				sb.append(text);
				sb.append(endSb);
			} else if (useCaseName.contains("pnp20BUsecase")) {
				sb.append(text);
				sb.append(endSb);
			} else if (useCaseName.contains("AU20C")) {
				sb.append(text);
				sb.append(endSb);
			} else if (useCaseName.contains("pnp20CUsecase")) {
				sb.append(text);
				sb.append(endSb);
			} else if (useCaseName.contains("AU21A")) {
				sb.append(text);
				sb.append(endSb);
			} else if (useCaseName.contains("pnp21AUsecase")) {
				sb.append(text);
				sb.append(endSb);
			} else if (useCaseName.contains("AU21B")) {
				sb.append(text);
				sb.append(endSb);
			} else if (useCaseName.contains("pnp21BUsecase")) {
				sb.append(text);
				sb.append(endSb);
			} else if (useCaseName.contains("AU21C")) {
				sb.append(text);
				sb.append(endSb);
			} else if (useCaseName.contains("pnp21CUsecase")) {
				sb.append(text);
				sb.append(endSb);
			}else if (useCaseName.contains("AU21D")) {
				sb.append(text);
				sb.append(endSb);
			} else if (useCaseName.contains("pnp21DUsecase")) {
				sb.append(text);
				sb.append(endSb);
			}else if (useCaseName.contains("AU22A")) {//22A|useCaseName.contains("DeGrow21DUsecase")
				sb.append(text);
				sb.append(endSb);
			} else if (useCaseName.contains("pnp22AUsecase")) {
				sb.append(text);
				sb.append(endSb);
			}else if (useCaseName.contains("AU22C")) {//22A|useCaseName.contains("DeGrow21DUsecase")
				sb.append(text);
				sb.append(endSb);
			} else if (useCaseName.contains("pnp22CUsecase")) {
				sb.append(text);
				sb.append(endSb);
			}else if (useCaseName.contains("DeleteNEUsecase")) {
				sb.append(text);
				sb.append(endSb);
			}else if (useCaseName.contains("NeCreationTimeUsecase")) {
				sb.append(text);
				sb.append(endSb);
			}else if (useCaseName.contains("DeleteNE21AUsecase")) {
				sb.append(text);
				sb.append(endSb);
			}else if (useCaseName.contains("NeCreationTime21AUsecase")) {
				sb.append(text);
				sb.append(endSb);
			}else if (useCaseName.contains("DeleteNE21BUsecase")) {
				sb.append(text);
				sb.append(endSb);
			}else if (useCaseName.contains("NeCreationTime21BUsecase")) {
				sb.append(text);
				sb.append(endSb);
			}else if (useCaseName.contains("DeleteNE21CUsecase")) {
				sb.append(text);
				sb.append(endSb);
			}else if (useCaseName.contains("NeCreationTime21CUsecase")) {
				sb.append(text);
				sb.append(endSb);
			}else if (useCaseName.contains("DeleteNE21DUsecase")) {
				sb.append(text);
				sb.append(endSb);
			}else if (useCaseName.contains("NeCreationTime21DUsecase")) {
				sb.append(text);
				sb.append(endSb);
			}else if (useCaseName.contains("DeleteNE22AUsecase")) {
				sb.append(text);
				sb.append(endSb);
			}else if (useCaseName.contains("NeCreationTime22AUsecase")) {
				sb.append(text);
				sb.append(endSb);
			}else if (useCaseName.contains("DeleteNE22CUsecase")) {
				sb.append(text);
				sb.append(endSb);
			}else if (useCaseName.contains("NeCreationTime22CUsecase")) {
				sb.append(text);
				sb.append(endSb);
			}


			else if (useCaseName.contains(Constants.RF_USECASE)) {
				if (rfScriptFlag) {
					sb.append(text);
					sb.append(endSb);
				} else {
					String before = StringUtils.substringBefore(text, "-d");
					String after = StringUtils.substringAfter(text, "https");
					String xmlName = descFinalPaths.substring(descFinalPaths.lastIndexOf("/") + 1);
					String rfScriptName = StringUtils.substringAfter(xmlName, "BASH_RF_NB-IoTAdd_");
					String finalRfScript = rfScriptName.substring(rfScriptName.lastIndexOf("_"));
					String scriptXml = StringUtils.substringBefore(rfScriptName, finalRfScript);
					String scriptName = scriptXml.substring(scriptXml.lastIndexOf("_"));
					String finalXmlName = StringUtils.substringBefore(scriptXml, scriptName);
					String finalString = before + "-d " + "\\@/home/vsm/rancomm/" + neId + "/" + finalXmlName + ".xml"
							+ "" + " " + "https" + after;
					sb.append(finalString);
					sb.append(endSb);
				}
			} else if ("XML".equalsIgnoreCase(scriptEntity.getScriptType())
					&& scriptEntity.getConnectionTerminal().equalsIgnoreCase(Constants.BASH_TERMINAL)) {
				sb.append(text);
				sb.append(endSb);
			} else if ("XML".equalsIgnoreCase(scriptEntity.getScriptType())
					&& scriptEntity.getConnectionTerminal().equalsIgnoreCase(Constants.CURL_TERMINAL)) {
				sb.append(text);
				sb.append(endSb);
			} else if (!scriptEntity.getConnectionTerminal().equalsIgnoreCase(Constants.CURL_TERMINAL)) {
				sb.append(text);
				sb.append("expect \"" + scriptEntity.getPrompt().replace("enbname", neName).replace("enbId", neId)
						+ "\"" + " \n");
			}
			String xm = null;
			String s = new String(sb);
			File file = new File(exeFileName);
			if (!file.exists()) {
				file.createNewFile();

			}

			OutputStream os = new FileOutputStream(file);

			os.write(s.getBytes(), 0, s.length());

			Runtime.getRuntime().exec("chmod -R 777 " + exeFileName);

			os.close();

		} catch (Exception e) {
			logger.info("Exception in writefile() in RunTestServiceImpl" + ExceptionUtils.getFullStackTrace(e));
		}

	}

	public void writefile5G(String text, int lsmId, boolean useCurrPassword, String eNBIp, String exeFileName,
			String sanePassword, String userName, UploadFileEntity scriptEntity, String useCaseName, String neId,
			int programId, String neName, String neType, String descFinalPaths, boolean rfScriptFlag) {

		NetworkConfigEntity networkConfigEntity = runTestRepository.getNeType(lsmId);
		StringBuilder sb = buildConnectionScript(networkConfigEntity, useCurrPassword, eNBIp, sanePassword, userName,
				scriptEntity, useCaseName, neId, text, neName, programId, neType);
		StringBuilder endSb = buildConnectionEndScript(networkConfigEntity, scriptEntity, programId, neType,
				useCaseName);
		try {
			/*
			 * StringBuilder commFilePath = new StringBuilder();
			 * commFilePath.append(LoadPropertyFiles.getInstance().getProperty("BASE_PATH"))
			 * .append(Constants.CUSTOMER); StringBuilder xmlFilePath = new StringBuilder();
			 * xmlFilePath.append(commFilePath).append(Constants.SEPARATOR).append(
			 * "xmlFlag.txt"); File xmlfile = new File(xmlFilePath.toString());
			 * BufferedReader br = new BufferedReader(new FileReader(xmlfile)); String line
			 * = br.readLine(); br.close();
			 */
			if (scriptEntity.getConnectionTerminal().equalsIgnoreCase(Constants.CLI_TERMINAL)
					|| scriptEntity.getConnectionTerminal().equalsIgnoreCase(Constants.CONFDCLI_TERMINAL)) {
				sb.append(text);
				sb.append(endSb);
			} else if (useCaseName.contains("ACPF_A1A2") || useCaseName.contains("CSLUsecase")
					|| useCaseName.contains("Comm") || useCaseName.contains("ENDC") || useCaseName.contains("Anchor")
					|| useCaseName.contains("GP_Script") || useCaseName.contains("GPScript")
					|| useCaseName.contains("vDURFScriptsUsecase") || useCaseName.contains("eNBRFScriptsUsecase")
					|| useCaseName.contains("ACPFRFScriptsUsecase") || useCaseName.contains("AUPFRFScriptsUsecase")
					|| useCaseName.contains("FSURFScriptsUsecase") || useCaseName.contains("Pre-CheckRFScriptsUsecase")
					|| useCaseName.contains("CutoverRFScriptsUsecase") || useCaseName.contains("ExtendedUsecase")
					|| useCaseName.contains("RollbackRFScriptsUsecase")) {
				sb.append(text);
				sb.append(endSb);
			} else if (useCaseName.contains("NBR") || useCaseName.contains("RF_Scripts_Usecase")
					|| useCaseName.contains("RFScriptsUsecase")) {
				if (rfScriptFlag) {
					sb.append(text);
					sb.append(endSb);
				} else {
					String before = StringUtils.substringBefore(text, "-d");
					String after = StringUtils.substringAfter(text, "https");
					String xmlName = descFinalPaths.substring(descFinalPaths.lastIndexOf("/") + 1);
					String rfScriptName = StringUtils.substringAfter(xmlName, "BASH_RF_NB-IoTAdd_");
					String finalRfScript = rfScriptName.substring(rfScriptName.lastIndexOf("_"));
					String scriptXml = StringUtils.substringBefore(rfScriptName, finalRfScript);
					String scriptName = scriptXml.substring(scriptXml.lastIndexOf("_"));
					String finalXmlName = StringUtils.substringBefore(scriptXml, scriptName);
					String finalString = before + "-d " + "\\@/home/vsm/rancomm/" + neId + "/" + finalXmlName + ".xml"
							+ "" + " " + "https" + after;
					sb.append(finalString);
					sb.append(endSb);
				}
			} else if ("XML".equalsIgnoreCase(scriptEntity.getScriptType())
					&& scriptEntity.getConnectionTerminal().equalsIgnoreCase(Constants.BASH_TERMINAL)) {
				sb.append(text);
				sb.append(endSb);
			} else if ("XML".equalsIgnoreCase(scriptEntity.getScriptType())
					&& scriptEntity.getConnectionTerminal().equalsIgnoreCase(Constants.CURL_TERMINAL)) {
				sb.append(text);
				sb.append(endSb);
			} else if (!scriptEntity.getConnectionTerminal().equalsIgnoreCase(Constants.CURL_TERMINAL)) {
				sb.append(text);
				sb.append("expect \"" + scriptEntity.getPrompt().replace("enbname", neName).replace("enbId", neId)
						+ "\"" + " \n");
			}
			String xm = null;
			String s = new String(sb);
			File file = new File(exeFileName);
			if (!file.exists()) {
				file.createNewFile();

			}

			OutputStream os = new FileOutputStream(file);

			os.write(s.getBytes(), 0, s.length());

			Runtime.getRuntime().exec("chmod -R 777 " + exeFileName);

			os.close();

		} catch (Exception e) {
			logger.info("Exception in writefile() in RunTestServiceImpl" + ExceptionUtils.getFullStackTrace(e));
		}

	}

	public String xmlParsing(XmlRuleBuilderEntity xmlRule, String data1, int xmlRuleOccurence, String neName,
			String enbId, String dbcollectionFileName, String subtype) {

		String rootName = xmlRule.getRootName();
		String subRootName = xmlRule.getSubRootName();
		String loopType = xmlRule.getLoopType();
		String cmdResult = xmlRule.getStatus();

		String result = NO_DATA;
		String finalResult = "NO";
		String outputResult = NO_DATA;

		JSONObject noRuleResultJson = new JSONObject();
		JSONObject yesRuleResultJson = new JSONObject();
		JSONObject resultJson = new JSONObject();
		JSONObject jsonResult = new JSONObject();

		Set<XmlRootEntity> xmlRootEntityset = xmlRule.getXmlRootEntitySet();

		Set<XmlElementEntity> xmlElementEntityset = xmlRule.getXmlElementEntitySet();

		try {

			String data = "";
			// data1 = new
			// String(Files.readAllBytes(Paths.get("/home/user/Desktop/audit_response")));
			data = data1;
			if (data.contains("Executing NeCreationTime")) {
				
					outputResult="PASS";
					//resultJson.put("rows", "Alram Time is there in response");
					jsonResult.put("outputResult", outputResult);
					jsonResult.put("ruleResultJson", resultJson);	
				return jsonResult.toString();
			}else if (data.contains("Executing PackageInventory")) {
				if (data.contains("Target NE is not initialized")) {
					outputResult="PASS";
					//resultJson.put("rows", "Alram Time is there in response");
					jsonResult.put("outputResult", outputResult);
					jsonResult.put("ruleResultJson", resultJson);
				}else {
					outputResult="FAIL";
					resultJson.put("rows", "Target Ne is initialized");
					jsonResult.put("outputResult", outputResult);
					jsonResult.put("ruleResultJson", resultJson);
				}
				return jsonResult.toString();
				
			}
				
			String finalOutput = requiredXmlOutput(xmlRule, data, xmlRuleOccurence, neName, enbId);

			List<String> rootArray = new ArrayList<>();

			while (finalOutput.length() > 0) {
				int stIndex = finalOutput.indexOf("<" + rootName + "");
				// Swetha added below condition
				if (rootName.contains(" ")) {
					rootName = StringUtils.substringBefore(rootName, " ");
					rootName = rootName.trim();
				}
				int endIndex = finalOutput.indexOf("</" + rootName + ">");
				if (stIndex != -1) {
					String subdata = finalOutput.substring(stIndex, endIndex + rootName.length() + 3);
					finalOutput = finalOutput.substring(endIndex + rootName.length() + 3);
					rootArray.add(subdata);

				} else {
					break;
				}
			}

			int yesCount = 0;
			int loyesCount = 0;
			List noRowLst = new ArrayList<>();
			List yesRowLst = new ArrayList<>();
			List<String> subRootDetailsArray = null;

			mainloop: for (int row = 0; row < rootArray.size(); row++) {

				Map noCol = null;
				Map yesCol = null;

				String rootData = rootArray.get(row);

				String subdata = rootData;
				List<String> subRootArray = new ArrayList<>();
				subRootDetailsArray = new ArrayList<>();

				if (!subRootName.isEmpty()) {
					while (subdata.length() > 0) {
						int stIndex = subdata.indexOf("<" + subRootName + ">");
						int endIndex = subdata.indexOf("</" + subRootName + ">");
						if (stIndex != -1) {
							String rootDetailData = subdata.substring(stIndex, endIndex + subRootName.length() + 3);
							subdata = subdata.substring(endIndex + subRootName.length() + 3);
							subRootArray.add(rootDetailData);

						} else {
							break;
						}
					}

					for (String subRootData : subRootArray) {

						int noOfCOndition = 0;
						for (XmlRootEntity xmlRootEntity : xmlRootEntityset) {

							String rootKeyValue = xmlRootEntity.getRootKey() + "=" + "\"" + xmlRootEntity.getRootValue()
									+ "\"";

							if (subRootData.contains(rootKeyValue)) {

								noOfCOndition++;

								if (xmlRootEntityset.size() == noOfCOndition) {

									subRootDetailsArray.add(subRootData);

								}
							}
						}
					}

					if (!xmlRootEntityset.isEmpty() && subRootDetailsArray.isEmpty()) {
						finalResult = NO_DATA;
						break mainloop;
					}

					if (subRootDetailsArray.isEmpty()) {
						subRootDetailsArray = subRootArray;

					}

					for (int lorow = 0; lorow < subRootDetailsArray.size(); lorow++) {

						Map lonoCol = null;
						Map loyesCol = null;
						String elementData = subRootDetailsArray.get(lorow);

						for (XmlElementEntity xmlElementEntity : xmlElementEntityset) {

							lonoCol = new HashMap<>();
							loyesCol = new HashMap<>();

							List yesColIndex = new ArrayList<>();
							List noColIndex = new ArrayList<>();

							String elementName = xmlElementEntity.getElementName();
							String elementValue = xmlElementEntity.getElementValue();
							String operator = xmlElementEntity.getOperator();

							String[] lines = elementData.split("\\r?\\n");
							int noOfCol = lines.length;
							for (int col = 0; col < lines.length; col++) {
								String colLine = lines[col];

								if (colLine.contains(elementName) || ("curl".equalsIgnoreCase(elementName) && "CONTAINS"
										.equalsIgnoreCase(operator))/* && colLine.contains(elementValue) */) {

									noOfCol--;
									switch (operator) {

									case "==":
										result = checkXmlEquals(elementName, Integer.valueOf(elementValue), colLine);
										if ("NO".equals(result)) {

											noColIndex.add(elementName);
											lonoCol.put("index", lorow);
											lonoCol.put("columnNames", noColIndex);

										} else if ("YES".equals(result)) {
											yesColIndex.add(elementName);
											loyesCol.put("index", lorow);
											loyesCol.put("columnNames", yesColIndex);
										}
										break;

									case "!=":
										result = checkXmlNotEquals(elementName, Integer.valueOf(elementValue), colLine);
										if ("NO".equals(result)) {

											noColIndex.add(elementName);
											lonoCol.put("index", lorow);
											lonoCol.put("columnNames", noColIndex);

										} else if ("YES".equals(result)) {
											yesColIndex.add(elementName);
											loyesCol.put("index", lorow);
											loyesCol.put("columnNames", yesColIndex);
										}
										break;

									case "<":
										result = checkXmlLessThan(elementName, Integer.valueOf(elementValue), colLine);
										if ("NO".equals(result)) {

											noColIndex.add(elementName);
											lonoCol.put("index", lorow);
											lonoCol.put("columnNames", noColIndex);

										} else if ("YES".equals(result)) {
											yesColIndex.add(elementName);
											loyesCol.put("index", lorow);
											loyesCol.put("columnNames", yesColIndex);
										}
										break;

									case "<=":
										result = checkXmlLessThanEql(elementName, Integer.valueOf(elementValue),
												colLine);
										if ("NO".equals(result)) {

											noColIndex.add(elementName);
											lonoCol.put("index", lorow);
											lonoCol.put("columnNames", noColIndex);

										} else if ("YES".equals(result)) {
											yesColIndex.add(elementName);
											loyesCol.put("index", lorow);
											loyesCol.put("columnNames", yesColIndex);
										}
										break;

									case ">":
										result = checkXmlGreaterThan(elementName, Integer.valueOf(elementValue),
												colLine);
										if ("NO".equals(result)) {

											noColIndex.add(elementName);
											lonoCol.put("index", lorow);
											lonoCol.put("columnNames", noColIndex);

										} else if ("YES".equals(result)) {
											yesColIndex.add(elementName);
											loyesCol.put("index", lorow);
											loyesCol.put("columnNames", yesColIndex);
										}
										break;

									case ">=":
										result = checkXmlGreaterThanEql(elementName, Integer.valueOf(elementValue),
												colLine);
										if ("NO".equals(result)) {

											noColIndex.add(elementName);
											lonoCol.put("index", lorow);
											lonoCol.put("columnNames", noColIndex);

										} else if ("YES".equals(result)) {
											yesColIndex.add(elementName);
											loyesCol.put("index", lorow);
											loyesCol.put("columnNames", yesColIndex);
										}
										break;

									case "CONTAINS":
										if ("curl".equalsIgnoreCase(elementName)) {
											result = checkCurlXmlContains(elementName, elementValue, colLine);
										} else {
											result = checkXmlContains(elementName, elementValue, colLine);
										}

										if ("NO".equals(result)) {

											noColIndex.add(elementName);
											lonoCol.put("index", lorow);
											lonoCol.put("columnNames", noColIndex);

										} else if ("YES".equals(result)) {
											yesColIndex.add(elementName);
											loyesCol.put("index", lorow);
											loyesCol.put("columnNames", yesColIndex);
										}
										break;

									case "ANY":
										result = checkXmlAny(elementName, elementValue, colLine);
										if ("NO".equals(result)) {

											noColIndex.add(elementName);
											lonoCol.put("index", lorow);
											lonoCol.put("columnNames", noColIndex);

										} else if ("YES".equals(result)) {
											yesColIndex.add(elementName);
											loyesCol.put("index", lorow);
											loyesCol.put("columnNames", yesColIndex);
										}
										break;

									case "TEMPLATE":
										result = checkDependentRule(elementName, elementValue, colLine,
												dbcollectionFileName, enbId);
										if ("NO".equals(result)) {

											noColIndex.add(elementName);
											lonoCol.put("index", lorow);
											lonoCol.put("columnNames", noColIndex);

										} else if ("YES".equals(result)) {
											yesColIndex.add(elementName);
											loyesCol.put("index", lorow);
											loyesCol.put("columnNames", yesColIndex);
										}
										break;
									}

								}

								if ((elementName.isEmpty() || elementName.contains(" "))
										&& colLine.contains(elementValue)) {
									result = "YES";
								}
							}
							if (noOfCol == lines.length) {

								noColIndex.add(elementName);
								lonoCol.put("index", lorow);
								lonoCol.put("columnNames", noColIndex);
							}
							if (!lonoCol.isEmpty()) {
								noRowLst.add(lonoCol);
								noRuleResultJson.put("rows", noRowLst);
							}
							if (!loyesCol.isEmpty()) {
								yesRowLst.add(loyesCol);
								yesRuleResultJson.put("rows", yesRowLst);
							}
						}

						if ("YES".equalsIgnoreCase(result)) {
							loyesCount++;
						}

						if ("YES".equalsIgnoreCase(result) && "atleastone".equalsIgnoreCase(loopType)) {
							finalResult = "YES";
							if (lonoCol != null && !lonoCol.isEmpty()) {
								noRowLst.add(lonoCol);
								noRuleResultJson.put("rows", noRowLst);
							}

							if (loyesCol != null && !loyesCol.isEmpty()) {
								yesRowLst.add(loyesCol);
								yesRuleResultJson.put("rows", yesRowLst);
							}
							break mainloop;
						}
						if ("all".equalsIgnoreCase(loopType) && "NO".equalsIgnoreCase(result)) {
							finalResult = "NO";
						}

					}
				} else {

					String elementData = subdata;

					for (XmlElementEntity xmlElementEntity : xmlElementEntityset) {

						noCol = new HashMap<>();
						yesCol = new HashMap<>();

						List yesColIndex = new ArrayList<>();
						List noColIndex = new ArrayList<>();

						String elementName = xmlElementEntity.getElementName();
						String elementValue = xmlElementEntity.getElementValue();
						String operator = xmlElementEntity.getOperator();

						String[] lines = elementData.replaceAll("\\t", "").split("\\r?\\n");

						int noOfCol = lines.length;
						for (int col = 0; col < lines.length; col++) {
							String colLine = lines[col];
							if (colLine.contains(elementName) || ("curl".equalsIgnoreCase(elementName)
									&& "CONTAINS".equalsIgnoreCase(operator))/* && colLine.contains(elementValue) */) {

								switch (operator) {

								case "==":
									result = checkXmlEquals(elementName, Integer.valueOf(elementValue), colLine);
									if ("NO".equals(result)) {

										noColIndex.add(elementName);
										noCol.put("index", row);
										noCol.put("columnNames", noColIndex);

									} else if ("YES".equals(result)) {
										yesColIndex.add(elementName);
										yesCol.put("index", row);
										yesCol.put("columnNames", yesColIndex);
									}
									break;

								case "!=":
									result = checkXmlNotEquals(elementName, Integer.valueOf(elementValue), colLine);
									if ("NO".equals(result)) {

										noColIndex.add(elementName);
										noCol.put("index", row);
										noCol.put("columnNames", noColIndex);

									} else if ("YES".equals(result)) {
										yesColIndex.add(elementName);
										yesCol.put("index", row);
										yesCol.put("columnNames", yesColIndex);
									}
									break;

								case "<":
									result = checkXmlLessThan(elementName, Integer.valueOf(elementValue), colLine);
									if ("NO".equals(result)) {

										noColIndex.add(elementName);
										noCol.put("index", row);
										noCol.put("columnNames", noColIndex);

									} else if ("YES".equals(result)) {
										yesColIndex.add(elementName);
										yesCol.put("index", row);
										yesCol.put("columnNames", yesColIndex);
									}
									break;

								case "<=":
									result = checkXmlLessThanEql(elementName, Integer.valueOf(elementValue), colLine);
									if ("NO".equals(result)) {

										noColIndex.add(elementName);
										noCol.put("index", row);
										noCol.put("columnNames", noColIndex);

									} else if ("YES".equals(result)) {
										yesColIndex.add(elementName);
										yesCol.put("index", row);
										yesCol.put("columnNames", yesColIndex);
									}
									break;

								case ">":
									result = checkXmlGreaterThan(elementName, Integer.valueOf(elementValue), colLine);
									if ("NO".equals(result)) {

										noColIndex.add(elementName);
										noCol.put("index", row);
										noCol.put("columnNames", noColIndex);

									} else if ("YES".equals(result)) {
										yesColIndex.add(elementName);
										yesCol.put("index", row);
										yesCol.put("columnNames", yesColIndex);
									}
									break;

								case ">=":
									result = checkXmlGreaterThanEql(elementName, Integer.valueOf(elementValue),
											colLine);
									if ("NO".equals(result)) {

										noColIndex.add(elementName);
										noCol.put("index", row);
										noCol.put("columnNames", noColIndex);

									} else if ("YES".equals(result)) {
										yesColIndex.add(elementName);
										yesCol.put("index", row);
										yesCol.put("columnNames", yesColIndex);
									}

									break;

								case "CONTAINS":

									if ("curl".equalsIgnoreCase(elementName)) {
										result = checkCurlXmlContains(elementName, elementValue, colLine);
									} else {
										result = checkXmlContains(elementName, elementValue, colLine);
									}

									if ("NO".equals(result)) {

										noColIndex.add(elementName);
										noCol.put("index", row);
										noCol.put("columnNames", noColIndex);

									} else if ("YES".equals(result)) {
										yesColIndex.add(elementName);
										yesCol.put("index", row);
										yesCol.put("columnNames", yesColIndex);
										// Swetha added below condition
										if ("atleastone".equalsIgnoreCase(loopType)) {
											break;
										}
									}

									break;

								case "ANY":
									result = checkXmlAny(elementName, elementValue, colLine);
									if ("NO".equals(result)) {

										noColIndex.add(elementName);
										noCol.put("index", row);
										noCol.put("columnNames", noColIndex);

									} else if ("YES".equals(result)) {
										yesColIndex.add(elementName);
										yesCol.put("index", row);
										yesCol.put("columnNames", yesColIndex);
										// Swetha added below condition
										if ("atleastone".equalsIgnoreCase(loopType)) {
											break;
										}

									}
									break;
								case "TEMPLATE":
									result = checkDependentRule(elementName, elementValue, colLine,
											dbcollectionFileName, enbId);
									if ("NO".equals(result)) {

										noColIndex.add(elementName);
										noCol.put("index", row);
										noCol.put("columnNames", noColIndex);

									} else if ("YES".equals(result)) {
										yesColIndex.add(elementName);
										yesCol.put("index", row);
										yesCol.put("columnNames", yesColIndex);
										// bala added below condition
										if ("atleastone".equalsIgnoreCase(loopType)) {
											break;
										}
									}
									break;
								}

							}
							// Swetha added below condition
							if ("YES".equals(result) && "atleastone".equalsIgnoreCase(loopType)) {
								break;
							}

							if ((elementName.isEmpty() || elementName.contains(" "))
									&& colLine.contains(elementValue)) {
								result = "YES";
							}
						}
						if (noOfCol == lines.length) {

							noColIndex.add(elementName);
							noCol.put("index", row);
							noCol.put("columnNames", noColIndex);
						}

						if (!noCol.isEmpty()) {
							noRowLst.add(noCol);
							noRuleResultJson.put("rows", noRowLst);
						}
						if (!yesCol.isEmpty()) {
							yesRowLst.add(yesCol);
							yesRuleResultJson.put("rows", yesRowLst);
						}
					}

				}

				if (subRootDetailsArray.isEmpty()) {
					if ("YES".equalsIgnoreCase(result)) {
						yesCount++;
					}

					if ("YES".equalsIgnoreCase(result) && "atleastone".equalsIgnoreCase(loopType)) {
						finalResult = "YES";
						if (noCol != null && !noCol.isEmpty()) {
							noRowLst.add(noCol);
							noRuleResultJson.put("rows", noRowLst);
						}

						if (yesCol != null && !yesCol.isEmpty()) {
							yesRowLst.add(yesCol);
							yesRuleResultJson.put("rows", yesRowLst);
						}
						break mainloop;
					}
					if ("all".equalsIgnoreCase(loopType) && "NO".equalsIgnoreCase(result)) {
						finalResult = "NO";
					}

				}
			}

			if (subRootDetailsArray == null) {
				finalResult = NO_DATA;
			} else {
				if (subRootDetailsArray.isEmpty()) {
					if (rootArray.size() == yesCount) {
						finalResult = "YES";
					}
				} else if (!subRootDetailsArray.isEmpty()) {
					if (subRootDetailsArray.size() == loyesCount) {
						finalResult = "YES";
					}
				}
			}
			/*
			 * if ("NEGrow".equalsIgnoreCase(subtype)) { String neGrowOutput =
			 * "{\"RESULT\":\"OK\"}"; if (StringUtils.isNotEmpty(finalOutput) &&
			 * finalOutput.contains(neGrowOutput)) { finalResult = "YES"; } }
			 */
			if ("NEGrow".equalsIgnoreCase(subtype)) {
				String neGrowOutput = null;
				if (xmlElementEntityset != null && xmlElementEntityset.size() > 0) {
					for (XmlElementEntity xmlElementEntityObj : xmlElementEntityset) {
						neGrowOutput = xmlElementEntityObj.getElementValue();
						break;
					}
				}
				if (StringUtils.isNotEmpty(finalOutput) && StringUtils.isNotEmpty(neGrowOutput)
						&& finalOutput.contains(neGrowOutput)) {
					finalResult = "YES";
				}
			}
			outputResult = getPassFail(cmdResult, finalResult);

			resultJson = getResultJson(cmdResult, outputResult, noRuleResultJson, yesRuleResultJson);
			jsonResult.put("outputResult", outputResult);
			jsonResult.put("ruleResultJson", resultJson);

		} catch (Exception e) {
			logger.error("Exception xmlParsing() in RunTestServiceImpl :" + ExceptionUtils.getFullStackTrace(e));
		}

		return jsonResult.toString();
	}

	public String checkXmlContains(String elementName, String value, String line) {

		String result = "NO";
		try {

			int stIndex = line.indexOf('<') + elementName.length() + 2;
			int endIndex = line.indexOf("</");
			try {
				String lineValue = "";
				// String lineValue = line.substring(stIndex, endIndex);
				// Swetha added below condition
				if (StringUtils.isNotEmpty(elementName) && endIndex > stIndex) {
					lineValue = line.substring(stIndex, endIndex);
				} else {
					lineValue = line;
				}
				if (lineValue.contains(value)) {
					result = "YES";
				}
			} catch (NumberFormatException e) {
				result = "NO";
			}

		} catch (Exception e) {
			logger.error("Exception checkXmlEquals() in RunTestServiceImpl :" + ExceptionUtils.getFullStackTrace(e));
		}

		return result;

	}

	public String checkCurlXmlContains(String elementName, String value, String line) {

		String result = "NO";

		try {

			if (line.contains(value)) {
				result = "YES";
			}

		} catch (Exception e) {
			logger.error(
					"Exception checkCurlXmlContains() in RunTestServiceImpl :" + ExceptionUtils.getFullStackTrace(e));
			result = "NO";
		}

		return result;

	}

	public String checkXmlAny(String elementName, String value, String line) {
		String[] inputValue = value.replaceAll("^\\s*\\[|\\]\\s*$", "").split("\\s*,\\s*");
		List<String> list = Arrays.asList(inputValue);
		String result = "NO";
		try {

			int stIndex = line.indexOf('<') + elementName.length() + 2;
			int endIndex = line.indexOf("</");
			try {
				String lineValue = "";
				if (StringUtils.isNotEmpty(elementName) && endIndex > stIndex) {
					lineValue = line.substring(stIndex, endIndex);
				} else {
					lineValue = line;
				}
				if (list.contains(lineValue)) {
					result = "YES";
				}
			} catch (NumberFormatException e) {
				result = "NO";
			}

		} catch (Exception e) {
			logger.error("Exception checkXmlEquals() in RunTestServiceImpl :" + ExceptionUtils.getFullStackTrace(e));
		}

		return result;

	}

	public String checkXmlEquals(String elementName, int value, String line) {

		String result = "NO";
		try {

			int stIndex = line.indexOf('<') + elementName.length() + 2;
			int endIndex = line.indexOf("</");
			try {
				int lineValue = Integer.parseInt(line.substring(stIndex, endIndex));

				if (lineValue == value) {
					result = "YES";

				}
			} catch (NumberFormatException e) {
				result = "NO";
			}

		} catch (Exception e) {
			logger.error("Exception checkXmlEquals() in RunTestServiceImpl :" + ExceptionUtils.getFullStackTrace(e));
		}

		return result;

	}

	public String checkXmlNotEquals(String elementName, int value, String line) {

		String result = "NO";
		try {

			int stIndex = line.indexOf('<') + elementName.length() + 2;
			int endIndex = line.indexOf("</");
			try {
				int lineValue = Integer.parseInt(line.substring(stIndex, endIndex));

				if (lineValue != value) {
					result = "YES";

				}
			} catch (NumberFormatException e) {
				result = "NO";
			}

		} catch (Exception e) {
			logger.error("Exception checkXmlNotEquals() in RunTestServiceImpl :" + ExceptionUtils.getFullStackTrace(e));
		}

		return result;

	}

	public String checkXmlLessThan(String elementName, int value, String line) {

		String result = "NO";
		try {
			int stIndex = line.indexOf('<') + elementName.length() + 2;
			int endIndex = line.indexOf("</");
			try {
				int lineValue = Integer.parseInt(line.substring(stIndex, endIndex));

				if (lineValue < value) {
					result = "YES";

				}
			} catch (NumberFormatException e) {
				result = "NO";
			}

		} catch (Exception e) {
			logger.error("Exception checkXmlLessThan() in RunTestServiceImpl :" + ExceptionUtils.getFullStackTrace(e));
		}

		return result;

	}

	public String checkXmlLessThanEql(String elementName, int value, String line) {

		String result = "NO";
		try {
			int stIndex = line.indexOf('<') + elementName.length() + 2;
			int endIndex = line.indexOf("</");
			try {
				int lineValue = Integer.parseInt(line.substring(stIndex, endIndex));

				if (lineValue <= value) {
					result = "YES";

				}
			} catch (NumberFormatException e) {
				result = "NO";
			}

		} catch (Exception e) {
			logger.error(
					"Exception checkXmlLessThanEql() in RunTestServiceImpl :" + ExceptionUtils.getFullStackTrace(e));
		}

		return result;

	}

	public String checkXmlGreaterThan(String elementName, int value, String line) {

		String result = "NO";
		try {
			int stIndex = line.indexOf('<') + elementName.length() + 2;
			int endIndex = line.indexOf("</");

			try {
				int lineValue = Integer.parseInt(line.substring(stIndex, endIndex));

				if (lineValue > value) {
					result = "YES";

				}
			} catch (NumberFormatException e) {
				result = "NO";
			}

		} catch (Exception e) {
			logger.error(
					"Exception checkXmlGreaterThan() in RunTestServiceImpl :" + ExceptionUtils.getFullStackTrace(e));
		}
		return result;

	}

	public String checkXmlGreaterThanEql(String elementName, int value, String line) {

		String result = "NO";
		try {
			int stIndex = line.indexOf('<') + elementName.length() + 2;
			int endIndex = line.indexOf("</");
			try {
				int lineValue = Integer.parseInt(line.substring(stIndex, endIndex));

				if (lineValue >= value) {
					result = "YES";

				}
			} catch (NumberFormatException e) {
				result = "NO";
			}

		} catch (Exception e) {
			logger.error(
					"Exception checkXmlGreaterThanEql() in RunTestServiceImpl :" + ExceptionUtils.getFullStackTrace(e));
		}
		return result;

	}

	public static String readFileAsString(String fileName) {
		String data = "";
		try {
			data = new String(Files.readAllBytes(Paths.get(fileName)));
		} catch (IOException e) {
			logger.error("Exception readFileAsString() in RunTestServiceImpl :" + ExceptionUtils.getFullStackTrace(e));
		}
		return data;
	}

	public String shellProcess(ShellCmdRuleBuilderEntity shellRule, String output, int cmdSequence, String neName,
			String enbId) {

		String resultValue = "FAIL";
		try {

			String opeCol1 = shellRule.getOperand1ColumnNames();
			String opeCol2 = shellRule.getOperand2ColumnNames();
			String operand1 = shellRule.getOperand1Values();
			String operand2 = shellRule.getOperand2Values();
			String cmdSatus = shellRule.getStatus();
			String operator = shellRule.getOperator();
			String loopType = shellRule.getLoopType();
			String resultType = shellRule.getResultType();
			String cmdName = shellRule.getCmdName();

			String finalOutput = requiredOutput(shellRule, output, cmdSequence, neName, enbId);

			if ("line".equalsIgnoreCase(resultType)) {

				resultValue = shellLine(finalOutput, opeCol1, operand1, cmdSatus, loopType);

				return resultValue;

			} else if ("table".equalsIgnoreCase(resultType)) {

				switch (operator) {

				case "CONTAINS":

					resultValue = shellContains(finalOutput, shellRule);

					return resultValue;

				case "==":

					resultValue = shellEql(finalOutput, shellRule);

					return resultValue;

				case "!=":

					resultValue = shellNotEql(finalOutput, shellRule);
					return resultValue;

				case "<":

					resultValue = shellLess(finalOutput, shellRule);

					return resultValue;

				case ">":

					resultValue = shellGreater(finalOutput, shellRule);
					return resultValue;
				case ">=":

					resultValue = shellGreaterEql(finalOutput, shellRule);
					return resultValue;

				case "<=":

					resultValue = shellLessEql(finalOutput, shellRule);
					return resultValue;
				}

			}
		} catch (Exception e) {
			logger.error("Exception shellProcess() in RunTestServiceImpl :" + ExceptionUtils.getFullStackTrace(e));
		}
		return resultValue;

	}

	public String cliProcess(CmdRuleBuilderEntity cmdRule, String output, int cmdSequence, String neName,
			String enbId) {
		String result = "FAIL";
		try {
			String opeCol1 = cmdRule.getOperand1ColumnNames();
			String opeCol2 = cmdRule.getOperand2ColumnNames();
			String operand1 = cmdRule.getOperand1Values();
			String operand2 = cmdRule.getOperand2Values();
			String cmdSatus = cmdRule.getStatus();
			String operator = cmdRule.getOperator();
			String loopType = cmdRule.getLoopType();

			Object resultValue;

			String finalOutput = requiredOutput(cmdRule, output, cmdSequence, neName, enbId);

			switch (operator) {

			case "CONTAINS":

				resultValue = cliContains(finalOutput, opeCol1, opeCol2, operand1, operand2, cmdSatus, loopType);
				return resultValue.toString();

			case "==":

				resultValue = cliEql(finalOutput, opeCol1, opeCol2, operand1, operand2, cmdSatus, loopType);
				return resultValue.toString();

			case "!=":

				resultValue = cliNotEql(finalOutput, opeCol1, opeCol2, operand1, operand2, cmdSatus, loopType);
				return resultValue.toString();

			case "<":

				resultValue = cliLess(finalOutput, opeCol1, opeCol2, operand1, operand2, cmdSatus, loopType);

				return resultValue.toString();

			case ">":

				resultValue = cliGreater(finalOutput, opeCol1, opeCol2, operand1, operand2, cmdSatus, loopType);
				return resultValue.toString();
			case ">=":

				resultValue = cliGreaterEql(finalOutput, opeCol1, opeCol2, operand1, operand2, cmdSatus, loopType);
				return resultValue.toString();

			case "<=":

				resultValue = cliLessEql(finalOutput, opeCol1, opeCol2, operand1, operand2, cmdSatus, loopType);
				return resultValue.toString();

			case "ANY":

				resultValue = cliAny(finalOutput, opeCol1, opeCol2, operand1, operand2, cmdSatus, loopType);
				return resultValue.toString();
			}
		} catch (Exception e) {
			logger.error("Exception cliProcess() in RunTestServiceImpl :" + ExceptionUtils.getFullStackTrace(e));
		}

		return result;

	}

	private String requiredXmlOutput(XmlRuleBuilderEntity xmlRule, String output, int cmdSequence, String neName,
			String enbId) {
		String finalOutput = "";
		try {

			String[] data1 = output
					.split(Pattern.quote(xmlRule.getPrompt().replaceAll("enbname", neName).replace("enbId", enbId)));

			List cmdoutput = new ArrayList<>();
			String cmd = xmlRule.getCmdName();

			for (int i = 0; i < data1.length; i++) {
				if (data1[i].contains(cmd)) {

					cmdoutput.add(data1[i]);
				}

			}
			if (!cmdoutput.isEmpty()) {
				finalOutput = cmdoutput.get(cmdSequence - 1).toString();

			}

		} catch (Exception e) {
			logger.info("Exception in requiredXmlOutput() in RunTestServiceImpl" + ExceptionUtils.getFullStackTrace(e));
		}
		return finalOutput;
	}

	private String requiredOutput(CmdRuleBuilderEntity cmdRule, String output, int cmdSequence, String neName,
			String enbId) {
		String finalOutput = "";
		try {

			String[] data1 = output
					.split(Pattern.quote(cmdRule.getPrompt().replaceAll("enbname", neName).replace("enbId", enbId)));

			List cmdoutput = new ArrayList<>();
			String cmd = cmdRule.getCmdName();

			for (int i = 0; i < data1.length; i++) {
				if (data1[i].contains(cmd)) {

					cmdoutput.add(data1[i]);
				}

			}

			if (!cmdoutput.isEmpty()) {
				finalOutput = cmdoutput.get(cmdSequence - 1).toString();

			}

		} catch (Exception e) {
			logger.info("Exception in requiredOutput() in RunTestServiceImpl" + ExceptionUtils.getFullStackTrace(e));
		}

		return finalOutput;
	}

	private String requiredOutput(ShellCmdRuleBuilderEntity shellRule, String output, int cmdSequence, String neName,
			String enbId) {
		String finalOutput = "";
		try {

			String[] data = output
					.split(Pattern.quote(shellRule.getPrompt().replaceAll("enbname", neName).replace("enbId", enbId)));
			List cmdoutput = new ArrayList<>();
			String cmd = shellRule.getCmdName();

			for (int i = 0; i < data.length; i++) {
				String[] lines = data[i].split("\\r?\\n");
				String cmdline = lines[0].substring(lines[0].indexOf(" ")).trim();
				if (lines.length != 0 && cmdline.equalsIgnoreCase(cmd)) {
					cmdoutput.add(data[i]);
				}
			}
			if (!cmdoutput.isEmpty()) {
				finalOutput = cmdoutput.get(cmdSequence - 1).toString();
			}
		} catch (Exception e) {
			logger.info("Exception in requiredOutput() in RunTestServiceImpl" + ExceptionUtils.getFullStackTrace(e));
		}
		return finalOutput;
	}

	private JSONObject cliGreater(String cliOutput, String opeCol1, String opeCol2, String operand1, String operand2,
			String cmdResult, String loopType) {
		String result = NO_DATA;
		String outputResult = NO_DATA;
		String finalResult = NO_DATA;
		String[] operandOneCol = opeCol1.trim().split(ruleDelimiter);
		String[] operandTwoCol = opeCol2.trim().split(ruleDelimiter);
		String[] operandOnevalueInput = operand1.trim().split(ruleDelimiter);
		String[] operandTwovalueInput = operand2.trim().split(ruleDelimiter);
		JSONObject jsonResult = new JSONObject();
		JSONObject ruleResultJson = new JSONObject();
		JSONObject resultJson = new JSONObject();
		JSONObject yesRuleResultJson = new JSONObject();
		List opndOnecolIndex = new ArrayList<>();
		List opndTwocolIndex = new ArrayList<>();

		try {
			String[] lines = cliOutput.split("\\r?\\n");
			boolean header = true;

			// looping lines
			String format = "";
			int startLine = 0;
			int singlelinenum = 0;
			for (; singlelinenum < lines.length; singlelinenum++) {
				if (lines[singlelinenum].contains(COMPLETE)) {
					if (lines[singlelinenum + 1].contains(DOUBLE_LINE)
							|| lines[singlelinenum + 1].contains(SINGLE_LINE)) {
						format = "table";
						startLine = singlelinenum + 2;
						break;
					} else {
						format = "line";
						startLine = singlelinenum + 1;
						break;
					}
				}
			}
			if ("table".equalsIgnoreCase(format)) {
				List rowLst = new ArrayList<>();
				List yesRowLst = new ArrayList<>();
				int opOneColLength = operandOneCol.length;
				int opTwoColLength = operandTwoCol.length;

				int conSatisfiedCount = 0;
				int yesCount = 0;
				int noCount = 0;
				mainloop: for (int linenum = startLine; linenum < lines.length; linenum++) {
					String[] colList = lines[linenum].trim().split(" " + "\\s+");
					Map col = new HashMap<>();
					Map yescol = new HashMap<>();
					int connum = 0;
					if (header) {
						for (int colnum = 0; colnum < colList.length; colnum++) {
							for (int valuenum = 0; valuenum < operandOneCol.length; valuenum++) {
								if (colList[colnum].trim().equalsIgnoreCase(operandOneCol[valuenum].trim())) {
									opndOnecolIndex.add(colnum);
									opOneColLength--;
								}
							}
							for (int valuenum = 0; valuenum < operandTwoCol.length; valuenum++) {
								if (colList[colnum].trim().equalsIgnoreCase(operandTwoCol[valuenum].trim())) {
									opndTwocolIndex.add(colnum);
									opTwoColLength--;
								}
							}

							if (operandOneCol.length == opndOnecolIndex.size()
									&& operandTwoCol.length == opndTwocolIndex.size()) {
								break;
							}

						}
						header = false;
						continue mainloop;

					}

					if (opOneColLength != 0 || opTwoColLength != 0) {
						outputResult = NO_DATA;
						break mainloop;
					}

					// got the header index use that to get the values
					Boolean conSatisfied = false;
					if (!colList[0].contains(DOUBLE_LINE) && !colList[0].contains(SINGLE_LINE)) {
						if (colList[0].contains(RESULT_OK)) {
							break mainloop;
						}

						for (int j = 0; j < opndOnecolIndex.size(); j++) {
							if (colList.length > j && colList[(int) opndOnecolIndex.get(j)].trim()
									.equalsIgnoreCase(operandOnevalueInput[connum].trim())) {
								conSatisfied = true;
							} else {
								conSatisfied = false;
								break;
							}
							connum++;
						}
					}

					if (conSatisfied) {
						int valuenum = 0;
						conSatisfiedCount++;
						List colIndex = new ArrayList<>();
						List yesColIndex = new ArrayList<>();
						int numOfCol = 0;
						int numofColYes = 0;
						int numofColNo = 0;
						for (int m = 0; m < opndTwocolIndex.size(); m++) {
							int outputValue = 0;
							int inputValue = 0;
							try {
								numOfCol++;
								outputValue = Integer.parseInt(colList[(int) opndTwocolIndex.get(m)].trim());
								inputValue = Integer.parseInt(operandTwovalueInput[valuenum].trim());

								if (outputValue > inputValue) {
									yesColIndex.add((int) opndTwocolIndex.get(m));
									yescol.put("index", linenum - (singlelinenum + 4));
									yescol.put("columnIndexes", yesColIndex);

									result = "YES";

									numofColYes++;

								} else {
									result = "NO";
									numofColNo++;
									colIndex.add((int) opndTwocolIndex.get(m));
									col.put("index", linenum - (singlelinenum + 4));
									col.put("columnIndexes", colIndex);
								}
							} catch (NumberFormatException e) {
								result = "NO";
								numofColNo++;
								colIndex.add((int) opndTwocolIndex.get(m));
								col.put("index", linenum - (singlelinenum + 4));
								col.put("columnIndexes", colIndex);
							}
							valuenum++;
							if ("YES".equalsIgnoreCase(result) && "atleastone".equalsIgnoreCase(loopType)) {
								finalResult = "YES";
								if (!col.isEmpty()) {
									rowLst.add(col);
									ruleResultJson.put("rows", rowLst);
								}

								if (!yescol.isEmpty()) {
									yesRowLst.add(yescol);
									yesRuleResultJson.put("rows", yesRowLst);
								}
								break mainloop;
							}
							if ("all".equalsIgnoreCase(loopType) && "NO".equalsIgnoreCase(result)) {
								finalResult = "NO";
							}
						}
						if (numofColYes != 0 && numOfCol != 0 && numOfCol == numofColYes) {
							yesCount++;
						}
						if (numofColNo != 0 && numOfCol != 0 && numOfCol == numofColNo) {
							noCount++;

						}
					}

					if (!col.isEmpty()) {
						rowLst.add(col);
						ruleResultJson.put("rows", rowLst);
					}
					if (!yescol.isEmpty()) {
						yesRowLst.add(yescol);
						yesRuleResultJson.put("rows", yesRowLst);
					}
				}
				if (conSatisfiedCount != 0 && conSatisfiedCount == yesCount) {
					finalResult = "YES";
				}
				if (conSatisfiedCount != 0 && conSatisfiedCount == noCount) {
					finalResult = "NO";
				}
				outputResult = getPassFail(cmdResult, finalResult);
				resultJson = getResultJson(cmdResult, outputResult, ruleResultJson, yesRuleResultJson);
			}

			if ("line".equalsIgnoreCase(format)) {
				int opOnecolLength = operandOneCol.length;
				int opTwocolLength = operandTwoCol.length;
				Boolean conSatisfied = false;
				List<String> opOnelist = Arrays.asList(operandOneCol);
				for (int linenum = startLine; linenum < lines.length; linenum++) {
					if (lines[linenum].trim().contains("=")) {
						String[] lineValue = lines[linenum].trim().split("=");
						String col = lineValue[0].trim();
						String value = lineValue[1].trim();
						if (opOnelist.contains(col)) {
							int colIndex = opOnelist.indexOf(col);
							if (value.equalsIgnoreCase(operandOnevalueInput[colIndex])) {
								conSatisfied = true;
							} else {
								conSatisfied = false;
								break;
							}
							opOnecolLength--;
							if (opOnecolLength == 0) {
								break;
							}
						}
					}

				}
				if (opOnecolLength != 0) {
					conSatisfied = false;
					outputResult = NO_DATA;
				} else if (opOnecolLength == 0 && conSatisfied) {
					List<String> opTwolist = Arrays.asList(operandTwoCol);
					for (int linenum = startLine; linenum < lines.length; linenum++) {
						if (lines[linenum].trim().contains("=")) {
							String[] lineValue = lines[linenum].trim().split("=");
							String col = lineValue[0].trim();
							try {
								int outputValue = Integer.parseInt(lineValue[1].trim());

								if (opTwolist.contains(col)) {
									int colIndex = opTwolist.indexOf(col);
									int inputValue = Integer.parseInt(operandTwovalueInput[colIndex]);

									if (outputValue > inputValue) {

										result = "YES";
									} else {
										result = "NO";
									}
									opTwocolLength--;
									if (opTwocolLength == 0) {
										break;
									}

								}
							} catch (NumberFormatException e) {
								result = "NO";
							}

						}
					}
				}
				if (opTwocolLength != 0) {
					outputResult = NO_DATA;
				}
				outputResult = getPassFail(cmdResult, result);
			}
			jsonResult.put("outputResult", outputResult);
			jsonResult.put("ruleResultJson", resultJson);

		} catch (Exception e) {
			logger.error("Exception RunTestServiceImpl in cliGreater() " + ExceptionUtils.getFullStackTrace(e));
		}

		return jsonResult;
	}

	private JSONObject cliGreaterEql(String cliOutput, String opeCol1, String opeCol2, String operand1, String operand2,
			String cmdResult, String loopType) {
		String result = NO_DATA;
		String outputResult = NO_DATA;
		String finalResult = NO_DATA;
		String[] operandOneCol = opeCol1.trim().split(ruleDelimiter);
		String[] operandTwoCol = opeCol2.trim().split(ruleDelimiter);
		String[] operandOnevalueInput = operand1.trim().split(ruleDelimiter);
		String[] operandTwovalueInput = operand2.trim().split(ruleDelimiter);
		JSONObject jsonResult = new JSONObject();
		JSONObject ruleResultJson = new JSONObject();
		JSONObject resultJson = new JSONObject();
		JSONObject yesRuleResultJson = new JSONObject();
		List opndOnecolIndex = new ArrayList<>();
		List opndTwocolIndex = new ArrayList<>();

		try {
			String[] lines = cliOutput.split("\\r?\\n");
			boolean header = true;

			// looping lines
			String format = "";
			int startLine = 0;
			int singlelinenum = 0;
			for (; singlelinenum < lines.length; singlelinenum++) {
				if (lines[singlelinenum].contains(COMPLETE)) {
					if (lines[singlelinenum + 1].contains(DOUBLE_LINE)
							|| lines[singlelinenum + 1].contains(SINGLE_LINE)) {
						format = "table";
						startLine = singlelinenum + 2;
						break;
					} else {
						format = "line";
						startLine = singlelinenum + 1;
						break;
					}
				}
			}
			if ("table".equalsIgnoreCase(format)) {
				List rowLst = new ArrayList<>();
				List yesRowLst = new ArrayList<>();
				int opOneColLength = operandOneCol.length;
				int opTwoColLength = operandTwoCol.length;

				int conSatisfiedCount = 0;
				int yesCount = 0;
				int noCount = 0;
				mainloop: for (int linenum = startLine; linenum < lines.length; linenum++) {
					String[] colList = lines[linenum].trim().split(" " + "\\s+");
					Map col = new HashMap<>();
					Map yescol = new HashMap<>();
					int connum = 0;
					if (header) {
						for (int colnum = 0; colnum < colList.length; colnum++) {
							for (int valuenum = 0; valuenum < operandOneCol.length; valuenum++) {
								if (colList[colnum].trim().equalsIgnoreCase(operandOneCol[valuenum].trim())) {
									opndOnecolIndex.add(colnum);
									opOneColLength--;
								}
							}
							for (int valuenum = 0; valuenum < operandTwoCol.length; valuenum++) {
								if (colList[colnum].trim().equalsIgnoreCase(operandTwoCol[valuenum].trim())) {
									opndTwocolIndex.add(colnum);
									opTwoColLength--;
								}
							}

							if (operandOneCol.length == opndOnecolIndex.size()
									&& operandTwoCol.length == opndTwocolIndex.size()) {
								break;
							}

						}
						header = false;
						continue mainloop;

					}

					if (opOneColLength != 0 || opTwoColLength != 0) {
						outputResult = NO_DATA;
						break mainloop;
					}

					// got the header index use that to get the values
					Boolean conSatisfied = false;
					if (!colList[0].contains(DOUBLE_LINE) && !colList[0].contains(SINGLE_LINE)) {
						if (colList[0].contains(RESULT_OK)) {
							break mainloop;
						}

						for (int j = 0; j < opndOnecolIndex.size(); j++) {
							if (colList.length > j && colList[(int) opndOnecolIndex.get(j)].trim()
									.equalsIgnoreCase(operandOnevalueInput[connum].trim())) {
								conSatisfied = true;
							} else {
								conSatisfied = false;
								break;
							}
							connum++;
						}
					}

					if (conSatisfied) {
						int valuenum = 0;
						conSatisfiedCount++;
						List colIndex = new ArrayList<>();
						List yesColIndex = new ArrayList<>();
						int numOfCol = 0;
						int numofColYes = 0;
						int numofColNo = 0;
						for (int m = 0; m < opndTwocolIndex.size(); m++) {
							int outputValue = 0;
							int inputValue = 0;
							try {
								numOfCol++;
								outputValue = Integer.parseInt(colList[(int) opndTwocolIndex.get(m)].trim());
								inputValue = Integer.parseInt(operandTwovalueInput[valuenum].trim());

								if (outputValue >= inputValue) {
									yesColIndex.add((int) opndTwocolIndex.get(m));
									yescol.put("index", linenum - (singlelinenum + 4));
									yescol.put("columnIndexes", yesColIndex);

									result = "YES";
									numofColYes++;
								} else {
									result = "NO";
									numofColNo++;
									colIndex.add((int) opndTwocolIndex.get(m));
									col.put("index", linenum - (singlelinenum + 4));
									col.put("columnIndexes", colIndex);
								}
							} catch (NumberFormatException e) {
								result = "NO";
								numofColNo++;
								colIndex.add((int) opndTwocolIndex.get(m));
								col.put("index", linenum - (singlelinenum + 4));
								col.put("columnIndexes", colIndex);
							}
							valuenum++;
							if ("YES".equalsIgnoreCase(result) && "atleastone".equalsIgnoreCase(loopType)) {
								finalResult = "YES";
								if (!col.isEmpty()) {
									rowLst.add(col);
									ruleResultJson.put("rows", rowLst);
								}

								if (!yescol.isEmpty()) {
									yesRowLst.add(yescol);
									yesRuleResultJson.put("rows", yesRowLst);
								}
								break mainloop;
							}
							if ("all".equalsIgnoreCase(loopType) && "NO".equalsIgnoreCase(result)) {
								finalResult = "NO";
							}
						}
						if (numofColYes != 0 && numOfCol != 0 && numOfCol == numofColYes) {
							yesCount++;
						}
						if (numofColNo != 0 && numOfCol != 0 && numOfCol == numofColNo) {
							noCount++;

						}
					}

					if (!col.isEmpty()) {
						rowLst.add(col);
						ruleResultJson.put("rows", rowLst);
					}
					if (!yescol.isEmpty()) {
						yesRowLst.add(yescol);
						yesRuleResultJson.put("rows", yesRowLst);
					}
				}
				if (conSatisfiedCount != 0 && conSatisfiedCount == yesCount) {
					finalResult = "YES";
				}
				if (conSatisfiedCount != 0 && conSatisfiedCount == noCount) {
					finalResult = "NO";
				}
				outputResult = getPassFail(cmdResult, finalResult);
				resultJson = getResultJson(cmdResult, outputResult, ruleResultJson, yesRuleResultJson);
			}

			if ("line".equalsIgnoreCase(format)) {
				int opOnecolLength = operandOneCol.length;
				int opTwocolLength = operandTwoCol.length;
				Boolean conSatisfied = false;
				List<String> opOnelist = Arrays.asList(operandOneCol);
				for (int linenum = startLine; linenum < lines.length; linenum++) {
					if (lines[linenum].trim().contains("=")) {
						String[] lineValue = lines[linenum].trim().split("=");
						String col = lineValue[0].trim();
						String value = lineValue[1].trim();
						if (opOnelist.contains(col)) {
							int colIndex = opOnelist.indexOf(col);
							if (value.equalsIgnoreCase(operandOnevalueInput[colIndex])) {
								conSatisfied = true;
							} else {
								conSatisfied = false;
								break;
							}
							opOnecolLength--;
							if (opOnecolLength == 0) {
								break;
							}
						}
					}

				}
				if (opOnecolLength != 0) {
					conSatisfied = false;
					outputResult = NO_DATA;
				} else if (opOnecolLength == 0 && conSatisfied) {
					List<String> opTwolist = Arrays.asList(operandTwoCol);
					for (int linenum = startLine; linenum < lines.length; linenum++) {
						if (lines[linenum].trim().contains("=")) {
							String[] lineValue = lines[linenum].trim().split("=");
							String col = lineValue[0].trim();
							try {
								int outputValue = Integer.parseInt(lineValue[1].trim());

								if (opTwolist.contains(col)) {
									int colIndex = opTwolist.indexOf(col);
									int inputValue = Integer.parseInt(operandTwovalueInput[colIndex]);

									if (outputValue >= inputValue) {
										result = "YES";
									} else {
										result = "NO";
									}
									opTwocolLength--;
									if (opTwocolLength == 0) {
										break;
									}

								}
							} catch (NumberFormatException e) {
								result = "NO";
							}

						}
					}
				}
				if (opTwocolLength != 0) {
					outputResult = NO_DATA;
				}
				outputResult = getPassFail(cmdResult, result);
			}
			jsonResult.put("outputResult", outputResult);
			jsonResult.put("ruleResultJson", resultJson);

		} catch (Exception e) {
			logger.error("Exception RunTestServiceImpl in cliGreaterEql() " + ExceptionUtils.getFullStackTrace(e));

		}

		return jsonResult;

	}

	private JSONObject cliLess(String cliOutput, String opeCol1, String opeCol2, String operand1, String operand2,
			String cmdResult, String loopType) {
		String result = NO_DATA;
		String outputResult = NO_DATA;
		String finalResult = NO_DATA;
		String[] operandOneCol = opeCol1.trim().split(ruleDelimiter);
		String[] operandTwoCol = opeCol2.trim().split(ruleDelimiter);
		String[] operandOnevalueInput = operand1.trim().split(ruleDelimiter);
		String[] operandTwovalueInput = operand2.trim().split(ruleDelimiter);
		JSONObject jsonResult = new JSONObject();
		JSONObject ruleResultJson = new JSONObject();
		JSONObject resultJson = new JSONObject();
		JSONObject yesRuleResultJson = new JSONObject();
		List opndOnecolIndex = new ArrayList<>();
		List opndTwocolIndex = new ArrayList<>();

		try {
			String[] lines = cliOutput.split("\\r?\\n");
			boolean header = true;

			// looping lines
			String format = "";
			int startLine = 0;
			int singlelinenum = 0;
			for (; singlelinenum < lines.length; singlelinenum++) {
				if (lines[singlelinenum].contains(COMPLETE)) {
					if (lines[singlelinenum + 1].contains(DOUBLE_LINE)
							|| lines[singlelinenum + 1].contains(SINGLE_LINE)) {
						format = "table";
						startLine = singlelinenum + 2;
						break;
					} else {
						format = "line";
						startLine = singlelinenum + 1;
						break;
					}
				}
			}
			if ("table".equalsIgnoreCase(format)) {
				List rowLst = new ArrayList<>();
				List yesRowLst = new ArrayList<>();
				int opOneColLength = operandOneCol.length;
				int opTwoColLength = operandTwoCol.length;

				int conSatisfiedCount = 0;
				int yesCount = 0;
				int noCount = 0;
				mainloop: for (int linenum = startLine; linenum < lines.length; linenum++) {
					String[] colList = lines[linenum].trim().split(" " + "\\s+");
					Map col = new HashMap<>();
					Map yescol = new HashMap<>();
					int connum = 0;
					if (header) {
						for (int colnum = 0; colnum < colList.length; colnum++) {
							for (int valuenum = 0; valuenum < operandOneCol.length; valuenum++) {
								if (colList[colnum].trim().equalsIgnoreCase(operandOneCol[valuenum].trim())) {
									opndOnecolIndex.add(colnum);
									opOneColLength--;
								}
							}
							for (int valuenum = 0; valuenum < operandTwoCol.length; valuenum++) {
								if (colList[colnum].trim().equalsIgnoreCase(operandTwoCol[valuenum].trim())) {
									opndTwocolIndex.add(colnum);
									opTwoColLength--;
								}
							}

							if (operandOneCol.length == opndOnecolIndex.size()
									&& operandTwoCol.length == opndTwocolIndex.size()) {
								break;
							}

						}
						header = false;
						continue mainloop;

					}

					if (opOneColLength != 0 || opTwoColLength != 0) {
						outputResult = NO_DATA;
						break mainloop;
					}

					// got the header index use that to get the values
					Boolean conSatisfied = false;
					if (!colList[0].contains(DOUBLE_LINE) && !colList[0].contains(SINGLE_LINE)) {
						if (colList[0].contains(RESULT_OK)) {
							break mainloop;
						}

						for (int j = 0; j < opndOnecolIndex.size(); j++) {
							if (colList.length > j && colList[(int) opndOnecolIndex.get(j)].trim()
									.equalsIgnoreCase(operandOnevalueInput[connum].trim())) {
								conSatisfied = true;
							} else {
								conSatisfied = false;
								break;
							}
							connum++;
						}
					}

					if (conSatisfied) {
						int valuenum = 0;
						conSatisfiedCount++;
						List colIndex = new ArrayList<>();
						List yesColIndex = new ArrayList<>();
						int numOfCol = 0;
						int numofColYes = 0;
						int numofColNo = 0;
						for (int m = 0; m < opndTwocolIndex.size(); m++) {
							int outputValue = 0;
							int inputValue = 0;
							try {
								numOfCol++;
								outputValue = Integer.parseInt(colList[(int) opndTwocolIndex.get(m)].trim());
								inputValue = Integer.parseInt(operandTwovalueInput[valuenum].trim());

								if (outputValue < inputValue) {
									yesColIndex.add((int) opndTwocolIndex.get(m));
									yescol.put("index", linenum - (singlelinenum + 4));
									yescol.put("columnIndexes", yesColIndex);
									result = "YES";
									numofColYes++;
								} else {
									result = "NO";
									numofColNo++;
									colIndex.add((int) opndTwocolIndex.get(m));
									col.put("index", linenum - (singlelinenum + 4));
									col.put("columnIndexes", colIndex);
								}
							} catch (NumberFormatException e) {
								result = "NO";
								numofColNo++;
								colIndex.add((int) opndTwocolIndex.get(m));
								col.put("index", linenum - (singlelinenum + 4));
								col.put("columnIndexes", colIndex);
							}
							valuenum++;
							if ("YES".equalsIgnoreCase(result) && "atleastone".equalsIgnoreCase(loopType)) {
								finalResult = "YES";
								if (!col.isEmpty()) {
									rowLst.add(col);
									ruleResultJson.put("rows", rowLst);
								}

								if (!yescol.isEmpty()) {
									yesRowLst.add(yescol);
									yesRuleResultJson.put("rows", yesRowLst);
								}
								break mainloop;
							}
							if ("all".equalsIgnoreCase(loopType) && "NO".equalsIgnoreCase(result)) {
								finalResult = "NO";
							}
						}
						if (numofColYes != 0 && numOfCol != 0 && numOfCol == numofColYes) {
							yesCount++;
						}
						if (numofColNo != 0 && numOfCol != 0 && numOfCol == numofColNo) {
							noCount++;

						}
					}

					if (!col.isEmpty()) {
						rowLst.add(col);
						ruleResultJson.put("rows", rowLst);
					}
					if (!yescol.isEmpty()) {
						yesRowLst.add(yescol);
						yesRuleResultJson.put("rows", yesRowLst);
					}
				}
				if (conSatisfiedCount != 0 && conSatisfiedCount == yesCount) {
					finalResult = "YES";
				}
				if (conSatisfiedCount != 0 && conSatisfiedCount == noCount) {
					finalResult = "NO";
				}
				outputResult = getPassFail(cmdResult, finalResult);
				resultJson = getResultJson(cmdResult, outputResult, ruleResultJson, yesRuleResultJson);

			}

			if ("line".equalsIgnoreCase(format)) {
				int opOnecolLength = operandOneCol.length;
				int opTwocolLength = operandTwoCol.length;
				Boolean conSatisfied = false;
				List<String> opOnelist = Arrays.asList(operandOneCol);
				for (int linenum = startLine; linenum < lines.length; linenum++) {
					if (lines[linenum].trim().contains("=")) {
						String[] lineValue = lines[linenum].trim().split("=");
						String col = lineValue[0].trim();
						String value = lineValue[1].trim();
						if (opOnelist.contains(col)) {
							int colIndex = opOnelist.indexOf(col);
							if (value.equalsIgnoreCase(operandOnevalueInput[colIndex])) {
								conSatisfied = true;
							} else {
								conSatisfied = false;
								break;
							}
							opOnecolLength--;
							if (opOnecolLength == 0) {
								break;
							}
						}
					}

				}
				if (opOnecolLength != 0) {
					conSatisfied = false;
					outputResult = NO_DATA;
				} else if (opOnecolLength == 0 && conSatisfied) {
					List<String> opTwolist = Arrays.asList(operandTwoCol);
					for (int linenum = startLine; linenum < lines.length; linenum++) {
						if (lines[linenum].trim().contains("=")) {
							String[] lineValue = lines[linenum].trim().split("=");
							String col = lineValue[0].trim();
							try {
								int outputValue = Integer.parseInt(lineValue[1].trim());

								if (opTwolist.contains(col)) {
									int colIndex = opTwolist.indexOf(col);
									int inputValue = Integer.parseInt(operandTwovalueInput[colIndex]);

									if (outputValue < inputValue) {
										result = "YES";
									} else {
										result = "NO";
									}
									opTwocolLength--;
									if (opTwocolLength == 0) {
										break;
									}

								}
							} catch (NumberFormatException e) {
								result = "NO";
							}

						}

					}
				}
				if (opTwocolLength != 0) {
					outputResult = NO_DATA;
				}
				outputResult = getPassFail(cmdResult, result);
			}
			jsonResult.put("outputResult", outputResult);
			jsonResult.put("ruleResultJson", resultJson);

		} catch (Exception e) {
			logger.error("Exception RunTestServiceImpl in cliLess() " + ExceptionUtils.getFullStackTrace(e));
		}

		return jsonResult;
	}

	private JSONObject cliLessEql(String cliOutput, String opeCol1, String opeCol2, String operand1, String operand2,
			String cmdResult, String loopType) {
		String result = NO_DATA;
		String outputResult = NO_DATA;
		String finalResult = NO_DATA;
		String[] operandOneCol = opeCol1.trim().split(ruleDelimiter);
		String[] operandTwoCol = opeCol2.trim().split(ruleDelimiter);
		String[] operandOnevalueInput = operand1.trim().split(ruleDelimiter);
		String[] operandTwovalueInput = operand2.trim().split(ruleDelimiter);
		JSONObject jsonResult = new JSONObject();
		JSONObject ruleResultJson = new JSONObject();
		JSONObject resultJson = new JSONObject();
		JSONObject yesRuleResultJson = new JSONObject();
		List opndOnecolIndex = new ArrayList<>();
		List opndTwocolIndex = new ArrayList<>();

		try {
			String[] lines = cliOutput.split("\\r?\\n");
			boolean header = true;

			// looping lines
			String format = "";
			int startLine = 0;
			int singlelinenum = 0;
			for (; singlelinenum < lines.length; singlelinenum++) {
				if (lines[singlelinenum].contains(COMPLETE)) {
					if (lines[singlelinenum + 1].contains(DOUBLE_LINE)
							|| lines[singlelinenum + 1].contains(SINGLE_LINE)) {
						format = "table";
						startLine = singlelinenum + 2;
						break;
					} else {
						format = "line";
						startLine = singlelinenum + 1;
						break;
					}
				}
			}
			if ("table".equalsIgnoreCase(format)) {
				List rowLst = new ArrayList<>();
				List yesRowLst = new ArrayList<>();
				int opOneColLength = operandOneCol.length;
				int opTwoColLength = operandTwoCol.length;

				int conSatisfiedCount = 0;
				int yesCount = 0;
				int noCount = 0;
				mainloop: for (int linenum = startLine; linenum < lines.length; linenum++) {
					String[] colList = lines[linenum].trim().split(" " + "\\s+");
					Map col = new HashMap<>();
					Map yescol = new HashMap<>();
					int connum = 0;
					if (header) {
						for (int colnum = 0; colnum < colList.length; colnum++) {
							for (int valuenum = 0; valuenum < operandOneCol.length; valuenum++) {
								if (colList[colnum].trim().equalsIgnoreCase(operandOneCol[valuenum].trim())) {
									opndOnecolIndex.add(colnum);
									opOneColLength--;
								}
							}
							for (int valuenum = 0; valuenum < operandTwoCol.length; valuenum++) {
								if (colList[colnum].trim().equalsIgnoreCase(operandTwoCol[valuenum].trim())) {
									opndTwocolIndex.add(colnum);
									opTwoColLength--;
								}
							}

							if (operandOneCol.length == opndOnecolIndex.size()
									&& operandTwoCol.length == opndTwocolIndex.size()) {
								break;
							}

						}
						header = false;
						continue mainloop;

					}

					if (opOneColLength != 0 || opTwoColLength != 0) {
						outputResult = NO_DATA;
						break mainloop;
					}

					// got the header index use that to get the values
					Boolean conSatisfied = false;
					if (!colList[0].contains(DOUBLE_LINE) && !colList[0].contains(SINGLE_LINE)) {
						if (colList[0].contains(RESULT_OK)) {
							break mainloop;
						}

						for (int j = 0; j < opndOnecolIndex.size(); j++) {
							if (colList.length > j && colList[(int) opndOnecolIndex.get(j)].trim()
									.equalsIgnoreCase(operandOnevalueInput[connum].trim())) {
								conSatisfied = true;
							} else {
								conSatisfied = false;
								break;
							}
							connum++;
						}
					}
					if (conSatisfied) {
						int valuenum = 0;
						conSatisfiedCount++;
						List colIndex = new ArrayList<>();
						List yesColIndex = new ArrayList<>();
						int numOfCol = 0;
						int numofColYes = 0;
						int numofColNo = 0;
						for (int m = 0; m < opndTwocolIndex.size(); m++) {
							int outputValue = 0;
							int inputValue = 0;
							try {
								numOfCol++;
								outputValue = Integer.parseInt(colList[(int) opndTwocolIndex.get(m)].trim());
								inputValue = Integer.parseInt(operandTwovalueInput[valuenum].trim());

								if (outputValue <= inputValue) {
									yesColIndex.add((int) opndTwocolIndex.get(m));
									yescol.put("index", linenum - (singlelinenum + 4));
									yescol.put("columnIndexes", yesColIndex);

									result = "YES";
									numofColYes++;
								} else {
									result = "NO";
									numofColNo++;
									colIndex.add((int) opndTwocolIndex.get(m));
									col.put("index", linenum - (singlelinenum + 4));
									col.put("columnIndexes", colIndex);
								}
							} catch (NumberFormatException e) {
								result = "NO";
								numofColNo++;
								colIndex.add((int) opndTwocolIndex.get(m));
								col.put("index", linenum - (singlelinenum + 4));
								col.put("columnIndexes", colIndex);
							}
							valuenum++;
							if ("YES".equalsIgnoreCase(result) && "atleastone".equalsIgnoreCase(loopType)) {
								finalResult = "YES";
								if (!col.isEmpty()) {
									rowLst.add(col);
									ruleResultJson.put("rows", rowLst);
								}

								if (!yescol.isEmpty()) {
									yesRowLst.add(yescol);
									yesRuleResultJson.put("rows", yesRowLst);
								}
								break mainloop;
							}
							if ("all".equalsIgnoreCase(loopType) && "NO".equalsIgnoreCase(result)) {
								finalResult = "NO";
							}
						}
						if (numofColYes != 0 && numOfCol != 0 && numOfCol == numofColYes) {
							yesCount++;
						}
						if (numofColNo != 0 && numOfCol != 0 && numOfCol == numofColNo) {
							noCount++;

						}
					}

					if (!col.isEmpty()) {
						rowLst.add(col);
						ruleResultJson.put("rows", rowLst);
					}
					if (!yescol.isEmpty()) {
						yesRowLst.add(yescol);
						yesRuleResultJson.put("rows", yesRowLst);
					}
				}
				if (conSatisfiedCount != 0 && conSatisfiedCount == yesCount) {
					finalResult = "YES";
				}
				if (conSatisfiedCount != 0 && conSatisfiedCount == noCount) {
					finalResult = "NO";
				}
				outputResult = getPassFail(cmdResult, finalResult);
				resultJson = getResultJson(cmdResult, outputResult, ruleResultJson, yesRuleResultJson);
			}

			if ("line".equalsIgnoreCase(format)) {
				int opOnecolLength = operandOneCol.length;
				int opTwocolLength = operandTwoCol.length;
				Boolean conSatisfied = false;
				List<String> opOnelist = Arrays.asList(operandOneCol);
				for (int linenum = startLine; linenum < lines.length; linenum++) {
					if (lines[linenum].trim().contains("=")) {
						String[] lineValue = lines[linenum].trim().split("=");
						String col = lineValue[0].trim();
						String value = lineValue[1].trim();
						if (opOnelist.contains(col)) {
							int colIndex = opOnelist.indexOf(col);
							if (value.equalsIgnoreCase(operandOnevalueInput[colIndex])) {
								conSatisfied = true;
							} else {
								conSatisfied = false;
								break;
							}
							opOnecolLength--;
							if (opOnecolLength == 0) {
								break;
							}
						}
					}

				}
				if (opOnecolLength != 0) {
					conSatisfied = false;
					outputResult = NO_DATA;
				} else if (opOnecolLength == 0 && conSatisfied) {
					List<String> opTwolist = Arrays.asList(operandTwoCol);
					for (int linenum = startLine; linenum < lines.length; linenum++) {
						if (lines[linenum].trim().contains("=")) {
							String[] lineValue = lines[linenum].trim().split("=");
							String col = lineValue[0].trim();
							try {
								int outputValue = Integer.parseInt(lineValue[1].trim());

								if (opTwolist.contains(col)) {
									int colIndex = opTwolist.indexOf(col);
									int inputValue = Integer.parseInt(operandTwovalueInput[colIndex]);

									if (outputValue <= inputValue) {
										result = "YES";
									} else {
										result = "NO";
									}
									opTwocolLength--;
									if (opTwocolLength == 0) {
										break;
									}

								}
							} catch (NumberFormatException e) {
								result = "NO";
							}

						}

					}
				}
				if (opTwocolLength != 0) {
					outputResult = NO_DATA;
				}
				outputResult = getPassFail(cmdResult, result);
			}
			jsonResult.put("outputResult", outputResult);
			jsonResult.put("ruleResultJson", resultJson);

		} catch (Exception e) {
			logger.error("Exception RunTestServiceImpl in cliLessEql() " + ExceptionUtils.getFullStackTrace(e));
		}

		return jsonResult;
	}

	private JSONObject cliEql(String cliOutput, String opeCol1, String opeCol2, String operand1, String operand2,
			String cmdResult, String loopType) {
		String result = NO_DATA;
		String outputResult = NO_DATA;
		String finalResult = NO_DATA;
		String[] operandOneCol = opeCol1.trim().split(ruleDelimiter);
		String[] operandTwoCol = opeCol2.trim().split(ruleDelimiter);
		String[] operandOnevalueInput = operand1.trim().split(ruleDelimiter);
		String[] operandTwovalueInput = operand2.trim().split(ruleDelimiter);
		JSONObject jsonResult = new JSONObject();
		JSONObject ruleResultJson = new JSONObject();
		JSONObject resultJson = new JSONObject();
		JSONObject yesRuleResultJson = new JSONObject();
		List opndOnecolIndex = new ArrayList<>();
		List opndTwocolIndex = new ArrayList<>();

		try {
			String[] lines = cliOutput.split("\\r?\\n");
			boolean header = true;

			// looping lines
			String format = "";
			int startLine = 0;
			int singlelinenum = 0;
			for (; singlelinenum < lines.length; singlelinenum++) {
				if (lines[singlelinenum].contains(COMPLETE)) {
					if (lines[singlelinenum + 1].contains(DOUBLE_LINE)
							|| lines[singlelinenum + 1].contains(SINGLE_LINE)) {
						format = "table";
						startLine = singlelinenum + 2;
						break;
					} else {
						format = "line";
						startLine = singlelinenum + 1;
						break;
					}
				}
			}
			if ("table".equalsIgnoreCase(format)) {
				List rowLst = new ArrayList<>();
				List yesRowLst = new ArrayList<>();
				int opOneColLength = operandOneCol.length;
				int opTwoColLength = operandTwoCol.length;

				int conSatisfiedCount = 0;
				int yesCount = 0;
				int noCount = 0;
				mainloop: for (int linenum = startLine; linenum < lines.length; linenum++) {
					String[] colList = lines[linenum].trim().split(" " + "\\s+");
					Map col = new HashMap<>();
					Map yescol = new HashMap<>();
					int connum = 0;
					if (header) {
						for (int colnum = 0; colnum < colList.length; colnum++) {
							for (int valuenum = 0; valuenum < operandOneCol.length; valuenum++) {
								if (colList[colnum].trim().equalsIgnoreCase(operandOneCol[valuenum].trim())) {
									opndOnecolIndex.add(colnum);
									opOneColLength--;
								}
							}
							for (int valuenum = 0; valuenum < operandTwoCol.length; valuenum++) {
								if (colList[colnum].trim().equalsIgnoreCase(operandTwoCol[valuenum].trim())) {
									opndTwocolIndex.add(colnum);
									opTwoColLength--;
								}
							}

							if (operandOneCol.length == opndOnecolIndex.size()
									&& operandTwoCol.length == opndTwocolIndex.size()) {
								break;
							}

						}
						header = false;
						continue mainloop;

					}

					if (opOneColLength != 0 || opTwoColLength != 0) {
						outputResult = NO_DATA;
						break mainloop;
					}

					// got the header index use that to get the values
					Boolean conSatisfied = false;
					if (!colList[0].contains(DOUBLE_LINE) && !colList[0].contains(SINGLE_LINE)) {
						if (colList[0].contains(RESULT_OK)) {
							break mainloop;
						}

						for (int j = 0; j < opndOnecolIndex.size(); j++) {
							if (colList.length > j && colList[(int) opndOnecolIndex.get(j)].trim()
									.equalsIgnoreCase(operandOnevalueInput[connum].trim())) {
								conSatisfied = true;
							} else {
								conSatisfied = false;
								break;
							}
							connum++;
						}
					}

					if (conSatisfied) {
						int valuenum = 0;
						conSatisfiedCount++;
						List colIndex = new ArrayList<>();
						List yesColIndex = new ArrayList<>();
						int numOfCol = 0;
						int numofColYes = 0;
						int numofColNo = 0;
						for (int m = 0; m < opndTwocolIndex.size(); m++) {
							int outputValue = 0;
							int inputValue = 0;
							try {
								numOfCol++;
								outputValue = Integer.parseInt(colList[(int) opndTwocolIndex.get(m)].trim());
								inputValue = Integer.parseInt(operandTwovalueInput[valuenum].trim());

								if (outputValue == inputValue) {
									yesColIndex.add((int) opndTwocolIndex.get(m));
									yescol.put("index", linenum - (singlelinenum + 4));
									yescol.put("columnIndexes", yesColIndex);

									result = "YES";
									numofColYes++;
								} else {
									result = "NO";
									numofColNo++;
									colIndex.add((int) opndTwocolIndex.get(m));
									col.put("index", linenum - (singlelinenum + 4));
									col.put("columnIndexes", colIndex);
								}
							} catch (NumberFormatException e) {
								result = "NO";
								numofColNo++;
								colIndex.add((int) opndTwocolIndex.get(m));
								col.put("index", linenum - (singlelinenum + 4));
								col.put("columnIndexes", colIndex);
							}
							valuenum++;
							if ("YES".equalsIgnoreCase(result) && "atleastone".equalsIgnoreCase(loopType)) {
								finalResult = "YES";
								if (!col.isEmpty()) {
									rowLst.add(col);
									ruleResultJson.put("rows", rowLst);
								}

								if (!yescol.isEmpty()) {
									yesRowLst.add(yescol);
									yesRuleResultJson.put("rows", yesRowLst);
								}
								break mainloop;
							}
							if ("all".equalsIgnoreCase(loopType) && "NO".equalsIgnoreCase(result)) {
								finalResult = "NO";
							}
						}
						if (numofColYes != 0 && numOfCol != 0 && numOfCol == numofColYes) {
							yesCount++;
						}
						if (numofColNo != 0 && numOfCol != 0 && numOfCol == numofColNo) {
							noCount++;

						}
					}

					if (!col.isEmpty()) {
						rowLst.add(col);
						ruleResultJson.put("rows", rowLst);
					}
					if (!yescol.isEmpty()) {
						yesRowLst.add(yescol);
						yesRuleResultJson.put("rows", yesRowLst);
					}
				}
				if (conSatisfiedCount != 0 && conSatisfiedCount == yesCount) {
					finalResult = "YES";
				}
				if (conSatisfiedCount != 0 && conSatisfiedCount == noCount) {
					finalResult = "NO";
				}
				outputResult = getPassFail(cmdResult, finalResult);
				resultJson = getResultJson(cmdResult, outputResult, ruleResultJson, yesRuleResultJson);
			}

			if ("line".equalsIgnoreCase(format)) {
				int opOnecolLength = operandOneCol.length;
				int opTwocolLength = operandTwoCol.length;
				Boolean conSatisfied = false;
				List<String> opOnelist = Arrays.asList(operandOneCol);
				for (int linenum = startLine; linenum < lines.length; linenum++) {
					if (lines[linenum].trim().contains("=")) {
						String[] lineValue = lines[linenum].trim().split("=");
						String col = lineValue[0].trim();
						String value = lineValue[1].trim();
						if (opOnelist.contains(col)) {
							int colIndex = opOnelist.indexOf(col);
							if (value.equalsIgnoreCase(operandOnevalueInput[colIndex])) {
								conSatisfied = true;
							} else {
								conSatisfied = false;
								break;
							}
							opOnecolLength--;
							if (opOnecolLength == 0) {
								break;
							}
						}
					}

				}
				if (opOnecolLength != 0) {
					conSatisfied = false;
					outputResult = NO_DATA;
				} else if (opOnecolLength == 0 && conSatisfied) {
					List<String> opTwolist = Arrays.asList(operandTwoCol);
					for (int linenum = startLine; linenum < lines.length; linenum++) {
						if (lines[linenum].trim().contains("=")) {
							String[] lineValue = lines[linenum].trim().split("=");
							String col = lineValue[0].trim();
							try {
								int outputValue = Integer.parseInt(lineValue[1].trim());

								if (opTwolist.contains(col)) {
									int colIndex = opTwolist.indexOf(col);
									int inputValue = Integer.parseInt(operandTwovalueInput[colIndex]);

									if (outputValue == inputValue) {
										result = "YES";
									} else {
										result = "NO";
									}
									opTwocolLength--;
									if (opTwocolLength == 0) {
										break;
									}

								}

							} catch (NumberFormatException e) {
								result = "NO";
							}

						}
					}
				}
				if (opTwocolLength != 0) {
					outputResult = NO_DATA;
				}
				outputResult = getPassFail(cmdResult, result);
			}
			jsonResult.put("outputResult", outputResult);
			jsonResult.put("ruleResultJson", resultJson);

		} catch (Exception e) {

			logger.error("Exception RunTestServiceImpl in cliEql() " + ExceptionUtils.getFullStackTrace(e));
		}

		return jsonResult;
	}

	private JSONObject cliNotEql(String cliOutput, String opeCol1, String opeCol2, String operand1, String operand2,
			String cmdResult, String loopType) {

		String result = NO_DATA;
		String outputResult = NO_DATA;
		String finalResult = NO_DATA;
		String[] operandOneCol = opeCol1.trim().split(ruleDelimiter);
		String[] operandTwoCol = opeCol2.trim().split(ruleDelimiter);
		String[] operandOnevalueInput = operand1.trim().split(ruleDelimiter);
		String[] operandTwovalueInput = operand2.trim().split(ruleDelimiter);
		JSONObject jsonResult = new JSONObject();
		JSONObject ruleResultJson = new JSONObject();
		JSONObject resultJson = new JSONObject();
		JSONObject yesRuleResultJson = new JSONObject();
		List opndOnecolIndex = new ArrayList<>();
		List opndTwocolIndex = new ArrayList<>();

		try {
			String[] lines = cliOutput.split("\\r?\\n");
			boolean header = true;
			// looping lines
			String format = "";
			int startLine = 0;
			int singlelinenum = 0;
			for (; singlelinenum < lines.length; singlelinenum++) {
				if (lines[singlelinenum].contains(COMPLETE)) {
					if (lines[singlelinenum + 1].contains(DOUBLE_LINE)
							|| lines[singlelinenum + 1].contains(SINGLE_LINE)) {
						format = "table";
						startLine = singlelinenum + 2;
						break;
					} else {
						format = "line";
						startLine = singlelinenum + 1;
						break;
					}
				}
			}
			if ("table".equalsIgnoreCase(format)) {
				List rowLst = new ArrayList<>();
				List yesRowLst = new ArrayList<>();
				int opOneColLength = operandOneCol.length;
				int opTwoColLength = operandTwoCol.length;

				int conSatisfiedCount = 0;
				int yesCount = 0;
				int noCount = 0;

				mainloop: for (int linenum = startLine; linenum < lines.length; linenum++) {
					String[] colList = lines[linenum].trim().split(" " + "\\s+");
					Map col = new HashMap<>();
					Map yescol = new HashMap<>();
					int connum = 0;
					if (header) {
						for (int colnum = 0; colnum < colList.length; colnum++) {
							for (int valuenum = 0; valuenum < operandOneCol.length; valuenum++) {
								if (colList[colnum].trim().equalsIgnoreCase(operandOneCol[valuenum].trim())) {
									opndOnecolIndex.add(colnum);
									opOneColLength--;
								}
							}
							for (int valuenum = 0; valuenum < operandTwoCol.length; valuenum++) {
								if (colList[colnum].trim().equalsIgnoreCase(operandTwoCol[valuenum].trim())) {
									opndTwocolIndex.add(colnum);
									opTwoColLength--;
								}
							}

							if (operandOneCol.length == opndOnecolIndex.size()
									&& operandTwoCol.length == opndTwocolIndex.size()) {
								break;
							}

						}
						header = false;
						continue mainloop;

					}

					if (opOneColLength != 0 || opTwoColLength != 0) {
						outputResult = NO_DATA;
						break mainloop;
					}

					// got the header index use that to get the values
					Boolean conSatisfied = false;
					if (!colList[0].contains(DOUBLE_LINE) && !colList[0].contains(SINGLE_LINE)) {
						if (colList[0].contains(RESULT_OK)) {
							break mainloop;
						}

						for (int j = 0; j < opndOnecolIndex.size(); j++) {

							if (colList.length > j && colList[(int) opndOnecolIndex.get(j)].trim()
									.equalsIgnoreCase(operandOnevalueInput[connum].trim())) {
								conSatisfied = true;
							} else {
								conSatisfied = false;
								break;
							}
							connum++;
						}
					}

					if (conSatisfied) {
						int valuenum = 0;
						conSatisfiedCount++;
						List colIndex = new ArrayList<>();
						List yesColIndex = new ArrayList<>();
						int numOfCol = 0;
						int numofColYes = 0;
						int numofColNo = 0;
						for (int m = 0; m < opndTwocolIndex.size(); m++) {
							int outputValue = 0;
							int inputValue = 0;
							try {
								numOfCol++;
								outputValue = Integer.parseInt(colList[(int) opndTwocolIndex.get(m)].trim());
								inputValue = Integer.parseInt(operandTwovalueInput[valuenum].trim());

								if (outputValue != inputValue) {
									yesColIndex.add((int) opndTwocolIndex.get(m));
									yescol.put("index", linenum - (singlelinenum + 4));
									yescol.put("columnIndexes", yesColIndex);

									result = "YES";
									numofColYes++;
								} else {
									result = "NO";
									numofColNo++;
									colIndex.add((int) opndTwocolIndex.get(m));
									col.put("index", linenum - (singlelinenum + 4));
									col.put("columnIndexes", colIndex);

								}
							} catch (NumberFormatException e) {
								result = "NO";
								numofColNo++;
								colIndex.add((int) opndTwocolIndex.get(m));
								col.put("index", linenum - (singlelinenum + 4));
								col.put("columnIndexes", colIndex);
							}
							valuenum++;
							if ("YES".equalsIgnoreCase(result) && "atleastone".equalsIgnoreCase(loopType)) {
								finalResult = "YES";
								if (!col.isEmpty()) {
									rowLst.add(col);
									ruleResultJson.put("rows", rowLst);
								}

								if (!yescol.isEmpty()) {
									yesRowLst.add(yescol);
									yesRuleResultJson.put("rows", yesRowLst);
								}
								break mainloop;
							}
							if ("all".equalsIgnoreCase(loopType) && "NO".equalsIgnoreCase(result)) {
								finalResult = "NO";
							}

						}
						if (numofColYes != 0 && numOfCol != 0 && numOfCol == numofColYes) {
							yesCount++;
						}
						if (numofColNo != 0 && numOfCol != 0 && numOfCol == numofColNo) {
							noCount++;

						}
					}

					if (!col.isEmpty()) {
						rowLst.add(col);
						ruleResultJson.put("rows", rowLst);
					}
					if (!yescol.isEmpty()) {
						yesRowLst.add(yescol);
						yesRuleResultJson.put("rows", yesRowLst);
					}
				}
				if (conSatisfiedCount != 0 && conSatisfiedCount == yesCount) {
					finalResult = "YES";
				}
				if (conSatisfiedCount != 0 && conSatisfiedCount == noCount) {
					finalResult = "NO";
				}
				outputResult = getPassFail(cmdResult, finalResult);
				resultJson = getResultJson(cmdResult, outputResult, ruleResultJson, yesRuleResultJson);
			}

			if ("line".equalsIgnoreCase(format)) {
				int opOnecolLength = operandOneCol.length;
				int opTwocolLength = operandTwoCol.length;
				Boolean conSatisfied = false;
				List<String> opOnelist = Arrays.asList(operandOneCol);
				for (int linenum = startLine; linenum < lines.length; linenum++) {
					if (lines[linenum].trim().contains("=")) {
						String[] lineValue = lines[linenum].trim().split("=");
						String col = lineValue[0].trim();
						String value = lineValue[1].trim();
						if (opOnelist.contains(col)) {
							int colIndex = opOnelist.indexOf(col);
							if (value.equalsIgnoreCase(operandOnevalueInput[colIndex])) {
								conSatisfied = true;
							} else {
								conSatisfied = false;
								break;
							}
							opOnecolLength--;
							if (opOnecolLength == 0) {

								break;
							}

						}

					}

				}
				if (opOnecolLength != 0) {
					conSatisfied = false;
					outputResult = NO_DATA;
				} else if (opOnecolLength == 0 && conSatisfied) {
					List<String> opTwolist = Arrays.asList(operandTwoCol);
					for (int linenum = startLine; linenum < lines.length; linenum++) {
						if (lines[linenum].trim().contains("=")) {
							String[] lineValue = lines[linenum].trim().split("=");
							String col = lineValue[0].trim();
							try {
								int outputValue = Integer.parseInt(lineValue[1].trim());

								if (opTwolist.contains(col)) {
									int colIndex = opTwolist.indexOf(col);
									int inputValue = Integer.parseInt(operandTwovalueInput[colIndex]);

									if (outputValue != inputValue) {
										result = "YES";
									} else {
										result = "NO";
									}
									opTwocolLength--;
									if (opTwocolLength == 0) {
										break;
									}

								}
							} catch (NumberFormatException e) {
								result = "NO";
							}

						}
					}
				}
				if (opTwocolLength != 0) {
					outputResult = NO_DATA;
				}
				outputResult = getPassFail(cmdResult, result);
			}
			jsonResult.put("outputResult", outputResult);
			jsonResult.put("ruleResultJson", resultJson);

		} catch (Exception e) {

			logger.error("Exception RunTestServiceImpl in cliNotEql() " + ExceptionUtils.getFullStackTrace(e));
		}

		return jsonResult;
	}

	private JSONObject cliAny(String cliOutput, String opeCol1, String opeCol2, String operand1, String operand2,
			String cmdResult, String loopType) {
		String result = NO_DATA;
		String outputResult = NO_DATA;
		String finalResult = NO_DATA;

		String[] operandOneCol = opeCol1.trim().split(ruleDelimiter);
		String[] operandTwoCol = opeCol2.trim().split(ruleDelimiter);
		String[] operandOnevalueInput = operand1.trim().split(ruleDelimiter);
		String[] operandTwovalueInput = operand2.trim().split(ruleDelimiter);
		JSONObject jsonResult = new JSONObject();
		JSONObject ruleResultJson = new JSONObject();
		JSONObject resultJson = new JSONObject();
		JSONObject yesRuleResultJson = new JSONObject();
		List opndOnecolIndex = new ArrayList<>();
		List opndTwocolIndex = new ArrayList<>();

		try {
			String[] lines = cliOutput.split("\\r?\\n");
			boolean header = true;
			// looping lines
			String format = "";
			int startLine = 0;
			int singlelinenum = 0;
			for (; singlelinenum < lines.length; singlelinenum++) {
				if (lines[singlelinenum].contains(COMPLETE)) {
					if (lines[singlelinenum + 1].contains(DOUBLE_LINE)
							|| lines[singlelinenum + 1].contains(SINGLE_LINE)) {
						format = "table";
						startLine = singlelinenum + 2;
						break;
					} else {
						format = "line";
						startLine = singlelinenum + 1;
						break;
					}
				}
			}
			if ("table".equalsIgnoreCase(format)) {
				List rowLst = new ArrayList<>();
				List yesRowLst = new ArrayList<>();

				int opOneColLength = operandOneCol.length;
				int opTwoColLength = operandTwoCol.length;

				int conSatisfiedCount = 0;
				int yesCount = 0;
				int noCount = 0;
				mainloop: for (int linenum = startLine; linenum < lines.length; linenum++) {
					String[] colList = lines[linenum].trim().split(" " + "\\s+");
					Map col = new HashMap<>();
					Map yescol = new HashMap<>();

					int connum = 0;
					if (header) {
						for (int colnum = 0; colnum < colList.length; colnum++) {
							for (int valuenum = 0; valuenum < operandOneCol.length; valuenum++) {
								if (colList[colnum].trim().equalsIgnoreCase(operandOneCol[valuenum].trim())) {
									opndOnecolIndex.add(colnum);
									opOneColLength--;
								}
							}
							for (int valuenum = 0; valuenum < operandTwoCol.length; valuenum++) {
								if (colList[colnum].trim().equalsIgnoreCase(operandTwoCol[valuenum].trim())) {
									opndTwocolIndex.add(colnum);
									opTwoColLength--;
								}
							}

							if (operandOneCol.length == opndOnecolIndex.size()
									&& operandTwoCol.length == opndTwocolIndex.size()) {
								break;
							}

						}
						header = false;
						continue mainloop;

					}

					if (opOneColLength != 0 || opTwoColLength != 0) {
						outputResult = NO_DATA;
						break mainloop;
					}

					// got the header index use that to get the values
					Boolean conSatisfied = false;
					if (!colList[0].contains(DOUBLE_LINE) && !colList[0].contains(SINGLE_LINE)) {
						if (colList[0].contains(RESULT_OK)) {
							break mainloop;
						}

						for (int j = 0; j < opndOnecolIndex.size(); j++) {
							if (colList.length > j && colList[(int) opndOnecolIndex.get(j)].trim()
									.equalsIgnoreCase(operandOnevalueInput[connum].trim())) {
								conSatisfied = true;
							} else {
								conSatisfied = false;
								break;
							}
							connum++;
						}
					}

					if (conSatisfied) {
						int valuenum = 0;
						conSatisfiedCount++;
						List colIndex = new ArrayList<>();
						List yesColIndex = new ArrayList<>();
						int numOfCol = 0;
						int numofColYes = 0;
						int numofColNo = 0;
						for (int m = 0; m < opndTwocolIndex.size(); m++) {
							numOfCol++;
							String outputValue = colList[(int) opndTwocolIndex.get(m)].trim();
							String input = operandTwovalueInput[valuenum].trim();
							String[] inputValue = input.replaceAll("^\\s*\\[|\\]\\s*$", "").split("\\s*,\\s*");
							List<String> list = Arrays.asList(inputValue);

							if (list.contains(outputValue)) {

								yesColIndex.add((int) opndTwocolIndex.get(m));
								yescol.put("index", linenum - (singlelinenum + 4));
								yescol.put("columnIndexes", yesColIndex);

								result = "YES";
								numofColYes++;
							} else {
								result = "NO";
								numofColNo++;

								colIndex.add((int) opndTwocolIndex.get(m));
								col.put("index", linenum - (singlelinenum + 4));
								col.put("columnIndexes", colIndex);
							}
							valuenum++;
							if ("YES".equalsIgnoreCase(result) && "atleastone".equalsIgnoreCase(loopType)) {
								finalResult = "YES";
								if (!col.isEmpty()) {
									rowLst.add(col);
									ruleResultJson.put("rows", rowLst);
								}

								if (!yescol.isEmpty()) {
									yesRowLst.add(yescol);
									yesRuleResultJson.put("rows", yesRowLst);
								}
								break mainloop;
							}
							if ("all".equalsIgnoreCase(loopType) && "NO".equalsIgnoreCase(result)) {
								finalResult = "NO";
							}

						}
						if (numofColYes != 0 && numOfCol != 0 && numOfCol == numofColYes) {
							yesCount++;
						}
						if (numofColNo != 0 && numOfCol != 0 && numOfCol == numofColNo) {
							noCount++;

						}
					}

					if (!col.isEmpty()) {
						rowLst.add(col);
						ruleResultJson.put("rows", rowLst);
					}

					if (!yescol.isEmpty()) {
						yesRowLst.add(yescol);
						yesRuleResultJson.put("rows", yesRowLst);
					}
				}
				if (conSatisfiedCount != 0 && conSatisfiedCount == yesCount) {
					finalResult = "YES";
				}
				if (conSatisfiedCount != 0 && conSatisfiedCount == noCount) {
					finalResult = "NO";
				}

				outputResult = getPassFail(cmdResult, finalResult);

				resultJson = getResultJson(cmdResult, outputResult, ruleResultJson, yesRuleResultJson);

			}

			if ("line".equalsIgnoreCase(format)) {
				int opOnecolLength = operandOneCol.length;
				int opTwocolLength = operandTwoCol.length;
				Boolean conSatisfied = false;
				List<String> opOnelist = Arrays.asList(operandOneCol);
				for (int linenum = startLine; linenum < lines.length; linenum++) {
					if (lines[linenum].trim().contains("=")) {
						String[] lineValue = lines[linenum].trim().split("=");
						String col = lineValue[0].trim();
						String value = lineValue[1].trim();
						if (opOnelist.contains(col)) {
							int colIndex = opOnelist.indexOf(col);
							if (value.equalsIgnoreCase(operandOnevalueInput[colIndex])) {
								conSatisfied = true;
							} else {
								conSatisfied = false;
								break;
							}
							opOnecolLength--;
							if (opOnecolLength == 0) {

								break;
							}

						}

					}

				}
				if (opOnecolLength != 0) {
					conSatisfied = false;
					outputResult = NO_DATA;
				} else if (opOnecolLength == 0 && conSatisfied) {
					List<String> opTwolist = Arrays.asList(operandTwoCol);
					for (int linenum = startLine; linenum < lines.length; linenum++) {
						if (lines[linenum].trim().contains("=")) {
							String[] lineValue = lines[linenum].trim().split("=");
							String col = lineValue[0].trim();
							String outputValue = lineValue[1].trim();

							if (opTwolist.contains(col)) {
								int colIndex = opTwolist.indexOf(col);
								String inputValue = operandTwovalueInput[colIndex];

								if (outputValue.equalsIgnoreCase(inputValue)) {
									result = "YES";
								} else {
									result = "NO";
								}
								opTwocolLength--;
								if (opTwocolLength == 0) {
									break;
								}

							}

						}
					}
				}
				if (opTwocolLength != 0) {
					outputResult = NO_DATA;
				}
				outputResult = getPassFail(cmdResult, result);
			}

			jsonResult.put("outputResult", outputResult);
			jsonResult.put("ruleResultJson", resultJson);

		} catch (Exception e) {

			logger.error("Exception RunTestServiceImpl in cliContains() " + ExceptionUtils.getFullStackTrace(e));
		}

		return jsonResult;
	}

	private JSONObject cliContains(String cliOutput, String opeCol1, String opeCol2, String operand1, String operand2,
			String cmdResult, String loopType) {
		String result = NO_DATA;
		String outputResult = NO_DATA;
		String finalResult = NO_DATA;

		String[] operandOneCol = opeCol1.trim().split(ruleDelimiter);
		String[] operandTwoCol = opeCol2.trim().split(ruleDelimiter);
		String[] operandOnevalueInput = operand1.trim().split(ruleDelimiter);
		String[] operandTwovalueInput = operand2.trim().split(ruleDelimiter);
		JSONObject jsonResult = new JSONObject();
		JSONObject ruleResultJson = new JSONObject();
		JSONObject resultJson = new JSONObject();
		JSONObject yesRuleResultJson = new JSONObject();
		List opndOnecolIndex = new ArrayList<>();
		List opndTwocolIndex = new ArrayList<>();

		try {
			String[] lines = cliOutput.split("\\r?\\n");
			boolean header = true;
			// looping lines
			String format = "";
			int startLine = 0;
			int singlelinenum = 0;
			for (; singlelinenum < lines.length; singlelinenum++) {
				if (lines[singlelinenum].contains(COMPLETE)) {
					if (lines[singlelinenum + 1].contains(DOUBLE_LINE)
							|| lines[singlelinenum + 1].contains(SINGLE_LINE)) {
						format = "table";
						startLine = singlelinenum + 2;
						break;
					} else {
						format = "line";
						startLine = singlelinenum + 1;
						break;
					}
				}
			}
			if ("table".equalsIgnoreCase(format)) {
				List rowLst = new ArrayList<>();
				List yesRowLst = new ArrayList<>();

				int opOneColLength = operandOneCol.length;
				int opTwoColLength = operandTwoCol.length;

				int conSatisfiedCount = 0;
				int yesCount = 0;
				int noCount = 0;
				mainloop: for (int linenum = startLine; linenum < lines.length; linenum++) {
					String[] colList = lines[linenum].trim().split(" " + "\\s+");
					Map col = new HashMap<>();
					Map yescol = new HashMap<>();

					int connum = 0;
					if (header) {
						for (int colnum = 0; colnum < colList.length; colnum++) {
							for (int valuenum = 0; valuenum < operandOneCol.length; valuenum++) {
								if (colList[colnum].trim().equalsIgnoreCase(operandOneCol[valuenum].trim())) {
									opndOnecolIndex.add(colnum);
									opOneColLength--;
								}
							}
							for (int valuenum = 0; valuenum < operandTwoCol.length; valuenum++) {
								if (colList[colnum].trim().equalsIgnoreCase(operandTwoCol[valuenum].trim())) {
									opndTwocolIndex.add(colnum);
									opTwoColLength--;
								}
							}

							if (operandOneCol.length == opndOnecolIndex.size()
									&& operandTwoCol.length == opndTwocolIndex.size()) {
								break;
							}

						}
						header = false;
						continue mainloop;

					}

					if (opOneColLength != 0 || opTwoColLength != 0) {
						outputResult = NO_DATA;
						break mainloop;
					}

					// got the header index use that to get the values
					Boolean conSatisfied = false;
					if (!colList[0].contains(DOUBLE_LINE) && !colList[0].contains(SINGLE_LINE)) {
						if (colList[0].contains(RESULT_OK)) {
							break mainloop;
						}

						for (int j = 0; j < opndOnecolIndex.size(); j++) {
							if (colList.length > j && colList[(int) opndOnecolIndex.get(j)].trim()
									.equalsIgnoreCase(operandOnevalueInput[connum].trim())) {
								conSatisfied = true;
							} else {
								conSatisfied = false;
								break;
							}
							connum++;
						}
					}

					if (conSatisfied) {
						int valuenum = 0;
						conSatisfiedCount++;
						List colIndex = new ArrayList<>();
						List yesColIndex = new ArrayList<>();
						int numOfCol = 0;
						int numofColYes = 0;
						int numofColNo = 0;
						for (int m = 0; m < opndTwocolIndex.size(); m++) {
							numOfCol++;
							String outputValue = colList[(int) opndTwocolIndex.get(m)].trim();
							String inputValue = operandTwovalueInput[valuenum].trim();

							if (outputValue.equalsIgnoreCase(inputValue)) {

								yesColIndex.add((int) opndTwocolIndex.get(m));
								yescol.put("index", linenum - (singlelinenum + 4));
								yescol.put("columnIndexes", yesColIndex);

								result = "YES";
								numofColYes++;
							} else {
								result = "NO";
								numofColNo++;

								colIndex.add((int) opndTwocolIndex.get(m));
								col.put("index", linenum - (singlelinenum + 4));
								col.put("columnIndexes", colIndex);
							}
							valuenum++;
							if ("YES".equalsIgnoreCase(result) && "atleastone".equalsIgnoreCase(loopType)) {
								finalResult = "YES";
								if (!col.isEmpty()) {
									rowLst.add(col);
									ruleResultJson.put("rows", rowLst);
								}

								if (!yescol.isEmpty()) {
									yesRowLst.add(yescol);
									yesRuleResultJson.put("rows", yesRowLst);
								}
								break mainloop;
							}
							if ("all".equalsIgnoreCase(loopType) && "NO".equalsIgnoreCase(result)) {
								finalResult = "NO";
							}

						}
						if (numofColYes != 0 && numOfCol != 0 && numOfCol == numofColYes) {
							yesCount++;
						}
						if (numofColNo != 0 && numOfCol != 0 && numOfCol == numofColNo) {
							noCount++;

						}
					}

					if (!col.isEmpty()) {
						rowLst.add(col);
						ruleResultJson.put("rows", rowLst);
					}

					if (!yescol.isEmpty()) {
						yesRowLst.add(yescol);
						yesRuleResultJson.put("rows", yesRowLst);
					}
				}
				if (conSatisfiedCount != 0 && conSatisfiedCount == yesCount) {
					finalResult = "YES";
				}
				if (conSatisfiedCount != 0 && conSatisfiedCount == noCount) {
					finalResult = "NO";
				}

				outputResult = getPassFail(cmdResult, finalResult);

				resultJson = getResultJson(cmdResult, outputResult, ruleResultJson, yesRuleResultJson);

			}

			if ("line".equalsIgnoreCase(format)) {
				int opOnecolLength = operandOneCol.length;
				int opTwocolLength = operandTwoCol.length;
				Boolean conSatisfied = false;
				List<String> opOnelist = Arrays.asList(operandOneCol);
				for (int linenum = startLine; linenum < lines.length; linenum++) {
					if (lines[linenum].trim().contains("=")) {
						String[] lineValue = lines[linenum].trim().split("=");
						String col = lineValue[0].trim();
						String value = lineValue[1].trim();
						if (opOnelist.contains(col)) {
							int colIndex = opOnelist.indexOf(col);
							if (value.equalsIgnoreCase(operandOnevalueInput[colIndex])) {
								conSatisfied = true;
							} else {
								conSatisfied = false;
								break;
							}
							opOnecolLength--;
							if (opOnecolLength == 0) {

								break;
							}

						}

					}

				}
				if (opOnecolLength != 0) {
					conSatisfied = false;
					outputResult = NO_DATA;
				} else if (opOnecolLength == 0 && conSatisfied) {
					List<String> opTwolist = Arrays.asList(operandTwoCol);
					for (int linenum = startLine; linenum < lines.length; linenum++) {
						if (lines[linenum].trim().contains("=")) {
							String[] lineValue = lines[linenum].trim().split("=");
							String col = lineValue[0].trim();
							String outputValue = lineValue[1].trim();

							if (opTwolist.contains(col)) {
								int colIndex = opTwolist.indexOf(col);
								String inputValue = operandTwovalueInput[colIndex];

								if (outputValue.equalsIgnoreCase(inputValue)) {
									result = "YES";
								} else {
									result = "NO";
								}
								opTwocolLength--;
								if (opTwocolLength == 0) {
									break;
								}

							}

						}
					}
				}
				if (opTwocolLength != 0) {
					outputResult = NO_DATA;
				}
				outputResult = getPassFail(cmdResult, result);
			}

			jsonResult.put("outputResult", outputResult);
			jsonResult.put("ruleResultJson", resultJson);

		} catch (Exception e) {

			logger.error("Exception RunTestServiceImpl in cliContains() " + ExceptionUtils.getFullStackTrace(e));
		}

		return jsonResult;
	}

	private JSONObject getResultJson(String cmdResult, String outputResult, JSONObject ruleResultJson,
			JSONObject yesRuleResultJson) {

		if ("Pass".equalsIgnoreCase(cmdResult) && "Pass".equalsIgnoreCase(outputResult)) {

			return yesRuleResultJson;
		}
		if ("Pass".equalsIgnoreCase(cmdResult) && "fail".equalsIgnoreCase(outputResult)) {

			return ruleResultJson;
		}
		if ("fail".equalsIgnoreCase(cmdResult) && "fail".equalsIgnoreCase(outputResult)) {

			return yesRuleResultJson;
		}
		if ("fail".equalsIgnoreCase(cmdResult) && "Pass".equalsIgnoreCase(outputResult)) {
			return ruleResultJson;

		}
		if ("warn".equalsIgnoreCase(cmdResult) && "Pass".equalsIgnoreCase(outputResult)) {
			return ruleResultJson;
		}
		if ("warn".equalsIgnoreCase(cmdResult) && "warn".equalsIgnoreCase(outputResult)) {
			return yesRuleResultJson;
		}
		return ruleResultJson;
	}

	private String getPassFail(String cmdResult, String result) {

		String output = "FAIL";

		if ("PASS".equalsIgnoreCase(cmdResult)) {
			if ("YES".equalsIgnoreCase(result)) {
				output = "PASS";
			} else if (NO_DATA.equalsIgnoreCase(result)) {
				output = NO_DATA;
			} else {
				output = "FAIL";
			}

		}
		if ("FAIL".equalsIgnoreCase(cmdResult)) {
			if ("YES".equalsIgnoreCase(result)) {
				output = "FAIL";
			} else if (NO_DATA.equalsIgnoreCase(result)) {
				output = NO_DATA;
			} else {
				output = "PASS";
			}

		}
		if ("WARN".equalsIgnoreCase(cmdResult)) {
			if ("YES".equalsIgnoreCase(result)) {
				output = "WARN";
			} else if (NO_DATA.equalsIgnoreCase(result)) {
				output = NO_DATA;
			} else {
				output = "PASS";
			}

		}

		return output;
	}

	private String shellEql(String shellOutput, ShellCmdRuleBuilderEntity shellRule) {

		String result = NO_DATA;
		String outputResult = NO_DATA;
		String finalResult = NO_DATA;
		String opeCol1 = shellRule.getOperand1ColumnNames();
		String opeCol2 = shellRule.getOperand2ColumnNames();
		String operand1 = shellRule.getOperand1Values();
		String operand2 = shellRule.getOperand2Values();
		String cmdResult = shellRule.getStatus();
		String loopType = shellRule.getLoopType();
		String cmdName = shellRule.getCmdName();
		String[] operandOneCol = opeCol1.trim().split(ruleDelimiter);
		String[] operandTwoCol = opeCol2.trim().split(ruleDelimiter);
		String[] operandOnevalueInput = operand1.trim().split(ruleDelimiter);
		String[] operandTwovalueInput = operand2.trim().split(ruleDelimiter);
		List<ShellCommandEntity> shellCmdDetails = runTestRepository.getShellCommandDetails(cmdName);
		List opndOnecolIndex = new ArrayList<>();
		List opndTwocolIndex = new ArrayList<>();

		try {
			String[] lines = shellOutput.split("\\r?\\n");
			boolean header = true;
			// looping lines
			int startLine = 1;
			Map colDetailsMap = new TreeMap<>();
			int opOneColLength = operandOneCol.length;
			int opTwoColLength = operandTwoCol.length;
			int conSatisfiedCount = 0;
			int yesCount = 0;
			int noCount = 0;
			mainloop: for (int linenum = startLine; linenum < lines.length; linenum++) {
				String[] colList = new String[shellCmdDetails.size()];
				int connum = 0;
				String line = lines[linenum];
				if (line.isEmpty()) {
					continue mainloop;
				}
				int startString = 0;
				if (header) {
					for (int i = 0; i < shellCmdDetails.size(); i++) {
						int[] leftStartEndIndex = new int[2];
						int[] rightStartEndIndex = new int[2];
						List mapList = new ArrayList<>();

						ShellCommandEntity shellCommandEntity = shellCmdDetails.get(i);
						String columnName = shellCommandEntity.getColumnName().trim();

						int leftStartPoint = line.indexOf(columnName, startString);
						int leftendPoint = 0;
						if (i < shellCmdDetails.size() - 1) {
							leftendPoint = line.indexOf(shellCmdDetails.get(i + 1).getColumnName(), startString);
						} else {
							leftendPoint = Integer.MAX_VALUE;
						}
						leftStartEndIndex[0] = leftStartPoint;
						leftStartEndIndex[1] = leftendPoint;

						int rightStartPoint = 0;
						if (i == 0) {
							rightStartPoint = 0;
						} else {
							rightStartPoint = line.indexOf(shellCmdDetails.get(i - 1).getColumnName())
									+ shellCmdDetails.get(i - 1).getColumnName().length();
						}
						int rightendPoint = line.indexOf(columnName, startString) + columnName.length();
						rightStartEndIndex[0] = rightStartPoint;
						rightStartEndIndex[1] = rightendPoint;

						startString = line.indexOf(columnName, startString) + columnName.length();
						mapList.add(columnName);
						mapList.add(rightStartEndIndex);
						mapList.add(leftStartEndIndex);
						mapList.add(shellCommandEntity.getAlignment());
						colDetailsMap.put(i, mapList);
					}
				}

				Set set = colDetailsMap.entrySet();
				Iterator it = set.iterator();
				int count = 0;
				int maxCount = set.size();
				while (it.hasNext()) {
					Map.Entry me = (Map.Entry) it.next();

					List opeOne = (List) me.getValue();
					String align = (String) opeOne.get(3);
					if ("left".equalsIgnoreCase(align)) {
						String val = "";
						int[] left = (int[]) opeOne.get(2);
						if (left[0] <= line.length() && left[1] == Integer.MAX_VALUE) {
							val = line.substring(left[0], line.length());
						} else {
							if (left[1] <= line.length()) {
								val = line.substring(left[0], left[1]);
							}
						}
						if (val.contains(" ") && count + 1 != maxCount) {
							val = val.substring(0, val.indexOf(' '));
						}
						colList[count] = val;
					} else if ("right".equalsIgnoreCase(align)) {
						int[] right = (int[]) opeOne.get(1);
						String val = "";
						if (right[1] <= line.length()) {
							val = line.substring(right[0], right[1]);
						}
						if (val.contains(" ")) {
							val = val.substring(val.lastIndexOf(' '), val.length());
						}
						colList[count] = val;
					}
					count++;

				}
				if (header) {
					for (int colnum = 0; colnum < colList.length; colnum++) {
						for (int valuenum = 0; valuenum < operandOneCol.length; valuenum++) {
							if (colList[colnum].trim().equalsIgnoreCase(operandOneCol[valuenum].trim())) {
								opndOnecolIndex.add(colnum);
								opOneColLength--;
							}
						}
						for (int valuenum = 0; valuenum < operandTwoCol.length; valuenum++) {
							if (colList[colnum].trim().equalsIgnoreCase(operandTwoCol[valuenum].trim())) {
								opndTwocolIndex.add(colnum);
								opTwoColLength--;
							}
						}
						if (operandOneCol.length == opndOnecolIndex.size()
								&& operandTwoCol.length == opndTwocolIndex.size()) {
							break;
						}
					}
					header = false;
					continue mainloop;
				}

				// got the header index use that to get the values
				Boolean conSatisfied = false;
				if (!colList[0].contains(DOUBLE_LINE) && !colList[0].contains(SINGLE_LINE)) {
					if (colList[0].contains(RESULT_OK)) {
						break mainloop;
					}
					for (int j = 0; j < opndOnecolIndex.size(); j++) {
						if (colList.length > j && colList[(int) opndOnecolIndex.get(j)].trim()
								.equalsIgnoreCase(operandOnevalueInput[connum].trim())) {
							conSatisfied = true;
						} else {
							conSatisfied = false;
							break;
						}
						connum++;
					}
				}
				if (conSatisfied) {
					int valuenum = 0;
					conSatisfiedCount++;
					int numofColYes = 0;
					int numofColNo = 0;
					int numOfCol = 0;
					for (int m = 0; m < opndTwocolIndex.size(); m++) {
						try {
							numOfCol++;
							int outputValue = Integer.parseInt(colList[(int) opndTwocolIndex.get(m)].trim());
							int inputValue = Integer.parseInt(operandTwovalueInput[valuenum].trim());

							if (outputValue == inputValue) {
								result = "YES";
								numofColYes++;
							} else {
								result = "NO";
								numofColNo++;
							}
						} catch (NumberFormatException e) {
							result = "NO";
							numofColNo++;
						}
						valuenum++;
						if ("YES".equalsIgnoreCase(result) && "atleastone".equalsIgnoreCase(loopType)) {
							finalResult = "YES";
							break mainloop;
						}
						if ("all".equalsIgnoreCase(loopType) && "NO".equalsIgnoreCase(result)) {
							finalResult = "NO";
						}
					}
					if ("YES".equalsIgnoreCase(result) && "atleastone".equalsIgnoreCase(loopType) && numofColYes != 0
							&& numOfCol != 0 && numOfCol == numofColYes) {
						finalResult = "YES";
						break mainloop;
					}
					if (numofColYes != 0 && numOfCol != 0 && numOfCol == numofColYes) {
						yesCount++;

					}
					if (numofColNo != 0 && numOfCol != 0 && numOfCol == numofColNo) {
						noCount++;

					}
				}

			}

			if (conSatisfiedCount != 0 && conSatisfiedCount == yesCount) {
				finalResult = "YES";
			}
			if (conSatisfiedCount != 0 && conSatisfiedCount == noCount) {
				finalResult = "NO";
			}

			outputResult = getPassFail(cmdResult, finalResult);

		} catch (

		Exception e) {

			logger.error("Exception RunTestServiceImpl in shellEql() " + ExceptionUtils.getFullStackTrace(e));
		}

		return outputResult;

	}

	private String shellNotEql(String shellOutput, ShellCmdRuleBuilderEntity shellRule) {

		String result = NO_DATA;
		String outputResult = NO_DATA;
		String finalResult = NO_DATA;
		String opeCol1 = shellRule.getOperand1ColumnNames();
		String opeCol2 = shellRule.getOperand2ColumnNames();
		String operand1 = shellRule.getOperand1Values();
		String operand2 = shellRule.getOperand2Values();
		String cmdResult = shellRule.getStatus();
		String loopType = shellRule.getLoopType();
		String cmdName = shellRule.getCmdName();
		String[] operandOneCol = opeCol1.trim().split(ruleDelimiter);
		String[] operandTwoCol = opeCol2.trim().split(ruleDelimiter);
		String[] operandOnevalueInput = operand1.trim().split(ruleDelimiter);
		String[] operandTwovalueInput = operand2.trim().split(ruleDelimiter);
		List<ShellCommandEntity> shellCmdDetails = runTestRepository.getShellCommandDetails(cmdName);
		List opndOnecolIndex = new ArrayList<>();
		List opndTwocolIndex = new ArrayList<>();

		try {
			String[] lines = shellOutput.split("\\r?\\n");
			boolean header = true;
			// looping lines
			int startLine = 1;
			Map colDetailsMap = new TreeMap<>();
			int opOneColLength = operandOneCol.length;
			int opTwoColLength = operandTwoCol.length;
			int conSatisfiedCount = 0;
			int yesCount = 0;
			int noCount = 0;
			mainloop: for (int linenum = startLine; linenum < lines.length; linenum++) {
				String[] colList = new String[shellCmdDetails.size()];
				int connum = 0;
				String line = lines[linenum];
				if (line.isEmpty()) {
					continue mainloop;
				}
				int startString = 0;
				if (header) {
					for (int i = 0; i < shellCmdDetails.size(); i++) {
						int[] leftStartEndIndex = new int[2];
						int[] rightStartEndIndex = new int[2];
						List mapList = new ArrayList<>();

						ShellCommandEntity shellCommandEntity = shellCmdDetails.get(i);
						String columnName = shellCommandEntity.getColumnName().trim();

						int leftStartPoint = line.indexOf(columnName, startString);

						int leftendPoint = 0;
						if (i < shellCmdDetails.size() - 1) {
							leftendPoint = line.indexOf(shellCmdDetails.get(i + 1).getColumnName(), startString);
						} else {
							leftendPoint = Integer.MAX_VALUE;
						}
						leftStartEndIndex[0] = leftStartPoint;
						leftStartEndIndex[1] = leftendPoint;

						int rightStartPoint = 0;
						if (i == 0) {
							rightStartPoint = 0;
						} else {
							rightStartPoint = line.indexOf(shellCmdDetails.get(i - 1).getColumnName())
									+ shellCmdDetails.get(i - 1).getColumnName().length();
						}
						int rightendPoint = line.indexOf(columnName, startString) + columnName.length();
						rightStartEndIndex[0] = rightStartPoint;
						rightStartEndIndex[1] = rightendPoint;
						startString = line.indexOf(columnName, startString) + columnName.length();
						mapList.add(columnName);
						mapList.add(rightStartEndIndex);
						mapList.add(leftStartEndIndex);
						mapList.add(shellCommandEntity.getAlignment());
						colDetailsMap.put(i, mapList);
					}
				}

				Set set = colDetailsMap.entrySet();
				Iterator it = set.iterator();
				int count = 0;
				int maxCount = set.size();
				while (it.hasNext()) {
					Map.Entry me = (Map.Entry) it.next();

					List opeOne = (List) me.getValue();
					String align = (String) opeOne.get(3);
					if ("left".equalsIgnoreCase(align)) {
						String val = "";
						int[] left = (int[]) opeOne.get(2);
						if (left[0] <= line.length() && left[1] == Integer.MAX_VALUE) {
							val = line.substring(left[0], line.length());
						} else {
							if (left[1] <= line.length()) {
								val = line.substring(left[0], left[1]);
							}
						}
						if (val.contains(" ") && count + 1 != maxCount) {
							val = val.substring(0, val.indexOf(' '));
						}
						colList[count] = val;
					} else if ("right".equalsIgnoreCase(align)) {
						int[] right = (int[]) opeOne.get(1);
						String val = "";
						if (right[1] <= line.length()) {
							val = line.substring(right[0], right[1]);
						}
						if (val.contains(" ")) {
							val = val.substring(val.lastIndexOf(' '), val.length());
						}
						colList[count] = val;
					}
					count++;

				}
				if (header) {
					for (int colnum = 0; colnum < colList.length; colnum++) {
						for (int valuenum = 0; valuenum < operandOneCol.length; valuenum++) {
							if (colList[colnum].trim().equalsIgnoreCase(operandOneCol[valuenum].trim())) {
								opndOnecolIndex.add(colnum);
								opOneColLength--;
							}
						}
						for (int valuenum = 0; valuenum < operandTwoCol.length; valuenum++) {
							if (colList[colnum].trim().equalsIgnoreCase(operandTwoCol[valuenum].trim())) {
								opndTwocolIndex.add(colnum);
								opTwoColLength--;
							}
						}
						if (operandOneCol.length == opndOnecolIndex.size()
								&& operandTwoCol.length == opndTwocolIndex.size()) {
							break;
						}
					}
					header = false;
					continue mainloop;
				}

				// got the header index use that to get the values
				Boolean conSatisfied = false;
				if (!colList[0].contains(DOUBLE_LINE) && !colList[0].contains(SINGLE_LINE)) {
					if (colList[0].contains(RESULT_OK)) {
						break mainloop;
					}
					for (int j = 0; j < opndOnecolIndex.size(); j++) {
						if (colList.length > j && colList[(int) opndOnecolIndex.get(j)].trim()
								.equalsIgnoreCase(operandOnevalueInput[connum].trim())) {
							conSatisfied = true;
						} else {
							conSatisfied = false;
							break;
						}
						connum++;
					}
				}
				if (conSatisfied) {
					int valuenum = 0;
					conSatisfiedCount++;
					int numofColYes = 0;
					int numofColNo = 0;
					int numOfCol = 0;
					for (int m = 0; m < opndTwocolIndex.size(); m++) {
						try {
							numOfCol++;
							int outputValue = Integer.parseInt(colList[(int) opndTwocolIndex.get(m)].trim());
							int inputValue = Integer.parseInt(operandTwovalueInput[valuenum].trim());

							if (outputValue != inputValue) {
								result = "YES";
								numofColYes++;
							} else {
								result = "NO";
								numofColNo++;
							}
						} catch (NumberFormatException e) {
							result = "NO";
							numofColNo++;
						}
						valuenum++;
						if ("YES".equalsIgnoreCase(result) && "atleastone".equalsIgnoreCase(loopType)) {
							finalResult = "YES";
							break mainloop;
						}
						if ("all".equalsIgnoreCase(loopType) && "NO".equalsIgnoreCase(result)) {
							finalResult = "NO";
						}
					}
					if ("YES".equalsIgnoreCase(result) && "atleastone".equalsIgnoreCase(loopType) && numofColYes != 0
							&& numOfCol != 0 && numOfCol == numofColYes) {
						finalResult = "YES";
						break mainloop;
					}
					if (numofColYes != 0 && numOfCol != 0 && numOfCol == numofColYes) {
						yesCount++;
					}

					if (numofColNo != 0 && numOfCol != 0 && numOfCol == numofColNo) {
						noCount++;
					}
				}

			}

			if (conSatisfiedCount != 0 && conSatisfiedCount == yesCount) {
				finalResult = "YES";
			}
			if (conSatisfiedCount != 0 && conSatisfiedCount == noCount) {
				finalResult = "NO";
			}

			outputResult = getPassFail(cmdResult, finalResult);

		} catch (

		Exception e) {

			logger.error("Exception RunTestServiceImpl in shellNotEql() " + ExceptionUtils.getFullStackTrace(e));
		}

		return outputResult;

	}

	private String shellLess(String shellOutput, ShellCmdRuleBuilderEntity shellRule) {

		String result = NO_DATA;
		String outputResult = NO_DATA;
		String finalResult = NO_DATA;
		String opeCol1 = shellRule.getOperand1ColumnNames();
		String opeCol2 = shellRule.getOperand2ColumnNames();
		String operand1 = shellRule.getOperand1Values();
		String operand2 = shellRule.getOperand2Values();
		String cmdResult = shellRule.getStatus();
		String loopType = shellRule.getLoopType();
		String cmdName = shellRule.getCmdName();
		String[] operandOneCol = opeCol1.trim().split(ruleDelimiter);
		String[] operandTwoCol = opeCol2.trim().split(ruleDelimiter);
		String[] operandOnevalueInput = operand1.trim().split(ruleDelimiter);
		String[] operandTwovalueInput = operand2.trim().split(ruleDelimiter);
		List<ShellCommandEntity> shellCmdDetails = runTestRepository.getShellCommandDetails(cmdName);
		List opndOnecolIndex = new ArrayList<>();
		List opndTwocolIndex = new ArrayList<>();

		try {
			String[] lines = shellOutput.split("\\r?\\n");
			boolean header = true;
			// looping lines
			int startLine = 1;
			Map colDetailsMap = new TreeMap<>();
			int opOneColLength = operandOneCol.length;
			int opTwoColLength = operandTwoCol.length;
			int conSatisfiedCount = 0;
			int yesCount = 0;
			int noCount = 0;
			mainloop: for (int linenum = startLine; linenum < lines.length; linenum++) {
				String[] colList = new String[shellCmdDetails.size()];
				int connum = 0;
				String line = lines[linenum];
				if (line.isEmpty()) {
					continue mainloop;
				}
				int startString = 0;
				if (header) {
					for (int i = 0; i < shellCmdDetails.size(); i++) {
						int[] leftStartEndIndex = new int[2];
						int[] rightStartEndIndex = new int[2];
						List mapList = new ArrayList<>();

						ShellCommandEntity shellCommandEntity = shellCmdDetails.get(i);
						String columnName = shellCommandEntity.getColumnName().trim();

						int leftStartPoint = line.indexOf(columnName, startString);
						int leftendPoint = 0;
						if (i < shellCmdDetails.size() - 1) {
							leftendPoint = line.indexOf(shellCmdDetails.get(i + 1).getColumnName(), startString);
						} else {
							leftendPoint = Integer.MAX_VALUE;
						}
						leftStartEndIndex[0] = leftStartPoint;
						leftStartEndIndex[1] = leftendPoint;

						int rightStartPoint = 0;
						if (i == 0) {
							rightStartPoint = 0;
						} else {
							rightStartPoint = line.indexOf(shellCmdDetails.get(i - 1).getColumnName())
									+ shellCmdDetails.get(i - 1).getColumnName().length();
						}
						int rightendPoint = line.indexOf(columnName, startString) + columnName.length();
						rightStartEndIndex[0] = rightStartPoint;
						rightStartEndIndex[1] = rightendPoint;
						startString = line.indexOf(columnName, startString) + columnName.length();

						mapList.add(columnName);
						mapList.add(rightStartEndIndex);
						mapList.add(leftStartEndIndex);
						mapList.add(shellCommandEntity.getAlignment());
						colDetailsMap.put(i, mapList);
					}
				}

				Set set = colDetailsMap.entrySet();
				Iterator it = set.iterator();
				int count = 0;
				int maxCount = set.size();
				while (it.hasNext()) {
					Map.Entry me = (Map.Entry) it.next();

					List opeOne = (List) me.getValue();
					String align = (String) opeOne.get(3);
					if ("left".equalsIgnoreCase(align)) {
						String val = "";
						int[] left = (int[]) opeOne.get(2);
						if (left[0] <= line.length() && left[1] == Integer.MAX_VALUE) {
							val = line.substring(left[0], line.length());
						} else {
							if (left[1] <= line.length()) {
								val = line.substring(left[0], left[1]);
							}
						}
						if (val.contains(" ") && count + 1 != maxCount) {
							val = val.substring(0, val.indexOf(' '));
						}
						colList[count] = val;
					} else if ("right".equalsIgnoreCase(align)) {
						int[] right = (int[]) opeOne.get(1);
						String val = "";
						if (right[1] <= line.length()) {

							val = line.substring(right[0], right[1]);
						}
						if (val.contains(" ")) {
							val = val.substring(val.lastIndexOf(' '), val.length());
						}
						colList[count] = val;
					}
					count++;

				}
				if (header) {
					for (int colnum = 0; colnum < colList.length; colnum++) {
						for (int valuenum = 0; valuenum < operandOneCol.length; valuenum++) {
							if (colList[colnum].trim().equalsIgnoreCase(operandOneCol[valuenum].trim())) {
								opndOnecolIndex.add(colnum);
								opOneColLength--;
							}
						}
						for (int valuenum = 0; valuenum < operandTwoCol.length; valuenum++) {
							if (colList[colnum].trim().equalsIgnoreCase(operandTwoCol[valuenum].trim())) {
								opndTwocolIndex.add(colnum);
								opTwoColLength--;
							}
						}
						if (operandOneCol.length == opndOnecolIndex.size()
								&& operandTwoCol.length == opndTwocolIndex.size()) {
							break;
						}
					}
					header = false;
					continue mainloop;
				}

				// got the header index use that to get the values
				Boolean conSatisfied = false;
				if (!colList[0].contains(DOUBLE_LINE) && !colList[0].contains(SINGLE_LINE)) {
					if (colList[0].contains(RESULT_OK)) {
						break mainloop;
					}
					for (int j = 0; j < opndOnecolIndex.size(); j++) {
						if (colList.length > j && colList[(int) opndOnecolIndex.get(j)].trim()
								.equalsIgnoreCase(operandOnevalueInput[connum].trim())) {
							conSatisfied = true;
						} else {
							conSatisfied = false;
							break;
						}
						connum++;
					}
				}
				if (conSatisfied) {
					int valuenum = 0;
					conSatisfiedCount++;
					int numofColYes = 0;
					int numofColNo = 0;
					int numOfCol = 0;
					for (int m = 0; m < opndTwocolIndex.size(); m++) {
						try {
							numOfCol++;
							int outputValue = Integer.parseInt(colList[(int) opndTwocolIndex.get(m)].trim());
							int inputValue = Integer.parseInt(operandTwovalueInput[valuenum].trim());

							if (outputValue < inputValue) {
								result = "YES";
								numofColYes++;
							} else {
								result = "NO";
								numofColNo++;
							}
						} catch (NumberFormatException e) {
							result = "NO";
							numofColNo++;
						}
						valuenum++;
						if ("YES".equalsIgnoreCase(result) && "atleastone".equalsIgnoreCase(loopType)) {
							finalResult = "YES";
							break mainloop;
						}
						if ("all".equalsIgnoreCase(loopType) && "NO".equalsIgnoreCase(result)) {
							finalResult = "NO";
						}
					}
					if ("YES".equalsIgnoreCase(result) && "atleastone".equalsIgnoreCase(loopType) && numofColYes != 0
							&& numOfCol != 0 && numOfCol == numofColYes) {
						finalResult = "YES";
						break mainloop;
					}
					if (numofColYes != 0 && numOfCol != 0 && numOfCol == numofColYes) {
						yesCount++;

					}
					if (numofColNo != 0 && numOfCol != 0 && numOfCol == numofColNo) {
						noCount++;

					}

				}

			}

			if (conSatisfiedCount != 0 && conSatisfiedCount == yesCount) {
				finalResult = "YES";
			}
			if (conSatisfiedCount != 0 && conSatisfiedCount == noCount) {
				finalResult = "NO";
			}

			outputResult = getPassFail(cmdResult, finalResult);

		} catch (

		Exception e) {

			logger.error("Exception RunTestServiceImpl in shellLess() " + ExceptionUtils.getFullStackTrace(e));
		}

		return outputResult;

	}

	private String shellLessEql(String shellOutput, ShellCmdRuleBuilderEntity shellRule) {

		String result = NO_DATA;
		String outputResult = NO_DATA;
		String finalResult = NO_DATA;
		String opeCol1 = shellRule.getOperand1ColumnNames();
		String opeCol2 = shellRule.getOperand2ColumnNames();
		String operand1 = shellRule.getOperand1Values();
		String operand2 = shellRule.getOperand2Values();
		String cmdResult = shellRule.getStatus();
		String loopType = shellRule.getLoopType();
		String cmdName = shellRule.getCmdName();
		String[] operandOneCol = opeCol1.trim().split(ruleDelimiter);
		String[] operandTwoCol = opeCol2.trim().split(ruleDelimiter);
		String[] operandOnevalueInput = operand1.trim().split(ruleDelimiter);
		String[] operandTwovalueInput = operand2.trim().split(ruleDelimiter);
		List<ShellCommandEntity> shellCmdDetails = runTestRepository.getShellCommandDetails(cmdName);
		List opndOnecolIndex = new ArrayList<>();
		List opndTwocolIndex = new ArrayList<>();

		try {
			String[] lines = shellOutput.split("\\r?\\n");
			boolean header = true;
			// looping lines
			int startLine = 1;
			Map colDetailsMap = new TreeMap<>();
			int opOneColLength = operandOneCol.length;
			int opTwoColLength = operandTwoCol.length;
			int conSatisfiedCount = 0;
			int yesCount = 0;
			int noCount = 0;
			mainloop: for (int linenum = startLine; linenum < lines.length; linenum++) {
				String[] colList = new String[shellCmdDetails.size()];
				int connum = 0;
				String line = lines[linenum];
				if (line.isEmpty()) {
					continue mainloop;
				}
				int startString = 0;
				if (header) {
					for (int i = 0; i < shellCmdDetails.size(); i++) {
						int[] leftStartEndIndex = new int[2];
						int[] rightStartEndIndex = new int[2];
						List mapList = new ArrayList<>();

						ShellCommandEntity shellCommandEntity = shellCmdDetails.get(i);
						String columnName = shellCommandEntity.getColumnName().trim();

						int leftStartPoint = line.indexOf(columnName, startString);
						int leftendPoint = 0;
						if (i < shellCmdDetails.size() - 1) {
							leftendPoint = line.indexOf(shellCmdDetails.get(i + 1).getColumnName(), startString);
						} else {
							leftendPoint = Integer.MAX_VALUE;
						}
						leftStartEndIndex[0] = leftStartPoint;
						leftStartEndIndex[1] = leftendPoint;

						int rightStartPoint = 0;
						if (i == 0) {
							rightStartPoint = 0;
						} else {
							rightStartPoint = line.indexOf(shellCmdDetails.get(i - 1).getColumnName())
									+ shellCmdDetails.get(i - 1).getColumnName().length();
						}
						int rightendPoint = line.indexOf(columnName, startString) + columnName.length();
						rightStartEndIndex[0] = rightStartPoint;
						rightStartEndIndex[1] = rightendPoint;

						startString = line.indexOf(columnName, startString) + columnName.length();
						mapList.add(columnName);
						mapList.add(rightStartEndIndex);
						mapList.add(leftStartEndIndex);
						mapList.add(shellCommandEntity.getAlignment());
						colDetailsMap.put(i, mapList);
					}
				}

				Set set = colDetailsMap.entrySet();
				Iterator it = set.iterator();
				int count = 0;
				int maxCount = set.size();
				while (it.hasNext()) {
					Map.Entry me = (Map.Entry) it.next();

					List opeOne = (List) me.getValue();
					String align = (String) opeOne.get(3);
					if ("left".equalsIgnoreCase(align)) {
						String val = "";
						int[] left = (int[]) opeOne.get(2);
						if (left[0] <= line.length() && left[1] == Integer.MAX_VALUE) {
							val = line.substring(left[0], line.length());
						} else {
							if (left[1] <= line.length()) {
								val = line.substring(left[0], left[1]);
							}
						}
						if (val.contains(" ") && count + 1 != maxCount) {
							val = val.substring(0, val.indexOf(' '));
						}
						colList[count] = val;
					} else if ("right".equalsIgnoreCase(align)) {
						int[] right = (int[]) opeOne.get(1);
						String val = "";
						if (right[1] <= line.length()) {
							val = line.substring(right[0], right[1]);
						}
						if (val.contains(" ")) {
							val = val.substring(val.lastIndexOf(' '), val.length());
						}
						colList[count] = val;
					}
					count++;

				}
				if (header) {
					for (int colnum = 0; colnum < colList.length; colnum++) {
						for (int valuenum = 0; valuenum < operandOneCol.length; valuenum++) {
							if (colList[colnum].trim().equalsIgnoreCase(operandOneCol[valuenum].trim())) {
								opndOnecolIndex.add(colnum);
								opOneColLength--;
							}
						}
						for (int valuenum = 0; valuenum < operandTwoCol.length; valuenum++) {
							if (colList[colnum].trim().equalsIgnoreCase(operandTwoCol[valuenum].trim())) {
								opndTwocolIndex.add(colnum);
								opTwoColLength--;
							}
						}
						if (operandOneCol.length == opndOnecolIndex.size()
								&& operandTwoCol.length == opndTwocolIndex.size()) {
							break;
						}
					}
					header = false;
					continue mainloop;
				}

				// got the header index use that to get the values
				Boolean conSatisfied = false;
				if (!colList[0].contains(DOUBLE_LINE) && !colList[0].contains(SINGLE_LINE)) {
					if (colList[0].contains(RESULT_OK)) {
						break mainloop;
					}
					for (int j = 0; j < opndOnecolIndex.size(); j++) {
						if (colList.length > j && colList[(int) opndOnecolIndex.get(j)].trim()
								.equalsIgnoreCase(operandOnevalueInput[connum].trim())) {
							conSatisfied = true;
						} else {
							conSatisfied = false;
							break;
						}
						connum++;
					}
				}
				if (conSatisfied) {
					int valuenum = 0;
					conSatisfiedCount++;
					int numofColYes = 0;
					int numofColNo = 0;
					int numOfCol = 0;
					for (int m = 0; m < opndTwocolIndex.size(); m++) {
						try {
							numOfCol++;
							int outputValue = Integer.parseInt(colList[(int) opndTwocolIndex.get(m)].trim());
							int inputValue = Integer.parseInt(operandTwovalueInput[valuenum].trim());

							if (outputValue <= inputValue) {
								result = "YES";
								numofColYes++;
							} else {
								result = "NO";
								numofColNo++;
							}

						} catch (NumberFormatException e) {
							result = "NO";
							numofColNo++;
						}
						valuenum++;
						if ("YES".equalsIgnoreCase(result) && "atleastone".equalsIgnoreCase(loopType)) {
							finalResult = "YES";
							break mainloop;
						}
						if ("all".equalsIgnoreCase(loopType) && "NO".equalsIgnoreCase(result)) {
							finalResult = "NO";
						}
					}
					if ("YES".equalsIgnoreCase(result) && "atleastone".equalsIgnoreCase(loopType) && numofColYes != 0
							&& numOfCol != 0 && numOfCol == numofColYes) {
						finalResult = "YES";
						break mainloop;
					}
					if (numofColYes != 0 && numOfCol != 0 && numOfCol == numofColYes) {
						yesCount++;

					}
					if (numofColNo != 0 && numOfCol != 0 && numOfCol == numofColNo) {
						noCount++;

					}

				}

			}

			if (conSatisfiedCount != 0 && conSatisfiedCount == yesCount) {
				finalResult = "YES";
			}
			if (conSatisfiedCount != 0 && conSatisfiedCount == noCount) {
				finalResult = "NO";
			}
			outputResult = getPassFail(cmdResult, finalResult);

		} catch (

		Exception e) {

			logger.error("Exception RunTestServiceImpl in shellLessEql() " + ExceptionUtils.getFullStackTrace(e));
		}

		return outputResult;

	}

	private String shellGreaterEql(String shellOutput, ShellCmdRuleBuilderEntity shellRule) {

		String result = NO_DATA;
		String outputResult = NO_DATA;
		String finalResult = NO_DATA;
		String opeCol1 = shellRule.getOperand1ColumnNames();
		String opeCol2 = shellRule.getOperand2ColumnNames();
		String operand1 = shellRule.getOperand1Values();
		String operand2 = shellRule.getOperand2Values();
		String cmdResult = shellRule.getStatus();
		String loopType = shellRule.getLoopType();
		String cmdName = shellRule.getCmdName();
		String[] operandOneCol = opeCol1.trim().split(ruleDelimiter);
		String[] operandTwoCol = opeCol2.trim().split(ruleDelimiter);
		String[] operandOnevalueInput = operand1.trim().split(ruleDelimiter);
		String[] operandTwovalueInput = operand2.trim().split(ruleDelimiter);
		List<ShellCommandEntity> shellCmdDetails = runTestRepository.getShellCommandDetails(cmdName);
		List opndOnecolIndex = new ArrayList<>();
		List opndTwocolIndex = new ArrayList<>();

		try {
			String[] lines = shellOutput.split("\\r?\\n");
			boolean header = true;
			// looping lines
			int startLine = 1;
			Map colDetailsMap = new TreeMap<>();
			int opOneColLength = operandOneCol.length;
			int opTwoColLength = operandTwoCol.length;
			int conSatisfiedCount = 0;
			int yesCount = 0;
			int noCount = 0;
			mainloop: for (int linenum = startLine; linenum < lines.length; linenum++) {
				String[] colList = new String[shellCmdDetails.size()];
				int connum = 0;
				String line = lines[linenum];
				if (line.isEmpty()) {
					continue mainloop;
				}
				int startString = 0;
				if (header) {
					for (int i = 0; i < shellCmdDetails.size(); i++) {
						int[] leftStartEndIndex = new int[2];
						int[] rightStartEndIndex = new int[2];
						List mapList = new ArrayList<>();

						ShellCommandEntity shellCommandEntity = shellCmdDetails.get(i);
						String columnName = shellCommandEntity.getColumnName().trim();

						int leftStartPoint = line.indexOf(columnName, startString);
						int leftendPoint = 0;
						if (i < shellCmdDetails.size() - 1) {
							leftendPoint = line.indexOf(shellCmdDetails.get(i + 1).getColumnName(), startString);
						} else {
							leftendPoint = Integer.MAX_VALUE;
						}
						leftStartEndIndex[0] = leftStartPoint;
						leftStartEndIndex[1] = leftendPoint;

						int rightStartPoint = 0;
						if (i == 0) {
							rightStartPoint = 0;
						} else {
							rightStartPoint = line.indexOf(shellCmdDetails.get(i - 1).getColumnName())
									+ shellCmdDetails.get(i - 1).getColumnName().length();
						}
						int rightendPoint = line.indexOf(columnName, startString) + columnName.length();
						rightStartEndIndex[0] = rightStartPoint;
						rightStartEndIndex[1] = rightendPoint;
						startString = line.indexOf(columnName, startString) + columnName.length();

						mapList.add(columnName);
						mapList.add(rightStartEndIndex);
						mapList.add(leftStartEndIndex);
						mapList.add(shellCommandEntity.getAlignment());
						colDetailsMap.put(i, mapList);
					}
				}

				Set set = colDetailsMap.entrySet();
				Iterator it = set.iterator();
				int count = 0;
				int maxCount = set.size();
				while (it.hasNext()) {
					Map.Entry me = (Map.Entry) it.next();

					List opeOne = (List) me.getValue();
					String align = (String) opeOne.get(3);
					if ("left".equalsIgnoreCase(align)) {
						String val = "";
						int[] left = (int[]) opeOne.get(2);
						if (left[0] <= line.length() && left[1] == Integer.MAX_VALUE) {
							val = line.substring(left[0], line.length());
						} else {
							if (left[1] <= line.length()) {
								val = line.substring(left[0], left[1]);
							}
						}
						if (val.contains(" ") && count + 1 != maxCount) {
							val = val.substring(0, val.indexOf(' '));
						}
						colList[count] = val;
					} else if ("right".equalsIgnoreCase(align)) {
						int[] right = (int[]) opeOne.get(1);
						String val = "";
						if (right[1] <= line.length()) {
							val = line.substring(right[0], right[1]);
						}
						if (val.contains(" ")) {
							val = val.substring(val.lastIndexOf(' '), val.length());
						}
						colList[count] = val;
					}
					count++;

				}
				if (header) {
					for (int colnum = 0; colnum < colList.length; colnum++) {
						for (int valuenum = 0; valuenum < operandOneCol.length; valuenum++) {
							if (colList[colnum].trim().equalsIgnoreCase(operandOneCol[valuenum].trim())) {
								opndOnecolIndex.add(colnum);
								opOneColLength--;
							}
						}
						for (int valuenum = 0; valuenum < operandTwoCol.length; valuenum++) {
							if (colList[colnum].trim().equalsIgnoreCase(operandTwoCol[valuenum].trim())) {
								opndTwocolIndex.add(colnum);
								opTwoColLength--;
							}
						}
						if (operandOneCol.length == opndOnecolIndex.size()
								&& operandTwoCol.length == opndTwocolIndex.size()) {
							break;
						}
					}
					header = false;
					continue mainloop;
				}

				// got the header index use that to get the values
				Boolean conSatisfied = false;
				if (!colList[0].contains(DOUBLE_LINE) && !colList[0].contains(SINGLE_LINE)) {
					if (colList[0].contains(RESULT_OK)) {
						break mainloop;
					}
					for (int j = 0; j < opndOnecolIndex.size(); j++) {
						if (colList.length > j && colList[(int) opndOnecolIndex.get(j)].trim()
								.equalsIgnoreCase(operandOnevalueInput[connum].trim())) {
							conSatisfied = true;
						} else {
							conSatisfied = false;
							break;
						}
						connum++;
					}
				}
				if (conSatisfied) {
					int valuenum = 0;
					conSatisfiedCount++;
					int numofColYes = 0;
					int numofColNo = 0;
					int numOfCol = 0;
					for (int m = 0; m < opndTwocolIndex.size(); m++) {
						try {
							numOfCol++;
							int outputValue = Integer.parseInt(colList[(int) opndTwocolIndex.get(m)].trim());
							int inputValue = Integer.parseInt(operandTwovalueInput[valuenum].trim());

							if (outputValue >= inputValue) {
								result = "YES";
								numofColYes++;
							} else {
								result = "NO";
								numofColNo++;
							}

						} catch (NumberFormatException e) {
							result = "NO";
							numofColNo++;
						}
						valuenum++;
						if ("YES".equalsIgnoreCase(result) && "atleastone".equalsIgnoreCase(loopType)) {
							finalResult = "YES";
							break mainloop;
						}
						if ("all".equalsIgnoreCase(loopType) && "NO".equalsIgnoreCase(result)) {
							finalResult = "NO";
						}
					}
					if ("YES".equalsIgnoreCase(result) && "atleastone".equalsIgnoreCase(loopType) && numofColYes != 0
							&& numOfCol != 0 && numOfCol == numofColYes) {
						finalResult = "YES";
						break mainloop;
					}
					if (numofColYes != 0 && numOfCol != 0 && numOfCol == numofColYes) {
						yesCount++;

					}
					if (numofColNo != 0 && numOfCol != 0 && numOfCol == numofColNo) {
						noCount++;

					}

				}

			}

			if (conSatisfiedCount != 0 && conSatisfiedCount == yesCount) {
				finalResult = "YES";
			}
			if (conSatisfiedCount != 0 && conSatisfiedCount == noCount) {
				finalResult = "NO";
			}

			outputResult = getPassFail(cmdResult, finalResult);

		} catch (

		Exception e) {

			logger.error("Exception RunTestServiceImpl in shellGreaterEql() " + ExceptionUtils.getFullStackTrace(e));
		}

		return outputResult;

	}

	private String shellGreater(String shellOutput, ShellCmdRuleBuilderEntity shellRule) {

		String result = NO_DATA;
		String outputResult = NO_DATA;
		String finalResult = NO_DATA;
		String opeCol1 = shellRule.getOperand1ColumnNames();
		String opeCol2 = shellRule.getOperand2ColumnNames();
		String operand1 = shellRule.getOperand1Values();
		String operand2 = shellRule.getOperand2Values();
		String cmdResult = shellRule.getStatus();
		String loopType = shellRule.getLoopType();
		String cmdName = shellRule.getCmdName();
		String[] operandOneCol = opeCol1.trim().split(ruleDelimiter);
		String[] operandTwoCol = opeCol2.trim().split(ruleDelimiter);
		String[] operandOnevalueInput = operand1.trim().split(ruleDelimiter);
		String[] operandTwovalueInput = operand2.trim().split(ruleDelimiter);
		List<ShellCommandEntity> shellCmdDetails = runTestRepository.getShellCommandDetails(cmdName);
		List opndOnecolIndex = new ArrayList<>();
		List opndTwocolIndex = new ArrayList<>();

		try {
			String[] lines = shellOutput.split("\\r?\\n");
			boolean header = true;
			// looping lines
			int startLine = 1;
			Map colDetailsMap = new TreeMap<>();
			int opOneColLength = operandOneCol.length;
			int opTwoColLength = operandTwoCol.length;
			int conSatisfiedCount = 0;
			int yesCount = 0;
			int noCount = 0;
			mainloop: for (int linenum = startLine; linenum < lines.length; linenum++) {
				String[] colList = new String[shellCmdDetails.size()];
				int connum = 0;
				String line = lines[linenum];
				if (line.isEmpty()) {
					continue mainloop;
				}
				int startString = 0;
				if (header) {
					for (int i = 0; i < shellCmdDetails.size(); i++) {
						int[] leftStartEndIndex = new int[2];
						int[] rightStartEndIndex = new int[2];
						List mapList = new ArrayList<>();

						ShellCommandEntity shellCommandEntity = shellCmdDetails.get(i);
						String columnName = shellCommandEntity.getColumnName().trim();

						int leftStartPoint = line.indexOf(columnName, startString);
						int leftendPoint = 0;
						if (i < shellCmdDetails.size() - 1) {
							leftendPoint = line.indexOf(shellCmdDetails.get(i + 1).getColumnName(), startString);
						} else {
							leftendPoint = Integer.MAX_VALUE;
						}
						leftStartEndIndex[0] = leftStartPoint;
						leftStartEndIndex[1] = leftendPoint;

						int rightStartPoint = 0;
						if (i == 0) {
							rightStartPoint = 0;
						} else {
							rightStartPoint = line.indexOf(shellCmdDetails.get(i - 1).getColumnName())
									+ shellCmdDetails.get(i - 1).getColumnName().length();
						}
						int rightendPoint = line.indexOf(columnName, startString) + columnName.length();
						rightStartEndIndex[0] = rightStartPoint;
						rightStartEndIndex[1] = rightendPoint;

						startString = line.indexOf(columnName, startString) + columnName.length();

						mapList.add(columnName);
						mapList.add(rightStartEndIndex);
						mapList.add(leftStartEndIndex);
						mapList.add(shellCommandEntity.getAlignment());
						colDetailsMap.put(i, mapList);
					}
				}

				Set set = colDetailsMap.entrySet();
				Iterator it = set.iterator();
				int count = 0;
				int maxCount = set.size();
				while (it.hasNext()) {
					Map.Entry me = (Map.Entry) it.next();

					List opeOne = (List) me.getValue();
					String align = (String) opeOne.get(3);
					if ("left".equalsIgnoreCase(align)) {
						String val = "";
						int[] left = (int[]) opeOne.get(2);
						if (left[0] <= line.length() && left[1] == Integer.MAX_VALUE) {
							val = line.substring(left[0], line.length());
						} else {
							if (left[1] <= line.length()) {
								val = line.substring(left[0], left[1]);
							}
						}
						if (val.contains(" ") && count + 1 != maxCount) {
							val = val.substring(0, val.indexOf(' '));
						}
						colList[count] = val;
					} else if ("right".equalsIgnoreCase(align)) {
						int[] right = (int[]) opeOne.get(1);
						String val = "";
						if (right[1] <= line.length()) {
							val = line.substring(right[0], right[1]);
						}
						if (val.contains(" ")) {
							val = val.substring(val.lastIndexOf(' '), val.length());
						}
						colList[count] = val;
					}
					count++;

				}
				if (header) {
					for (int colnum = 0; colnum < colList.length; colnum++) {
						for (int valuenum = 0; valuenum < operandOneCol.length; valuenum++) {
							if (colList[colnum].trim().equalsIgnoreCase(operandOneCol[valuenum].trim())) {
								opndOnecolIndex.add(colnum);
								opOneColLength--;
							}
						}
						for (int valuenum = 0; valuenum < operandTwoCol.length; valuenum++) {
							if (colList[colnum].trim().equalsIgnoreCase(operandTwoCol[valuenum].trim())) {
								opndTwocolIndex.add(colnum);
								opTwoColLength--;
							}
						}
						if (operandOneCol.length == opndOnecolIndex.size()
								&& operandTwoCol.length == opndTwocolIndex.size()) {
							break;
						}
					}
					header = false;
					continue mainloop;
				}

				// got the header index use that to get the values
				Boolean conSatisfied = false;
				if (!colList[0].contains(DOUBLE_LINE) && !colList[0].contains(SINGLE_LINE)) {
					if (colList[0].contains(RESULT_OK)) {
						break mainloop;
					}
					for (int j = 0; j < opndOnecolIndex.size(); j++) {
						if (colList.length > j && colList[(int) opndOnecolIndex.get(j)].trim()
								.equalsIgnoreCase(operandOnevalueInput[connum].trim())) {
							conSatisfied = true;
						} else {
							conSatisfied = false;
							break;
						}
						connum++;
					}
				}
				if (conSatisfied) {
					int valuenum = 0;
					conSatisfiedCount++;
					int numofColYes = 0;
					int numofColNo = 0;
					int numOfCol = 0;
					for (int m = 0; m < opndTwocolIndex.size(); m++) {
						try {
							numOfCol++;
							int outputValue = Integer.parseInt(colList[(int) opndTwocolIndex.get(m)].trim());
							int inputValue = Integer.parseInt(operandTwovalueInput[valuenum].trim());

							if (outputValue > inputValue) {
								result = "YES";
								numofColYes++;
							} else {
								result = "NO";
								numofColNo++;
							}
						} catch (NumberFormatException e) {
							result = "NO";
							numofColNo++;
						}
						valuenum++;
						if ("YES".equalsIgnoreCase(result) && "atleastone".equalsIgnoreCase(loopType)) {
							finalResult = "YES";
							break mainloop;
						}
						if ("all".equalsIgnoreCase(loopType) && "NO".equalsIgnoreCase(result)) {
							finalResult = "NO";
						}
					}

					if ("YES".equalsIgnoreCase(result) && "atleastone".equalsIgnoreCase(loopType) && numofColYes != 0
							&& numOfCol != 0 && numOfCol == numofColYes) {
						finalResult = "YES";
						break mainloop;
					}

					if (numofColYes != 0 && numOfCol != 0 && numOfCol == numofColYes) {
						yesCount++;

					}
					if (numofColNo != 0 && numOfCol != 0 && numOfCol == numofColNo) {
						noCount++;

					}

				}

			}

			if (conSatisfiedCount != 0 && conSatisfiedCount == yesCount) {
				finalResult = "YES";
			}
			if (conSatisfiedCount != 0 && conSatisfiedCount == noCount) {
				finalResult = "NO";
			}

			outputResult = getPassFail(cmdResult, finalResult);

		} catch (

		Exception e) {

			logger.error("Exception RunTestServiceImpl in shellGreater() " + ExceptionUtils.getFullStackTrace(e));
		}

		return outputResult;

	}

	private String shellContains(String shellOutput, ShellCmdRuleBuilderEntity shellRule) {

		String result = NO_DATA;
		String outputResult = NO_DATA;
		String finalResult = NO_DATA;
		String opeCol1 = shellRule.getOperand1ColumnNames();
		String opeCol2 = shellRule.getOperand2ColumnNames();
		String operand1 = shellRule.getOperand1Values();
		String operand2 = shellRule.getOperand2Values();
		String cmdResult = shellRule.getStatus();
		String loopType = shellRule.getLoopType();
		String cmdName = shellRule.getCmdName();
		String[] operandOneCol = opeCol1.trim().split(ruleDelimiter);
		String[] operandTwoCol = opeCol2.trim().split(ruleDelimiter);
		String[] operandOnevalueInput = operand1.trim().split(ruleDelimiter);
		String[] operandTwovalueInput = operand2.trim().split(ruleDelimiter);
		List<ShellCommandEntity> shellCmdDetails = runTestRepository.getShellCommandDetails(cmdName);
		List opndOnecolIndex = new ArrayList<>();
		List opndTwocolIndex = new ArrayList<>();

		try {
			String[] lines = shellOutput.split("\\r?\\n");
			boolean header = true;
			// looping lines
			int startLine = 1;
			Map colDetailsMap = new TreeMap<>();
			int opOneColLength = operandOneCol.length;
			int opTwoColLength = operandTwoCol.length;
			int conSatisfiedCount = 0;
			int yesCount = 0;
			int noCount = 0;
			mainloop: for (int linenum = startLine; linenum < lines.length; linenum++) {
				String[] colList = new String[shellCmdDetails.size()];
				int connum = 0;
				String line = lines[linenum];
				if (line.isEmpty()) {
					continue mainloop;
				}
				int startString = 0;
				if (header) {
					for (int i = 0; i < shellCmdDetails.size(); i++) {
						int[] leftStartEndIndex = new int[2];
						int[] rightStartEndIndex = new int[2];
						List mapList = new ArrayList<>();

						ShellCommandEntity shellCommandEntity = shellCmdDetails.get(i);
						String columnName = shellCommandEntity.getColumnName().trim();

						int leftStartPoint = line.indexOf(columnName, startString);

						int leftendPoint = 0;
						if (i < shellCmdDetails.size() - 1) {
							leftendPoint = line.indexOf(shellCmdDetails.get(i + 1).getColumnName(), startString);
						} else {
							leftendPoint = Integer.MAX_VALUE;
						}
						leftStartEndIndex[0] = leftStartPoint;
						leftStartEndIndex[1] = leftendPoint;

						int rightStartPoint = 0;
						if (i == 0) {
							rightStartPoint = 0;
						} else {

							rightStartPoint = line.indexOf(shellCmdDetails.get(i - 1).getColumnName())
									+ shellCmdDetails.get(i - 1).getColumnName().length();
						}

						int rightendPoint = line.indexOf(columnName, startString) + columnName.length();
						rightStartEndIndex[0] = rightStartPoint;
						rightStartEndIndex[1] = rightendPoint;

						startString = line.indexOf(columnName, startString) + columnName.length();

						mapList.add(columnName);
						mapList.add(rightStartEndIndex);
						mapList.add(leftStartEndIndex);
						mapList.add(shellCommandEntity.getAlignment());
						colDetailsMap.put(i, mapList);
					}
				}

				Set set = colDetailsMap.entrySet();
				Iterator it = set.iterator();
				int count = 0;
				int maxCount = set.size();
				while (it.hasNext()) {
					Map.Entry me = (Map.Entry) it.next();

					List opeOne = (List) me.getValue();
					String align = (String) opeOne.get(3);
					if ("left".equalsIgnoreCase(align)) {
						String val = "";
						int[] left = (int[]) opeOne.get(2);
						if (left[0] <= line.length() && left[1] == Integer.MAX_VALUE) {
							val = line.substring(left[0], line.length());
						} else {
							if (left[1] <= line.length()) {

								val = line.substring(left[0], left[1]);
							}
						}
						if (val.contains(" ") && count + 1 != maxCount) {
							val = val.substring(0, val.indexOf(' '));
						}
						colList[count] = val;
					} else if ("right".equalsIgnoreCase(align)) {
						int[] right = (int[]) opeOne.get(1);
						String val = "";
						if (right[1] <= line.length()) {
							val = line.substring(right[0], right[1]);
						}
						if (val.contains(" ")) {
							val = val.substring(val.lastIndexOf(' '), val.length());
						}
						colList[count] = val;
					}
					count++;

				}
				if (header) {
					for (int colnum = 0; colnum < colList.length; colnum++) {
						for (int valuenum = 0; valuenum < operandOneCol.length; valuenum++) {
							if (colList[colnum].trim().equalsIgnoreCase(operandOneCol[valuenum].trim())) {
								opndOnecolIndex.add(colnum);
								opOneColLength--;
							}
						}
						for (int valuenum = 0; valuenum < operandTwoCol.length; valuenum++) {
							if (colList[colnum].trim().equalsIgnoreCase(operandTwoCol[valuenum].trim())) {
								opndTwocolIndex.add(colnum);
								opTwoColLength--;
							}
						}
						if (operandOneCol.length == opndOnecolIndex.size()
								&& operandTwoCol.length == opndTwocolIndex.size()) {
							break;
						}
					}
					header = false;
					continue mainloop;
				}

				// got the header index use that to get the values
				Boolean conSatisfied = false;
				if (!colList[0].contains(DOUBLE_LINE) && !colList[0].contains(SINGLE_LINE)) {
					if (colList[0].contains(RESULT_OK)) {
						break mainloop;
					}
					for (int j = 0; j < opndOnecolIndex.size(); j++) {
						if (colList.length > j && colList[(int) opndOnecolIndex.get(j)].trim()
								.equalsIgnoreCase(operandOnevalueInput[connum].trim())) {
							conSatisfied = true;
						} else {
							conSatisfied = false;
							break;
						}
						connum++;
					}
				}
				if (conSatisfied) {
					int valuenum = 0;
					conSatisfiedCount++;
					int numofColYes = 0;
					int numofColNo = 0;
					int numOfCol = 0;
					for (int m = 0; m < opndTwocolIndex.size(); m++) {
						numOfCol++;
						String outputValue = colList[(int) opndTwocolIndex.get(m)].trim();
						String inputValue = operandTwovalueInput[valuenum].trim();

						if (outputValue.equalsIgnoreCase(inputValue)) {
							result = "YES";
							numofColYes++;
						} else {
							result = "NO";
							numofColNo++;
						}
						valuenum++;

						if ("all".equalsIgnoreCase(loopType) && "NO".equalsIgnoreCase(result)) {
							finalResult = "NO";
						}

					}
					if ("YES".equalsIgnoreCase(result) && "atleastone".equalsIgnoreCase(loopType) && numofColYes != 0
							&& numOfCol != 0 && numOfCol == numofColYes) {
						finalResult = "YES";
						break mainloop;
					}
					if (numofColYes != 0 && numOfCol != 0 && numOfCol == numofColYes) {
						yesCount++;
					}
					if (numofColNo != 0 && numOfCol != 0 && numOfCol == numofColNo) {
						noCount++;
					}

				}

			}

			if (conSatisfiedCount != 0 && conSatisfiedCount == yesCount) {
				finalResult = "YES";
			}
			if (conSatisfiedCount != 0 && conSatisfiedCount == noCount) {
				finalResult = "NO";
			}

			outputResult = getPassFail(cmdResult, finalResult);

		} catch (

		Exception e) {

			logger.error("Exception RunTestServiceImpl in shellContains() " + ExceptionUtils.getFullStackTrace(e));
		}

		return outputResult;

	}

	private String shellLine(String shellOutput, String opeCol1, String operand1, String cmdResult, String loopType) {
		String result = NO_DATA;
		String outputResult = "FAIL";
		String finalResult = NO_DATA;
		String[] operandOneCol = opeCol1.trim().split(ruleDelimiter);
		String[] operandOnevalueInput = operand1.trim().split(ruleDelimiter);

		try {
			String[] lines = shellOutput.split("\\r?\\n");
			// looping lines
			int startLine = 0;

			int conSatisfiedCount = 0;
			int yesCount = 0;
			mainloop: for (int linenum = startLine; linenum < lines.length; linenum++) {

				String s = lines[linenum];

				boolean indexCondition = false;
				// boolean result
				for (int valuenum = 0; valuenum < operandOneCol.length; valuenum++) {

					if (s.contains(operandOneCol[valuenum])) {
						indexCondition = true;
					} else {

						indexCondition = false;
					}
				}
				if (indexCondition) {
					int colCondition = 0;
					int numOfCol = 0;
					conSatisfiedCount++;

					for (int valuenum = 0; valuenum < operandOnevalueInput.length; valuenum++) {
						numOfCol++;
						if (s.contains(operandOnevalueInput[valuenum])) {
							result = "YES";
							colCondition++;
						} else {

							result = "NO";
						}

						if ("all".equalsIgnoreCase(loopType) && "NO".equalsIgnoreCase(result)) {
							finalResult = "NO";
							break mainloop;
						}
					}
					if ("YES".equalsIgnoreCase(result) && "atleastone".equalsIgnoreCase(loopType) && colCondition != 0
							&& operandOnevalueInput.length == colCondition) {
						finalResult = "YES";
						break mainloop;
					}
					if (colCondition != 0 && numOfCol != 0 && numOfCol == colCondition) {
						yesCount++;
					}

				}

			}
			if (conSatisfiedCount != 0 && conSatisfiedCount == yesCount) {
				finalResult = "YES";
			}
			outputResult = getPassFail(cmdResult, finalResult);

		} catch (Exception e) {

			logger.error("Exception RunTestServiceImpl in shellLine() " + ExceptionUtils.getFullStackTrace(e));
		}

		return outputResult;
	}

	public String nonCliProcessContains(CmdRuleBuilderEntity cmdRule, String output, int cmdSequence, String neName,
			String enbId) {
		String result = "FAIL";
		try {
			String operand1 = cmdRule.getOperand1Values();
			String operand2 = cmdRule.getOperand2Values();
			String operator = cmdRule.getOperator();
			String cmdStatus = cmdRule.getStatus();

			String finalOutput = requiredOutput(cmdRule, output, cmdSequence, neName, enbId);

			if (finalOutput != null) {
				String[] lines = finalOutput.split("\\r?\\n");
				for (String s : lines) {
					if (s.contains(operand1) && s.contains(operand2)) {

						switch (operator) {

						case "==":

							result = checkEquals(Integer.valueOf(operand1), Integer.valueOf(operand2), cmdStatus);
							break;

						case "<":
							result = checkLessThan(Integer.valueOf(operand1), Integer.valueOf(operand2), cmdStatus);
							break;

						case "<=":
							result = checkLessThanEql(Integer.valueOf(operand1), Integer.valueOf(operand2), cmdStatus);
							break;
						case ">":
							result = checkGreaterThan(Integer.valueOf(operand1), Integer.valueOf(operand2), cmdStatus);
							break;

						case ">=":
							result = checkGreaterThanEql(Integer.valueOf(operand1), Integer.valueOf(operand2),
									cmdStatus);
							break;

						case "CONTAINS":
							result = checkContains(cmdStatus);
							break;
						}

						break;
					}
				}
			}

		} catch (

		Exception e) {
			logger.error(
					"Exception RunTestServiceImpl in nonCliProcessContains() " + ExceptionUtils.getFullStackTrace(e));
		}
		return result;
	}

	@Override
	@SuppressWarnings("rawtypes")
	public Map<String, RunTestEntity> insertRunTestDetails(JSONObject runTestParams, String perlPath) {
		Date creationDate = new Date();
		Map<String, RunTestEntity> runTestEntityMap = new HashMap<>();
		try {

			@SuppressWarnings("unchecked")

			String serviceToken = runTestParams.get("serviceToken").toString();
			Map run = (Map) runTestParams.get("runTestFormDetails");
			List<LinkedHashMap> useCaseList = (List) run.get("useCase");
			List<Map> scriptSeqDetails = (List<Map>) run.get("scripts");
			List<Map> neList = (List<Map>) run.get("neDetails");
			String userName = runTestParams.get("userName").toString();

			String testname = run.get("testname").toString();
			String testDesc = run.get("testDesc").toString();
			String lsmVersion = run.get("lsmVersion").toString();
			String lsmName = run.get("lsmName").toString();
			String ciqName = run.get("ciqName").toString();
			String checklistFileName = run.get("checklistFileName").toString();
			int customerId = Integer.parseInt(runTestParams.get("customerId").toString());
			String usecase = "";
			String useCaseDetails = "";
			int count = 0;
			int programId = Integer.parseInt(runTestParams.get("programId").toString());
			String migrationType = runTestParams.get("migrationType").toString();
			String migrationSubType = runTestParams.get("migrationSubType").toString();

			if (migrationType.equalsIgnoreCase(Constants.MIGRATION)) {
				migrationType = "Migration";
			} else if (migrationType.equalsIgnoreCase(Constants.POST_MIGRATION)) {
				migrationType = "PostMigration";
			} else if (migrationType.equalsIgnoreCase(Constants.PRE_MIGRATION)) {
				migrationType = "PreMigration";
			}

			if ("precheck".equalsIgnoreCase(migrationSubType)) {
				migrationSubType = "PreCheck";
			} else if ("commission".equalsIgnoreCase(migrationSubType)) {
				migrationSubType = "Commission";
			} else if ("postcheck".equalsIgnoreCase(migrationSubType)) {
				migrationSubType = "PostCheck";
			} else if ("AUDIT".equalsIgnoreCase(migrationSubType)) {
				migrationSubType = "Audit";
			} else if ("RANATP".equalsIgnoreCase(migrationSubType)) {
				migrationSubType = "RanATP";
			} else if ("NEGrow".equalsIgnoreCase(migrationSubType)) {
				migrationSubType = "NEGrow";
			} else if ("PREAUDIT".equalsIgnoreCase(migrationSubType)) {
				migrationSubType = "PREAUDIT";
			}else if ("NESTATUS".equalsIgnoreCase(migrationSubType)) {
				migrationSubType = "NESTATUS";
			}

			for (Map ucase : useCaseList) {
				if (useCaseList.size() == count) {
					String uName = ucase.get("useCaseName").toString();
					usecase = usecase + uName;
					String uId = ucase.get("useCaseId").toString();
					String uSeq = ucase.get("executionSequence").toString();
					useCaseDetails = useCaseDetails + uName + "?" + uId + "?" + uSeq;
				} else {
					String uName = ucase.get("useCaseName").toString();
					usecase = usecase + uName + ",";
					String uId = ucase.get("useCaseId").toString();
					String uSeq = ucase.get("executionSequence").toString();
					useCaseDetails = useCaseDetails + uName + "?" + uId + "?" + uSeq + ",";
				}

			}

			CustomerDetailsEntity customerDetailsEntity = getCustomerDetailsEntity(programId);
			if (testname.contains("WFM")) {
				NetworkTypeDetailsEntity networkTypeDetailsEntity = customerDetailsEntity.getNetworkTypeDetailsEntity();
				networkTypeDetailsEntity.setRemarks("Ran from WFM");
			}
			if (!testname.contains("WFM")) {
				usecase = usecase.substring(0, usecase.length() - 1);
			}
			int flag = 0;
			for (Map neid : neList) {
				String usecases = "";
				String neName = neid.get("neName").toString();
				if ((runTestParams.get("programName").toString().equalsIgnoreCase("VZN-5G-DSS") 
						|| runTestParams.get("programName").toString().equalsIgnoreCase("VZN-5G-CBAND")  )&& (run.get("prePostAuditFlag")).equals(true)) {
					String timeStampDate = new SimpleDateFormat("yyyy-MM-dd_HH:mm:ss").format(new Date());
					if(testname.contains("PreEnbAudit")) {
						testname = "PreEnbAudit" +"_"+neName+"_"+ timeStampDate;
					}else if (testname.contains("PostEnbAudit")) {
						testname = "PostEnbAudit" +"_"+neName+"_"+ timeStampDate;
					}
				}
				if ((migrationType.equalsIgnoreCase(Constants.MIGRATION) || migrationSubType.equalsIgnoreCase("NEGrow"))
						&& !testname.contains("WFM")) {
					AtomicBoolean usecaseNotPresent = new AtomicBoolean(true);
					AtomicBoolean scriptEmpty = new AtomicBoolean(true);
					for (LinkedHashMap ucase : useCaseList) {
						if (useCaseList.size() == count) {
							if (ucase.get("useCaseName").toString().contains(neid.get("neId").toString())) {
								String uName = ucase.get("useCaseName").toString();
								usecases = usecases + uName;
								usecaseNotPresent.set(false);
							}
						} else {
							if (ucase.get("useCaseName").toString().contains(neid.get("neId").toString())) {
								String uName = ucase.get("useCaseName").toString();
								usecases = usecases + uName + ",";
								usecaseNotPresent.set(false);
							}
						}
						List<Map> scriptList = scriptSeqDetails.stream()
								.filter(x -> x.get("useCaseName").toString().equals(ucase.get("useCaseName").toString())
										&& x.get("useCaseName").toString().contains(neid.get("neId").toString()))
								.map(x -> x).collect(Collectors.toList());
						if (!scriptList.isEmpty() || !scriptEmpty.get()) {
							System.out.println(ucase.get("useCaseName").toString());
							scriptEmpty.set(false);
						}
					}
					if (usecaseNotPresent.get() || scriptEmpty.get()) {
						continue;
					}
					usecases = usecases.substring(0, usecases.length() - 1);
				}
				if (lsmVersion.isEmpty() || lsmName.isEmpty()) {
					NeMappingModel neMappingModelversion = new NeMappingModel();
					CustomerDetailsEntity programDetailsEntityversion = new CustomerDetailsEntity();
					programDetailsEntityversion.setId(programId);
					neMappingModelversion.setProgramDetailsEntity(programDetailsEntityversion);
					neMappingModelversion.setEnbId(neid.get("neId").toString());
					NetworkConfigEntity neMappingEntitiesForVersion = runTestRepository
							.getNetWorkEntityDetails(neMappingModelversion);
					lsmVersion = neMappingEntitiesForVersion.getNeVersionEntity().getNeVersion();
					lsmName = neMappingEntitiesForVersion.getNeName();
					flag = 1;
				}
				int RFcount=0;
				if ("precheck".equalsIgnoreCase(migrationSubType)) {
					StringBuilder rfScriptsPathdest = new StringBuilder();
					rfScriptsPathdest.append(LoadPropertyFiles.getInstance().getProperty("BASE_PATH"))
							.append(Constants.CUSTOMER).append(Constants.SEPARATOR).append(programId)
							.append(Constants.SEPARATOR)
							.append(Constants.PRE_MIGRATION_SCRIPT
									.replace("filename", StringUtils.substringBeforeLast(ciqName.toString(), "."))
									.replaceAll(" ", "_"))
							.append(neid.get("neId").toString()).append(Constants.SEPARATOR);
					if (!(runTestParams.get("programName").toString().equalsIgnoreCase("VZN-4G-FSU"))) {
					File rfScriptFolderdest = new File(rfScriptsPathdest.toString());
					File[] rfFiles = rfScriptFolderdest.listFiles();
					for (File file1 : rfFiles) {
						String fileExtension1 = FilenameUtils.getExtension(file1.getPath());
						if (fileExtension1.equalsIgnoreCase("xml")) {
							RFcount++;
						}
						}
					}
				}
				System.out.println(RFcount);
				StringBuilder comFilePath = new StringBuilder();
				comFilePath = comFilePath.append(Constants.CUSTOMER).append(Constants.SEPARATOR).append(programId);

				StringBuilder outputFilePath = new StringBuilder();
				 neName = neid.get("neName").toString();
				String neId = neid.get("neId").toString();

				outputFilePath = comFilePath.append(Constants.RUN_MIGRATION_OUTPUT.replace("migration", migrationType)
						.replace("enbId", StringUtils.substringBeforeLast(neId, "."))
						.replace("subtype", migrationSubType).replaceAll(" ", "_"));

				File outFilePath = new File(outputFilePath.toString());
				outFilePath.mkdirs();

				String outputFileName = outputFilePath + serviceToken + "_" + "output.txt";

				RunTestEntity runTestEntity = new RunTestEntity();
				runTestEntity.setCreationDate(creationDate);
				runTestEntity.setCustomerId(customerId);
				runTestEntity.setLsmName(lsmName);
				runTestEntity.setLsmVersion(lsmVersion);
				runTestEntity.setCiqName(ciqName);
				runTestEntity.setChecklistFileName(checklistFileName);
				runTestEntity.setTestName(testname);
				runTestEntity.setTestDescription(testDesc);
				runTestEntity.setMigrationType(migrationType);
				runTestEntity.setMigrationSubType(migrationSubType);
				if (migrationType.equalsIgnoreCase(Constants.MIGRATION) && !testname.contains("WFM")) {
					runTestEntity.setUseCase(usecases);
				} else {
					runTestEntity.setUseCase(usecase);
				}
				runTestEntity.setCustomerDetailsEntity(customerDetailsEntity);
				runTestEntity.setStatus("InProgress");
				runTestEntity.setNeName(neName);
				runTestEntity.setOutputFilepath(outputFileName);
				runTestEntity.setProgressStatus("InProgress");

				runTestEntity.setUseCaseDetails(useCaseDetails);
				runTestEntity.setResult(perlPath);
				runTestEntity.setUserName(userName);
				if ("precheck".equalsIgnoreCase(migrationSubType)) {
					String  TotalRFScript= String.valueOf(RFcount);
				runTestEntity.setTotalRFScript(TotalRFScript);
				}
				runTestEntityMap.put(neId, runTestRepository.createRunTest(runTestEntity));
				if (flag == 1) {
					lsmVersion = "";
					lsmName = "";
				}
			}

		}

		catch (Exception e) {
			logger.error(
					"Exception RunTestServiceImpl in insertRunTestDetails() " + ExceptionUtils.getFullStackTrace(e));
		}
		return runTestEntityMap;

	}
	
	

	@Override
	public CustomerDetailsEntity getCustomerDetailsEntity(int programId) {
		CustomerDetailsEntity customerDetailsEntity = null;
		try {
			customerDetailsEntity = runTestResultRepository.getCustomerDetailsEntity(programId);
		} catch (Exception e) {
			logger.error("Exception getCustomerDetailsEntity() in RunTestServiceImpl  : "
					+ ExceptionUtils.getFullStackTrace(e));
		}
		return customerDetailsEntity;
	}

	@Override
	public RunTestEntity getRunTestEntity(Integer runTestId) {
		RunTestEntity runTestEntity = null;
		try {
			runTestEntity = runTestRepository.getRunTestEntity(runTestId);
		} catch (Exception e) {
			logger.error("Exception getRunTestEntity() in RunTestServiceImpl :" + ExceptionUtils.getFullStackTrace(e));
		}

		return runTestEntity;
	}

	@Override
	public String getRunTestEntity(int programId, String migrationType, String subType, String testname) {
		try {
			boolean isTestNamePresent = runTestRepository.getRunTestEntity(programId, migrationType, subType, testname);
			if (isTestNamePresent) {
				return GlobalInitializerListener.faultCodeMap.get(FaultCodes.TEST_NAME_ALREADY_EXISTS);
			}
		} catch (Exception e) {
			logger.error("Exception RunTestServiceImpl in getRunTestEntity() " + ExceptionUtils.getFullStackTrace(e));
		}

		return Constants.SUCCESS;
	}

	@Override
	public boolean getInProgressRunTestDetails(int programId, String migrationType, String subType) {
		boolean isInProgress = false;
		try {
			isInProgress = runTestRepository.getInProgressRunTestDetails(programId, migrationType, subType);

		} catch (Exception e) {
			logger.error("Exception RunTestServiceImpl in getRunTestEntity() " + ExceptionUtils.getFullStackTrace(e));
		}

		return isInProgress;
	}

	@Override
	public List<RunTestResultEntity> getRunTestResult(Integer runTestId) {
		List<RunTestResultEntity> runTestResultEntityList = null;
		try {

			runTestResultEntityList = runTestResultRepository.getRunTestResultList(runTestId);

		} catch (Exception e) {
			logger.error("Exception RunTestServiceImpl in getRunTestResult() " + ExceptionUtils.getFullStackTrace(e));
		}
		return runTestResultEntityList;
	}
	@Override
	public List<OvTestResultEntity> getOvRunTestResult(Integer runTestId) {
		List<OvTestResultEntity> runTestResultEntityList = null;
		try {

			runTestResultEntityList = runTestResultRepository.getOVRunTestResultList(runTestId);

		} catch (Exception e) {
			logger.error("Exception RunTestServiceImpl in getRunTestResult() " + ExceptionUtils.getFullStackTrace(e));
		}
		return runTestResultEntityList;
	}
	@Override
	public List<PremigrationOvUpadteEntity> getOvRunTestResultpre(Integer runTestId) {
		List<PremigrationOvUpadteEntity> runTestResultEntityList = null;
		try {

			runTestResultEntityList = runTestResultRepository.getOVRunTestResultListpre(runTestId);

		} catch (Exception e) {
			logger.error("Exception RunTestServiceImpl in getRunTestResult() " + ExceptionUtils.getFullStackTrace(e));
		}
		return runTestResultEntityList;
	}
	
	
	@Override
	public boolean deleteOvRunTestResult(Integer runTestId) {
		List<OvTestResultEntity> runTestResultEntityList = null;
		boolean status = false;
		try {
			
			runTestResultEntityList = runTestResultRepository.getOVRunTestResultList(runTestId);
			for (OvTestResultEntity entity : runTestResultEntityList) {
				if(!deleteOVupdateEntityById(entity.getId())) {
					return false;
				}
			}
			//entityManager.remove(runTestResultRepository.getOVRunTestResultList(runTestId));
			
			status = true;
		} catch (Exception e) {
			status = false;
			logger.error(
					"Exception in deleterunTest() in  RunTestRepositoryImpl:" + ExceptionUtils.getFullStackTrace(e));
		} finally {
			entityManager.flush();
			entityManager.clear();
		}
		return status;
	}@Override
	
	public boolean deleteOVupdateEntityById(int OVid) {
		boolean status = false;
		try {
			//entityManager.createQuery("Delete from OV_UPDATE_RUN_TEST_RESULT where  RUN_TEST_ID =:id")
			entityManager.remove(getOvupdateEntityById(OVid));
			status = true;
		} catch (Exception e) {
			status = false;
			logger.error(
					"Exception in deleteOVupdateEntityById() in  RunTestImpl:" + ExceptionUtils.getFullStackTrace(e));
		} finally {
			entityManager.flush();
			entityManager.clear();
		}
		return status;
	}
	
	public OvTestResultEntity getOvupdateEntityById(int OVid) {
		return entityManager.find(OvTestResultEntity.class, OVid);
	}

	@Override
	public boolean deleteRunTest(Integer runTestId) {

		return runTestRepository.deleterunTest(runTestId);
	}

	@Override
	public String readOutputFile(String fileName) throws Exception {
		String data;
		String filepath = fileName;
		data = new String(Files.readAllBytes(Paths.get(filepath)));
		return data;
	}

	@Override
	public String loadRunningLog(Integer runTestId) {

		return runTestRepository.loadRunningLog(runTestId);
	}

	@Override
	public JSONObject getResult(List<RunTestResultEntity> entityList, String neName) {

		List usecases = new ArrayList<>();
		String neid = StringUtils.substringBefore(neName, "_");
		List usecaseCheck = new ArrayList<>();
		JSONObject resultOutput = new JSONObject();
		String scriptName = null;
		try {
			outer: for (RunTestResultEntity entity : entityList) {
				if (neName.contains(entity.getNeName())) {
					int cmdId = 0;
					int fileID = 0;
					int xmlId = 0;
					int shellId = 0;
					String cmdRuleName = null;
					String fileRuleName = null;
					String xmlRuleName = null;
					String shellRuleName = null;
					List scriptList = new ArrayList<>();
					Map scriptDetails = new HashMap<>();
					Map fileRuleMap = new HashMap<>();
					Map cmdRuleMap = new HashMap<>();
					Map shellRuleMap = new HashMap<>();
					Map xmlRuleMap = new HashMap<>();
					List fileRuleList = new ArrayList<>();
					List cmdRuleList = new ArrayList<>();
					List shellRuleList = new ArrayList<>();
					List xmlRuleList = new ArrayList<>();
					Map usecaseDetails = new HashMap<>();
					String scName = null;
					String currentOutputLoc = null;
					String shellPath = null;
					StringBuilder sb = new StringBuilder();
					StringBuilder shellOutputBefore = new StringBuilder();
					String shellOutputAfter = null;
					String shellOutput = null;
					String shellOutputBef = null;

					String useCaseName = entity.getUseCaseBuilderEntity().getUseCaseName();
					String type = entity.getMigrationType();
					int useCaseId = entity.getUseCaseBuilderEntity().getId();
					if (entity.getUploadFileEntity().getFileName().contains(".")) {
						String[] name = entity.getUploadFileEntity().getFileName().split("\\.");
						scriptName = name[0];
					}
					currentOutputLoc = LoadPropertyFiles.getInstance().getProperty("BASE_PATH")
							+ entity.getCurrentScriptOutput();
					scName = charRemoveAt(scriptName);
					int scriptId = entity.getUploadFileEntity().getId();
					String previousResult =entity.getPreviousResult();
					String previousOutput =entity.getPreviousScriptOutput();
					String result = entity.getCurrentResult();
					int scriptExeSeq = entity.getScriptExeSeq();
					File file = new File(currentOutputLoc);
					File[] listOfFiles = file.listFiles();
					for (int i = 0; i < listOfFiles.length; i++) {
						String ch = listOfFiles[i].toString();
						if (ch.contains(scName)) {
							BufferedReader bf = new BufferedReader(new FileReader(ch));
							String line = "";
							while ((line = bf.readLine()) != null) {
								sb.append(line).append("\n");
							}
						}
					}
					shellOutput = sb.toString();
					shellOutputAfter = StringUtils.substringAfter(shellOutput, "<rpc-");
					shellOutputBef = StringUtils.substringBefore(shellOutputAfter, "</rpc-reply>");
					shellOutputBefore = shellOutputBefore.append("Response").append("\n").append("<rpc-")
							.append(shellOutputBef).append(" ").append("</rpc-reply>");
					if (entity.getCmdRuleBuilderEntity() != null) {
						cmdId = entity.getCmdRuleBuilderEntity().getId();
						cmdRuleName = entity.getCmdRuleBuilderEntity().getRuleName();
					}

					if (entity.getFileRuleBuilderEntity() != null) {
						fileID = entity.getFileRuleBuilderEntity().getId();
						fileRuleName = entity.getFileRuleBuilderEntity().getRuleName();
					}

					if (entity.getXmlRuleBuilderEntity() != null) {
						xmlId = entity.getXmlRuleBuilderEntity().getId();
						xmlRuleName = entity.getXmlRuleBuilderEntity().getRuleName();
					}

					if (entity.getShellCmdRuleBuilderEntity() != null) {
						shellId = entity.getShellCmdRuleBuilderEntity().getId();
						shellRuleName = entity.getShellCmdRuleBuilderEntity().getRuleName();
					}
					if (fileRuleName != null) {

						FileRuleBuilderEntity fileRuleBuilder = runTestRepository.getFileRuleById(fileID);

						StringBuilder fileRuleDef = new StringBuilder();

						fileRuleDef.append("FileRuleName : ").append(fileRuleBuilder.getRuleName()).append(", ")
								.append("FileName : ").append(fileRuleBuilder.getFileName()).append(", ")
								.append("SearchParam : ").append(fileRuleBuilder.getSearchParameter()).append(", ")
								.append("Status : ").append(fileRuleBuilder.getStatus());

						if (type.equals("Migration")) {
							fileRuleMap.put("ruleName", "Result");
							fileRuleMap.put("ruleDefinition", shellOutputBefore);
						} else {
							fileRuleMap.put("ruleName", fileRuleName);
							fileRuleMap.put("ruleDefinition", fileRuleDef.toString());
						}
						fileRuleMap.put("status", result);
						fileRuleList.add(fileRuleMap);

						scriptDetails.put("File_Rules", fileRuleList);

					} else if (cmdRuleName != null) {
						CmdRuleBuilderEntity cmdRuleBuilder = runTestRepository.getCommandRuleById(cmdId);

						StringBuilder cmdRuleDef = new StringBuilder();

						cmdRuleDef.append("CommandRuleName : ").append(cmdRuleBuilder.getRuleName()).append(", ")
								.append("CommandName : ").append(cmdRuleBuilder.getCmdName()).append(", ")
								.append("OperandColumnOne : ").append(cmdRuleBuilder.getOperand1ColumnNames())
								.append(", ").append("OperandOne : ").append(cmdRuleBuilder.getOperand1Values())
								.append(", ").append("OperandColumnTwo : ")
								.append(cmdRuleBuilder.getOperand2ColumnNames()).append(", ").append("OperandTwo : ")
								.append(cmdRuleBuilder.getOperand2Values()).append(", ").append("Operator : ")
								.append(cmdRuleBuilder.getOperator()).append(", ").append("Status : ")
								.append(cmdRuleBuilder.getStatus());

						if (type.equals("Migration")) {
							cmdRuleMap.put("ruleName", "Result");
							cmdRuleMap.put("ruleDefinition", shellOutputBefore);
						} else {
							cmdRuleMap.put("ruleName", cmdRuleName);
							cmdRuleMap.put("ruleDefinition", cmdRuleDef.toString());
						}
						cmdRuleMap.put("status", result);
						cmdRuleList.add(cmdRuleMap);
						scriptDetails.put("Command_Rules", cmdRuleList);
					} else if (xmlRuleName != null) {
						XmlRuleBuilderEntity xmlRuleBuilder = runTestRepository.getXmlRuleById(xmlId);

						StringBuilder xmlRuleDef = new StringBuilder();

						xmlRuleDef.append("XmlRuleName : ").append(xmlRuleBuilder.getRuleName()).append(", ")
								.append("RootName : ").append(xmlRuleBuilder.getRootName()).append(", ")
								.append("SubrootName : ").append(xmlRuleBuilder.getSubRootName());

						if (CommonUtil.isValidObject(xmlRuleBuilder.getXmlRootEntitySet())
								&& xmlRuleBuilder.getXmlRootEntitySet().size() > 0) {
							for (XmlRootEntity xmlRootEntity : xmlRuleBuilder.getXmlRootEntitySet()) {
								xmlRuleDef.append(", ").append("RootKey : ").append(xmlRootEntity.getRootKey())
										.append(", ").append("RootValue : ").append(xmlRootEntity.getRootValue());
							}
						}

						if (CommonUtil.isValidObject(xmlRuleBuilder.getXmlElementEntitySet())
								&& xmlRuleBuilder.getXmlElementEntitySet().size() > 0) {
							for (XmlElementEntity xmlElementEntity : xmlRuleBuilder.getXmlElementEntitySet()) {
								xmlRuleDef.append(", ").append("ElementName : ")
										.append(xmlElementEntity.getElementName()).append(", ")
										.append("ElementValue : ").append(xmlElementEntity.getElementValue())
										.append(", ").append("Operator : ").append(xmlElementEntity.getOperator());
							}
						}
						xmlRuleDef.append(", ").append("Status : ").append(xmlRuleBuilder.getStatus());
						if (type.equals("Migration")) {
							xmlRuleMap.put("ruleName", "Result");
							xmlRuleMap.put("ruleDefinition", shellOutputBefore);
							xmlRuleMap.put("previousResult", previousResult);
							xmlRuleMap.put("previousOutput", previousOutput);
						} else {
							xmlRuleMap.put("ruleName", xmlRuleName);
							xmlRuleMap.put("ruleDefinition", xmlRuleDef.toString());
						}
						xmlRuleMap.put("status", result);
						xmlRuleList.add(xmlRuleMap);
						scriptDetails.put("XML_Rules", xmlRuleList);
					} else if (shellRuleName != null) {
						ShellCmdRuleBuilderEntity shellRuleBuilder = runTestRepository.getshellRuleById(shellId);

						StringBuilder shellRuleDef = new StringBuilder();

						shellRuleDef.append("CommandRuleName : ").append(shellRuleBuilder.getRuleName()).append(", ")
								.append("CommandName : ").append(shellRuleBuilder.getCmdName()).append(", ")
								.append("OperandColumnOne : ").append(shellRuleBuilder.getOperand1ColumnNames())
								.append(", ").append("OperandOne : ").append(shellRuleBuilder.getOperand1Values())
								.append(", ").append("OperandColumnTwo : ")
								.append(shellRuleBuilder.getOperand2ColumnNames()).append(", ").append("OperandTwo : ")
								.append(shellRuleBuilder.getOperand2Values()).append(", ").append("Operator : ")
								.append(shellRuleBuilder.getOperator()).append(", ").append("Status : ")
								.append(shellRuleBuilder.getStatus());
						if (type.equals("Migration")) {
							shellRuleMap.put("ruleName", "Result");
							shellRuleMap.put("ruleDefinition", shellOutputBefore);
							xmlRuleMap.put("previousResult", previousResult);
							xmlRuleMap.put("previousOutput", previousOutput);
						} else {
							shellRuleMap.put("ruleName", shellRuleName);
							shellRuleMap.put("ruleDefinition", shellRuleDef.toString());
						}
						shellRuleMap.put("status", result);
						shellRuleList.add(shellRuleMap);
						scriptDetails.put("Shell_Rules", shellRuleList);
					}
					scriptDetails.put("scriptName", scriptName);
					scriptDetails.put("scriptId", scriptId);
					scriptDetails.put("scriptExeSeq", scriptExeSeq);
					scriptList.add(scriptDetails);

					if (usecases.isEmpty()) {
						usecaseDetails.put("useCaseName", useCaseName);
						usecaseDetails.put("useCaseId", useCaseId);
						usecaseDetails.put("script_status", scriptList);
						usecases.add(usecaseDetails);
						usecaseCheck.add(useCaseName);
						continue;
					}

					if (!usecaseCheck.contains(useCaseName)) {
						usecaseDetails.put("useCaseName", useCaseName);
						usecaseDetails.put("useCaseId", useCaseId);
						usecaseDetails.put("script_status", scriptList);
						usecases.add(usecaseDetails);
						usecaseCheck.add(useCaseName);
						continue outer;

					} else {

						Map usecase1 = null;
						for (int i = 0; i < usecases.size(); i++) {
							Map usecases2 = (Map) usecases.get(i);
							String usecaser = (String) usecases2.get("useCaseName");
							if (usecaser.equals(useCaseName)) {
								usecase1 = usecases2;
								break;
							}
						}

						List<Map> scriptStatus = (List) usecase1.get("script_status");
						boolean sta = true;
						for (Map ruleDetails : scriptStatus) {
							int scriptIdval = (int) ((HashMap) ruleDetails).get("scriptId");
							if (scriptId == scriptIdval) {

								List cmdRulestatisList = (List) ((HashMap) ruleDetails).get("Command_Rules");

								if (cmdRulestatisList == null && !cmdRuleMap.isEmpty()) {
									List<Map> scriptListtmp = scriptList;
									for (Map ruleDetails1 : scriptListtmp) {
										List valu = (List) ruleDetails1.get("Command_Rules");
										ruleDetails.put("Command_Rules", valu);
										cmdRulestatisList = (List) ((HashMap) ruleDetails).get("Command_Rules");
										break;
									}

								}

								else if (cmdRulestatisList != null && !cmdRuleMap.isEmpty()) {
									cmdRulestatisList.add(cmdRuleMap);
								}
								List fileRulestatisList = (List) ((HashMap) ruleDetails).get("File_Rules");

								if (fileRulestatisList == null && !fileRuleMap.isEmpty()) {
									List<Map> scriptListtmp = scriptList;
									for (Map ruleDetails1 : scriptListtmp) {
										List valu = (List) ruleDetails1.get("File_Rules");
										ruleDetails.put("File_Rules", valu);
										fileRulestatisList = (List) ((HashMap) ruleDetails).get("File_Rules");
										break;
									}

								}

								else if (fileRulestatisList != null && !fileRuleMap.isEmpty()) {
									fileRulestatisList.add(fileRuleMap);
								}
								List xmlRulestatisList = (List) ((HashMap) ruleDetails).get("XML_Rules");

								if (xmlRulestatisList == null && !xmlRuleMap.isEmpty()) {
									List<Map> scriptListtmp = scriptList;
									for (Map ruleDetails1 : scriptListtmp) {
										List valu = (List) ruleDetails1.get("XML_Rules");
										ruleDetails.put("XML_Rules", valu);
										xmlRulestatisList = (List) ((HashMap) ruleDetails).get("XML_Rules");
										break;
									}

								}

								else if (xmlRulestatisList != null && !xmlRuleMap.isEmpty()) {
									xmlRulestatisList.add(xmlRuleMap);
								}
								List shellRulestatisList = (List) ((HashMap) ruleDetails).get("Shell_Rules");
								if (shellRulestatisList == null && !shellRuleMap.isEmpty()) {
									List<Map> scriptListtmp = scriptList;
									for (Map ruleDetails1 : scriptListtmp) {
										List valu = (List) ruleDetails1.get("Shell_Rules");
										ruleDetails.put("Shell_Rules", valu);
										shellRulestatisList = (List) ((HashMap) ruleDetails).get("Shell_Rules");
										break;
									}

								} else if (shellRulestatisList != null && !shellRuleMap.isEmpty()) {
									shellRulestatisList.add(shellRuleMap);
								}
								usecaseDetails.put("script_status", scriptStatus);
								sta = false;
								break;
							}

						}
						if (sta) {
							scriptStatus.add(scriptDetails);
							usecaseDetails.put("script_status", scriptStatus);
						}

					}
				}
			}
			resultOutput.put("status", "SUCCESS");
			resultOutput.put("useCaseResult", usecases);
		} catch (Exception e) {
			logger.error("Exception getResult() in RunTestServiceImpl :" + ExceptionUtils.getFullStackTrace(e));
		}
		return resultOutput;
	}

	@Override
	public String getScriptOutput(Integer runTestId, Integer useCaseId, Integer scriptId, String useCaseName,
			String scriptName) {
		String output;
		String text = "";
		String finalFileName = null;

		String fUseCaseName = useCaseName;
		String fScriptName = scriptName;

		if (useCaseName.contains("_")) {
			fUseCaseName = charRemoveAt(useCaseName);
		}

		if (scriptName.contains("_")) {
			fScriptName = charRemoveAt(scriptName);
		}

		fScriptName = fScriptName.replaceAll("\\s", "");
		fUseCaseName = fUseCaseName.replaceAll("\\s", "");

		try {
			output = runTestResultRepository.getScriptOutput(runTestId, useCaseId, scriptId);
			File file = new File(LoadPropertyFiles.getInstance().getProperty("BASE_PATH") + output);
			if (file.exists() && file.isDirectory()) {
				String[] files = file.list(); // get the files in String format.
				for (String fileName : files) {
					if (fileName.contains(fUseCaseName + "_" + fScriptName)) {
						finalFileName = fileName;
					}
				}
			}

			String path = LoadPropertyFiles.getInstance().getProperty("BASE_PATH") + output + finalFileName;

			text = new String(Files.readAllBytes(Paths.get(path)), StandardCharsets.UTF_8);

		} catch (Exception e) {
			logger.info("Exception in getScriptOutput() in RunTestServiceImpl" + ExceptionUtils.getFullStackTrace(e));
		}

		return text;
	}

	private String checkEquals(int operand1, int operand2, String cmdStatus) {

		String result = "FAIL";
		if (operand1 == operand2) {
			if ("pass".equalsIgnoreCase(cmdStatus)) {
				result = "PASS";
			} else
				result = "FAIL";
		}
		return result;

	}

	private String checkLessThan(int operand1, int operand2, String cmdStatus) {

		String result = "FAIL";
		if (operand1 < operand2) {
			if ("pass".equalsIgnoreCase(cmdStatus)) {
				result = "PASS";
			} else
				result = "FAIL";
		}
		return result;

	}

	private String checkLessThanEql(int operand1, int operand2, String cmdStatus) {

		String result = "FAIL";
		if (operand1 <= operand2) {
			if ("pass".equalsIgnoreCase(cmdStatus)) {
				result = "PASS";
			} else
				result = "FAIL";
		}
		return result;

	}

	private String checkContains(String cmdStatus) {
		String result;
		if ("pass".equalsIgnoreCase(cmdStatus)) {
			result = "PASS";
		} else {
			result = "FAIL";
		}
		return result;
	}

	private String checkGreaterThan(int operand1, int operand2, String cmdStatus) {
		String result = "FAIL";
		if (operand1 > operand2) {
			if ("pass".equalsIgnoreCase(cmdStatus)) {
				result = "PASS";
			} else
				result = "FAIL";
		}
		return result;
	}

	private String checkGreaterThanEql(int operand1, int operand2, String cmdStatus) {
		String result = "FAIL";
		if (operand1 >= operand2) {
			if ("pass".equalsIgnoreCase(cmdStatus)) {
				result = "PASS";
			} else
				result = "FAIL";
		}
		return result;

	}

	@Override
	public int loadRunTestDetails(int programId, String migrationType, String migrationSubType, int customerId,
			int history, RunTestModel runTestModels) {
		int runTestEntityCount = 0;
		try {
			List<RunTestEntity> runTestEntityList = runTestRepository.loadRunTestDetails(programId, migrationType,
					migrationSubType, customerId, history, runTestModels);
			runTestEntityCount = runTestEntityList.size();
		} catch (Exception e) {
			logger.error(" loadRunTestDetails service : " + ExceptionUtils.getFullStackTrace(e));
		}
		return runTestEntityCount;
	}

	public boolean fileExists(String fileName) {
		boolean result = false;
		try {

			String filepath = "/home/user/Desktop/eng/" + fileName;

			File f = new File(filepath);
			if (f.exists()) {
				result = true;

			} else {
				result = false;
			}

		} catch (Exception e) {
			logger.error("Exception RunTestServiceImpl in fileExists() " + ExceptionUtils.getFullStackTrace(e));
		}
		return result;

	}

	public Map<String, String> paramCount(String fileName, int count, String serachParam, String status) {
		String result = "FAIL";
		Map<String, String> map = new HashMap<>();
		try {
			String filepath = "/home/user/Desktop/eng/" + fileName;
			Map wordCountInFileMap = countWord(serachParam, filepath);
			int wordCountInFile = (int) wordCountInFileMap.get("count");
			String outputString = (String) wordCountInFileMap.get("fileoutput");

			if ((count == wordCountInFile) && ("PASS".equalsIgnoreCase(status))) {
				result = "PASS";
			} else if ((count == wordCountInFile) && ("FAIL".equalsIgnoreCase(status))) {
				result = "FAIL";
			} else if ((count != wordCountInFile) && ("PASS".equalsIgnoreCase(status))) {
				result = "FAIL";
			} else if ((count != wordCountInFile) && ("FAIL".equalsIgnoreCase(status))) {
				result = "PASS";
			}

			map.put("outputString", outputString);
			map.put("status", result);

		} catch (Exception e) {
			logger.error("Exception RunTestServiceImpl in paramCount() " + ExceptionUtils.getFullStackTrace(e));
		}
		return map;
	}

	public Map countWord(String word, String filePath) throws FileNotFoundException {
		FileInputStream fis = new FileInputStream(filePath);
		BufferedReader in = new BufferedReader(new InputStreamReader(fis));
		String readLine = "";
		int count = 0;
		Map map = new HashMap<>();
		StringBuilder fileoutput = new StringBuilder();
		try {
			while ((readLine = in.readLine()) != null) {
				if (readLine.contains(word)) {
					fileoutput = fileoutput.append("\n").append(readLine);
					count++;
				}

			}
			fis.close();
			map.put("count", count);
			map.put("fileoutput", fileoutput.toString());
		} catch (IOException e) {
			logger.error("Exception countWord() in RunTestServiceImpl :" + ExceptionUtils.getFullStackTrace(e));
		}
		return map;

	}

	@Override
	public String getConnection(JSONObject connectionParams) throws RctException {

		String sessionId = connectionParams.get("sessionId").toString();
		Map run = (Map) connectionParams.get("runTestFormDetails");
		int lsmId = (int) run.get("lsmId");
		int programId = (int) connectionParams.get("programId");
		boolean useCurrPassword = (boolean) run.get("currentPassword");
		String sanePassword = run.get("password").toString();
		StringBuilder comFilePath = new StringBuilder();
		String userName = connectionParams.get("userName").toString();

		NetworkConfigEntity networkConfigEntity = runTestRepository.getNeType(lsmId);

		String migrationType = connectionParams.get("migrationType").toString();
		String subType = connectionParams.get("migrationSubType").toString();
		String ciqFileName = run.get("ciqName").toString();
		List<Map> neList = (List<Map>) run.get("neDetails");
		String dbcollectionFileName = CommonUtil.createMongoDbFileName(String.valueOf(programId), ciqFileName);

		if (migrationType.equalsIgnoreCase(Constants.MIGRATION)) {
			migrationType = "Migration";
		} else if (migrationType.equalsIgnoreCase(Constants.POST_MIGRATION)) {
			migrationType = "PostMigration";
		}

		comFilePath = comFilePath.append(LoadPropertyFiles.getInstance().getProperty("BASE_PATH"))
				.append(Constants.CUSTOMER).append(Constants.SEPARATOR).append(programId).append(Constants.SEPARATOR)
				.append(migrationType);

		String exeFilePath = comFilePath + Constants.CHECK_CONNECTION_EXE + "/";
		String outputFilePath = comFilePath + Constants.CHECK_CONNECTION_OUTPUT + "/";

		File outfilePath = new File(outputFilePath);
		outfilePath.mkdirs();

		File filePath = new File(exeFilePath);
		filePath.mkdirs();

		String exeFileName = exeFilePath + sessionId + "_excScript.sh";
		String outputFileName = outputFilePath + sessionId + "_output.txt";

		// to check Ne connection

		/*
		 * for (Map neid : neList) {
		 * 
		 * String neName = neid.get("neName").toString(); MongoClient client = new
		 * MongoClient("localhost", 27017); MongoDatabase database =
		 * client.getDatabase("SMART_Config"); MongoCollection<Document> collection =
		 * database.getCollection(ciqName); List<Bson> queryFilters = new ArrayList<>();
		 * queryFilters.add(Filters.eq("ciqMap.eNB_Name", neName)); Bson searchFilter =
		 * Filters.and(queryFilters);
		 * 
		 * Document doc = collection.find(searchFilter).first();
		 * 
		 * String enbIP = doc.get("eNBId").toString();
		 * 
		 * }
		 */

		if (migrationType.equalsIgnoreCase(Constants.MIGRATION)) {
			migrationType = "Migration";
		} else if (migrationType.equalsIgnoreCase(Constants.POST_MIGRATION)) {
			migrationType = "PostMigration";
		}

		generatecheckConnectionExpectScript(networkConfigEntity, useCurrPassword, sanePassword, exeFileName,
				dbcollectionFileName, neList, userName);

		String output = null;
		try {
			Runtime.getRuntime().exec("chmod -R 777 " + exeFileName);

			output = executeCheckConnection(exeFileName, outputFileName);

			if (useCurrPassword == false) {
				userActionRepositoryImpl.changeVPNPassword(userName, sanePassword);
			}

		} catch (IOException e) {
			logger.error("Exception getConnection() in RunTestServiceImpl :" + ExceptionUtils.getFullStackTrace(e));

			output = e.getMessage();
		} catch (RctException e) {
			logger.error("Exception getConnection() in RunTestServiceImpl :" + ExceptionUtils.getFullStackTrace(e));
			throw new RctException(e.getMessage());
		}

		return output;
	}

	private void generatecheckConnectionExpectScript(NetworkConfigEntity networkConfigEntity, boolean useCurrPassword,
			String sanePassword, String exeFileName, String dbcollectionFileName, List<Map> neList, String userName) {

		StringBuilder sb = buildCheckConnectionScript(networkConfigEntity, useCurrPassword, dbcollectionFileName,
				neList, sanePassword, userName);

		String s = new String(sb);

		try (OutputStream os = new FileOutputStream(new File(exeFileName))) {
			os.write(s.getBytes(), 0, s.length());

		} catch (IOException e) {
			logger.info("Exception in generatecheckConnectionExpectScript() in RunTestServiceImpl"
					+ ExceptionUtils.getFullStackTrace(e));
		}

	}

	private StringBuilder buildCheckConnectionScript(NetworkConfigEntity networkConfigEntity, boolean useCurrPassword,
			String dbcollectionFileName, List<Map> neList, String sanePassword, String userName) {
		boolean first = true;

		List<NetworkConfigDetailsEntity> neDetailsLst = networkConfigEntity.getNeDetails();

		Collections.sort(neDetailsLst, Comparator.comparing(NetworkConfigDetailsEntity::getStep));

		StringBuilder sb = new StringBuilder();

		try {

			String neSudoPwd = "";
			String neConfidCLIConnectionTerminalUserName = null;
			String neConnectionLocationUserName = null;
			String neConnectionLocationPwd = "";

			ProgramTemplateEntity programTemplateEntity = fileUploadRepository.getProgramTemplate(
					networkConfigEntity.getProgramDetailsEntity().getId(), Constants.SCRIPT_STORE_TEMPLATE);

			List<GrowConstantsEntity> objListProgDetails = fileUploadRepository.getGrowConstantsDetails();
			String BASH_EXPECT_TIMEOUT = Constants.EXPECT_WAIT_TIME;
			try {
				Map<String, String> resultMapForConstants = objListProgDetails.stream()
						.filter(X -> X.getLabel().startsWith("BASH_EXPECT_TIMEOUT"))
						.collect(Collectors.toMap(GrowConstantsEntity::getLabel, GrowConstantsEntity::getValue));
				BASH_EXPECT_TIMEOUT = resultMapForConstants.get(Constants.BASH_EXPECT_TIMEOUT);
			} catch (Exception e) {
				BASH_EXPECT_TIMEOUT = Constants.EXPECT_WAIT_TIME;
				logger.error("Exception buildCheckConnectionScript() in RunTestServiceImpl :"
						+ ExceptionUtils.getFullStackTrace(e));
			}

			if (programTemplateEntity != null) {
				if (programTemplateEntity.getValue() != null && !programTemplateEntity.getValue().trim().isEmpty()) {
					JSONObject objData = CommonUtil.parseDataToJSON(programTemplateEntity.getValue());
					HashMap connLocation = (HashMap) objData.get("connLocation");

					// NE
					HashMap ne = (HashMap) connLocation.get("NE");
					neSudoPwd = ne.get("sudoPassword").toString();
					neConnectionLocationUserName = ne.get("username").toString();
					neConnectionLocationPwd = ne.get("password").toString();
				}
			}
			// This is for jump and sane connection
			for (NetworkConfigDetailsEntity neDetails : neDetailsLst) {

				String password = neDetails.getServerPassword();
				String sUserName = neDetails.getServerUserName();
				UserDetailsEntity userDetailsEntity = userActionRepositoryImpl.getUserDetailsBasedName(userName);

				if (first) {
					sb.append("#!/usr/bin/expect\n");
					sb.append("set timeout ").append(BASH_EXPECT_TIMEOUT).append("\n");
					sb.append("match_max 100000\n\n");

					/*
					 * sb.append("\n#proc ssh_login pass { \n");
					 * sb.append("#expect \"(yes/no)\" { send \"yes^M \"} \n");
					 * sb.append("#for {set x 0} {$x<3} {incr x} { \n");
					 * sb.append("#expect \"*word:\" { send $pass } \n"); sb.append("#} \n");
					 * sb.append("#expect \"Permission denied (publickey,password).\" {exit}  \n");
					 * sb.append("#sleep ").append(Constants.EXPECT_SLEEP_TIME).append("\n");
					 * sb.append("#} \n");
					 */

					if (useCurrPassword == false && neDetails.getServerTypeEntity().getServerType()
							.equalsIgnoreCase(Constants.SANE_SERVERYYPE)) {
						password = sanePassword;
						sUserName = userDetailsEntity.getVpnUserName();
					} else if (useCurrPassword == true && neDetails.getServerTypeEntity().getServerType()
							.equalsIgnoreCase(Constants.SANE_SERVERYYPE)) {
						password = PasswordCrypt.decrypt(userDetailsEntity.getVpnPassword());
						sUserName = userDetailsEntity.getVpnUserName();
					}
					sb.append("spawn ssh -o StrictHostKeyChecking=no -oCheckHostIP=no " + sUserName + "@"
							+ neDetails.getServerIp() + "\n");
					// sb.append("ssh_login \""+password + "\\r\" \n");
					sb.append("expect \"word:\" \n");
					sb.append("send \"" + password + "\\r\"\n\n");
					for (int i = 0; i < 3; i++) {
						sb.append("expect {");
						sb.append("\n");
						sb.append("\"word:\"\n" + "{");
						sb.append("send \"" + password + "\\r\"\n\n");
					}
					sb.append("expect {");
					sb.append("\n");
					sb.append("\"word:\"\n" + "{");
					sb.append("send \"" + "\\x3\\r\"" + "}" + "\n\n");
					sb.append("}");
					sb.append("\n");
					sb.append("expect {");
					for (int i = 0; i < 3; i++) {
						sb.append("\n\"" + neDetails.getUserPrompt() + "\"\n");
						sb.append("{");
						sb.append("send" + " ");
						sb.append("\"2\r\"");
						sb.append("}");
						sb.append("\n");
						sb.append("}");
						sb.append("\n");
						sb.append("}");
					}
					sb.append("\n\"" + neDetails.getUserPrompt() + "\"\n");
					sb.append("{");
					sb.append("send" + " ");
					sb.append("\"2\r\"");
					sb.append("}");
					sb.append("\n");
					sb.append("}");

					// sb.append("interact -o -nobuffer -re $prompt return\n");
					if (!neDetails.getServerTypeEntity().getServerType().equalsIgnoreCase(Constants.SANE_SERVERYYPE)) {
						sb.append("expect \"" + neDetails.getUserPrompt() + "\"\n");
					}
					includeConnectingMethods(sb, neDetails);
					first = false;
				} else {

					if (useCurrPassword == false && neDetails.getServerTypeEntity().getServerType()
							.equalsIgnoreCase(Constants.SANE_SERVERYYPE)) {
						password = sanePassword;
						sUserName = userDetailsEntity.getVpnUserName();
					} else if (useCurrPassword == true && neDetails.getServerTypeEntity().getServerType()
							.equalsIgnoreCase(Constants.SANE_SERVERYYPE)) {
						password = PasswordCrypt.decrypt(userDetailsEntity.getVpnPassword());
						sUserName = userDetailsEntity.getVpnUserName();
					}
					sb.append("send \"ssh -o StrictHostKeyChecking=no -oCheckHostIP=no " + sUserName + "@"
							+ neDetails.getServerIp() + "\\r\" \n");
					// sb.append("interact -o -nobuffer -re $prompt return\n");
					// sb.append("ssh_login \""+password + "\\r\" \n");
					sb.append("expect \"word:\" \n");
					sb.append("send \"" + password + "\\r\"\n\n");
					for (int i = 0; i < 3; i++) {
						sb.append("expects {");
						sb.append("\n");
						sb.append("\"word:\"\n" + "{");
						sb.append("send \"" + password + "\\r\"\n\n");
					}
					sb.append("expect {");
					sb.append("\n");
					sb.append("\"word:\"\n" + "{");
					sb.append("send \"" + "\\x3\\r\"" + "}" + "\n\n");
					sb.append("}");
					sb.append("\n");
					sb.append("expect {");
					for (int i = 0; i < 3; i++) {
						sb.append("\n\"" + neDetails.getUserPrompt() + "\"\n");
						sb.append("{");
						sb.append("send" + " ");
						sb.append("\"2\r\"");
						sb.append("}");
						sb.append("\n");
						sb.append("}");
						sb.append("\n");
						sb.append("}");
					}
					sb.append("\n\"" + neDetails.getUserPrompt() + "\"\n");
					sb.append("{");
					sb.append("send" + " ");
					sb.append("\"2\r\"");
					sb.append("}");
					sb.append("\n");
					sb.append("}");
					// sb.append("interact -o -nobuffer -re $prompt return\n");
					if (!neDetails.getServerTypeEntity().getServerType().equalsIgnoreCase(Constants.SANE_SERVERYYPE)) {
						sb.append("expect \"" + neDetails.getUserPrompt() + "\"\n");
					}
					includeConnectingMethods(sb, neDetails);
				}

			}

			// This is for lsm
			if (neDetailsLst.isEmpty()) {

				sb.append("#!/usr/bin/expect\n");
				sb.append("set timeout ").append(BASH_EXPECT_TIMEOUT).append("\n");
				sb.append("match_max 100000\n\n");

				/*
				 * sb.append("\n#proc ssh_login pass { \n");
				 * sb.append("#expect \"(yes/no)\" { send \"yes^M \"} \n");
				 * sb.append("#for {set x 0} {$x<3} {incr x} { \n");
				 * sb.append("#expect \"*word:\" { send $pass } \n"); sb.append("#} \n");
				 * sb.append("#expect \"Permission denied (publickey,password).\" {exit}  \n");
				 * sb.append("#sleep ").append(Constants.EXPECT_SLEEP_TIME).append("\n");
				 * sb.append("#} \n");
				 */

				sb.append("spawn ssh -o StrictHostKeyChecking=no -oCheckHostIP=no "
						+ networkConfigEntity.getNeUserName() + "@" + networkConfigEntity.getNeIp() + "\n");
				// sb.append("ssh_login \""+ networkConfigEntity.getNePassword() + "\\r\" \n");
				sb.append("expect \"word:\" \n");

				sb.append("send \"" + networkConfigEntity.getNePassword() + "\\r\"\n");

				// sb.append("interact -o -nobuffer -re $prompt return\n");
				sb.append("expect \"" + networkConfigEntity.getNeUserName() + "\" \n");
				sb.append("\n");

			} else {

				sb.append("send \"ssh -o StrictHostKeyChecking=no -oCheckHostIP=no "
						+ networkConfigEntity.getNeUserName() + "@" + networkConfigEntity.getNeIp() + "\\r\" \n");
				// sb.append("interact -o -nobuffer -re $prompt return\n");
				sb.append("expect \"word:\" \n");
				sb.append("send \"" + networkConfigEntity.getNePassword() + "\\r\"\n");
				// sb.append("interact -o -nobuffer -re $prompt return\n");
				sb.append("expect \"" + networkConfigEntity.getNeUserName() + "\" \n\n");

			}

			// uncomment this code to run on enb bhuvana

			// this is for enb

			for (Map ne : neList) {

				String neId = ne.get("neId").toString();
				String vznEnbIP = fileUploadRepository.getEnBDataByPath(dbcollectionFileName, Constants.VZ_GROW_IPPLAN,
						neId, Constants.ORAN_SPRINT_COMM_SCRIPT_eNB_OAM_IP_eNB_S_B_IP);
				String eNB_OAM_IP = fileUploadRepository.getEnBDataByPath(dbcollectionFileName,
						Constants.SPT_GROW_SHEET_FDD_TDD, neId, Constants.ORAN_SPRINT_COMM_SCRIPT_8_CHG_IP_ADDR);
				String enbIP = "127.0.0.1";

				String CSR_OAM_IP = fileUploadRepository.getEnBDataByPath(dbcollectionFileName,
						Constants.SPT_GROW_SHEET_FDD_TDD, neId, Constants.ORAN_SPRINT_COMM_SCRIPT_9_CSR_OAM_IP);

				if (StringUtils.isNotEmpty(vznEnbIP)) {
					enbIP = vznEnbIP;
				} else if (StringUtils.isNotEmpty(eNB_OAM_IP)) {
					String sprintEnbIP = CommonUtil.getLeftSubStringWithLen(eNB_OAM_IP, 3);
					if (StringUtils.isNotEmpty(sprintEnbIP)) {
						enbIP = sprintEnbIP;
					} else {
						enbIP = eNB_OAM_IP;
					}
				}

				sb.append("send \"ssh -o StrictHostKeyChecking=no -oCheckHostIP=no " + neConnectionLocationUserName
						+ "@" + enbIP + "\\r\" \n");
				sb.append("expect \"word:\" \n");
				sb.append("send \"" + neConnectionLocationPwd + "\\r\"\n");
				sb.append("expect \"" + neConnectionLocationUserName + "\" \n\n");
				sb.append("send \"exit\\r\"\n");
				sb.append("expect \"" + networkConfigEntity.getNeUserName() + "\"\n\n");
			}

			if (neDetailsLst.isEmpty()) {
				sb.append("send \"exit\\r\"\n");
			} else {
				neDetailsLst = neDetailsLst.stream().sorted((x1, x2) -> -(x1.getStep().compareTo(x2.getStep())))
						.collect(Collectors.toList());
				sb.append("send \"exit\\r\"\n");
				for (NetworkConfigDetailsEntity detailsEntity : neDetailsLst) {
					sb.append("expect \"" + detailsEntity.getServerUserName() + "\"\n");
					sb.append("send \"exit\\r\"\n");
				}
			}

			/*
			 * // root login sb.append("\nsend \"" + Constants.ENB_SUDO_EXPECT +
			 * " \\r\" \n"); sb.append("expect \"word*\" \n"); sb.append("send \"" +
			 * neSudoPwd + "\\r\" \n"); sb.append("expect \"root\" \n \n");
			 */

			/*
			 * if(useCurrPassword == false) {
			 * userActionRepositoryImpl.changeVPNPassword(userName,sanePassword); }
			 */

		} catch (Exception e) {
			logger.error("Exception buildCheckConnectionScript() in RunTestServiceImpl :"
					+ ExceptionUtils.getFullStackTrace(e));

		}
		return sb;
	}

	private StringBuilder buildConnectionEndScript(NetworkConfigEntity networkConfigEntity,
			UploadFileEntity scriptEntity, int programId, String neType, String useCaseName) {
		List<NetworkConfigDetailsEntity> neDetailsLst = networkConfigEntity.getNeDetails();
		/*
		 * Collections.sort(neDetailsLst,
		 * Comparator.comparing(NetworkConfigDetailsEntity::getStep));
		 * Collections.reverseOrder(Comparator.comparing(NetworkConfigDetailsEntity::
		 * getStep));
		 */

		neDetailsLst = neDetailsLst.stream().sorted((x1, x2) -> -(x1.getStep().compareTo(x2.getStep())))
				.collect(Collectors.toList());

		StringBuilder sb = new StringBuilder();
		try {

			String neConfidCLIConnectionTerminalUserName = null;
			String neConnectionLocationUserName = null;
			String smBSMUseName = null;
			String smCSRUseName = null;

			ProgramTemplateEntity programTemplateEntity = fileUploadRepository.getProgramTemplate(programId,
					Constants.SCRIPT_STORE_TEMPLATE);
			if (programTemplateEntity != null) {
				if (programTemplateEntity.getValue() != null && !programTemplateEntity.getValue().trim().isEmpty()) {
					JSONObject objData = CommonUtil.parseDataToJSON(programTemplateEntity.getValue());
					HashMap connLocation = (HashMap) objData.get("connLocation");

					// NE
					HashMap ne = (HashMap) connLocation.get("NE");
					neConnectionLocationUserName = ne.get("username").toString();

					ArrayList<HashMap> NETerminal = (ArrayList) ne.get("terminals");
					for (HashMap neTerminal : NETerminal) {
						String NETerminalName = neTerminal.get("terminalName").toString();
						if (NETerminalName.equalsIgnoreCase(Constants.CONFDCLI_TERMINAL)) {
							neConfidCLIConnectionTerminalUserName = neTerminal.get("termUsername").toString();
						}
					}

					// SM
					HashMap sm = (HashMap) connLocation.get("SM");
					ArrayList<HashMap> SMTerminal = (ArrayList) sm.get("terminals");
					for (HashMap smTerminal : SMTerminal) {
						String SMTerminalName = smTerminal.get("terminalName").toString();
						if (SMTerminalName.equalsIgnoreCase(Constants.CSR_TERMINAL)) {
							smCSRUseName = smTerminal.get("termUsername").toString();
							if (Constants.NE_TYPE_CSR.equalsIgnoreCase(neType)) {
								neConnectionLocationUserName = smCSRUseName;
							}
						} else if (SMTerminalName.equalsIgnoreCase(Constants.BSM_TERMINAL)) {
							smBSMUseName = smTerminal.get("termUsername").toString();
							if (Constants.NE_TYPE_BSM.equalsIgnoreCase(neType)) {
								neConnectionLocationUserName = smBSMUseName;
							}
						}
					}

				}
			}
			if (scriptEntity.getConnectionTerminal().equalsIgnoreCase(Constants.CLI_TERMINAL)
					|| scriptEntity.getConnectionTerminal().equalsIgnoreCase(Constants.CONFDCLI_TERMINAL)
					|| scriptEntity.getConnectionTerminal().equalsIgnoreCase(Constants.BASH_TERMINAL)
					|| scriptEntity.getConnectionTerminal().equalsIgnoreCase(Constants.CURL_TERMINAL)
					|| useCaseName.contains(Constants.COMMISION_USECASE) || useCaseName.contains(Constants.RF_USECASE)
					|| useCaseName.contains(Constants.GROWCELLUSECASE) || useCaseName.contains(Constants.GROWENBUSECASE)
					|| useCaseName.contains(Constants.PNPUSECASE) || useCaseName.contains("AUCaCell")
					|| useCaseName.contains("AU20B") || useCaseName.contains("AU20A")
					|| useCaseName.contains("pnp20BUsecase") || useCaseName.contains("pnp20AUsecase")
					|| useCaseName.contains("AU20C") || useCaseName.contains("pnp20CUsecase")) {
				if (scriptEntity.getConnectionLocation() != null
						&& scriptEntity.getConnectionLocation().equalsIgnoreCase(Constants.NE_SERVERYYPE)) {
					if (!Constants.NE_TYPE_CSR.equalsIgnoreCase(neType)
							&& !Constants.NE_TYPE_BSM.equalsIgnoreCase(neType)) {
						sb.append("expect \"root\"\n");
						sb.append("send \"exit\\r\"\n");
					}
					sb.append("expect \"" + neConnectionLocationUserName + "\"\n");
					sb.append("send \"exit\\r\"\n");
				} else if (Constants.NE_TYPE_CSR.equalsIgnoreCase(neType)) {
					sb.append("expect \"" + neConnectionLocationUserName + "\"\n");
					sb.append("send \"exit\\r\"\n");
				} else if (Constants.NE_TYPE_BSM.equalsIgnoreCase(neType)) {
					sb.append("expect \"" + neConnectionLocationUserName + "\"\n");
					sb.append("send \"exit\\r\"\n");
				}

				if (neDetailsLst.isEmpty()) {
					sb.append("expect \"" + networkConfigEntity.getNeUserName() + "\"\n");
					sb.append("send \"exit\\r\"\n");
				} else {
					sb.append("expect \"" + networkConfigEntity.getNeUserName() + "\"\n");
					sb.append("send \"exit\\r\"\n");
					for (NetworkConfigDetailsEntity detailsEntity : neDetailsLst) {
						if (detailsEntity.getServerTypeEntity().getServerType()
								.equalsIgnoreCase(Constants.SANE_SERVERYYPE)) {
							sb.append("expect \"" + detailsEntity.getSuperUserPrompt() + "\"\n");
							sb.append("send \"exit\\r\"\n");
							sb.append("expect \"" + detailsEntity.getUserPrompt() + "\"\n");
							sb.append("send \"x\\r\"\n");
						} else {
							sb.append("expect \"" + detailsEntity.getServerUserName() + "\"\n");
							sb.append("send \"exit\\r\"\n");
						}
					}
				}
			}

		} catch (Exception e) {
			logger.error("Exception buildConnectionEndScript() in RunTestServiceImpl :"
					+ ExceptionUtils.getFullStackTrace(e));

		}
		return sb;
	}

	private StringBuilder buildConnectionScript(NetworkConfigEntity networkConfigEntity, boolean useCurrPassword,
			String eNBIp, String sanePassword, String userName, UploadFileEntity scriptEntity, String useCaseName,
			String neId, String text, String neName, int programId, String neType) {
		boolean first = true;

		List<NetworkConfigDetailsEntity> neDetailsLst = networkConfigEntity.getNeDetails();

		Collections.sort(neDetailsLst, Comparator.comparing(NetworkConfigDetailsEntity::getStep));

		StringBuilder sb = new StringBuilder();

		String mcmaIp = "";
		try {

			// Template changes starts
			String neSudoPwd = "";
			String neConfidCLIConnectionTerminalUserName = null;
			String neConnectionLocationUserName = null;
			String neConnectionLocationPwd = "";
			String neConfdCLIPrompt = null;
			String neBashPrompt = null;
			String neCLIPrompt = null;
			String smCurlPrompt = null;
			String smBashPrompt = null;
			String smCmdSysPrompt = null;
			String smCmdxPrompt = null;

			String smCSRPrompt = null;
			String smCSRUseName = null;
			String smCSRPwd = null;

			String smBSMPrompt = null;
			String smBSMUseName = null;
			String smBSMPwd = null;

			ProgramTemplateEntity programTemplateEntity = fileUploadRepository.getProgramTemplate(programId,
					Constants.SCRIPT_STORE_TEMPLATE);

			List<GrowConstantsEntity> objListProgDetails = fileUploadRepository.getGrowConstantsDetails();
			String BASH_EXPECT_TIMEOUT = Constants.EXPECT_WAIT_TIME;
			try {
				Map<String, String> resultMapForConstants = objListProgDetails.stream()
						.filter(X -> X.getLabel().startsWith("BASH_EXPECT_TIMEOUT"))
						.filter(X -> X.getProgramDetailsEntity().getId().equals(programId))
						.collect(Collectors.toMap(GrowConstantsEntity::getLabel, GrowConstantsEntity::getValue));
				BASH_EXPECT_TIMEOUT = resultMapForConstants.get(Constants.BASH_EXPECT_TIMEOUT);
			} catch (Exception e) {
				BASH_EXPECT_TIMEOUT = Constants.EXPECT_WAIT_TIME;
				logger.error("Exception buildCheckConnectionScript() in RunTestServiceImpl :"
						+ ExceptionUtils.getFullStackTrace(e));
			}

			if (programTemplateEntity != null) {
				if (programTemplateEntity.getValue() != null && !programTemplateEntity.getValue().trim().isEmpty()) {
					JSONObject objData = CommonUtil.parseDataToJSON(programTemplateEntity.getValue());
					HashMap connLocation = (HashMap) objData.get("connLocation");

					// NE
					HashMap ne = (HashMap) connLocation.get("NE");
					neSudoPwd = ne.get("sudoPassword").toString();
					neConnectionLocationUserName = ne.get("username").toString();
					neConnectionLocationPwd = ne.get("password").toString();

					ArrayList<HashMap> NETerminal = (ArrayList) ne.get("terminals");
					for (HashMap neTerminal : NETerminal) {
						String NETerminalName = neTerminal.get("terminalName").toString();
						if (NETerminalName.equalsIgnoreCase(Constants.CONFDCLI_TERMINAL)) {
							neConfidCLIConnectionTerminalUserName = neTerminal.get("termUsername").toString();
							neConfdCLIPrompt = neTerminal.get("prompt").toString();
						} else if (NETerminalName.equalsIgnoreCase(Constants.BASH_TERMINAL)) {
							neBashPrompt = neTerminal.get("prompt").toString();
						} else if (NETerminalName.equalsIgnoreCase(Constants.CLI_TERMINAL)) {
							neCLIPrompt = neTerminal.get("prompt").toString();
						}
					}

					// SM
					HashMap sm = (HashMap) connLocation.get("SM");
					ArrayList<HashMap> SMTerminal = (ArrayList) sm.get("terminals");
					for (HashMap smTerminal : SMTerminal) {
						String SMTerminalName = smTerminal.get("terminalName").toString();
						if (SMTerminalName.equalsIgnoreCase(Constants.CURL_TERMINAL)) {
							smCurlPrompt = smTerminal.get("prompt").toString();
						} else if (SMTerminalName.equalsIgnoreCase(Constants.BASH_TERMINAL)) {
							smBashPrompt = smTerminal.get("prompt").toString();
						} else if (SMTerminalName.equalsIgnoreCase(Constants.CMD_SYS_TERMINAL)) {
							smCmdSysPrompt = smTerminal.get("prompt").toString();
						} else if (SMTerminalName.equalsIgnoreCase(Constants.CMDX_TERMINAL)) {
							smCmdxPrompt = smTerminal.get("prompt").toString();
						} else if (SMTerminalName.equalsIgnoreCase(Constants.CSR_TERMINAL)) {
							smCSRPrompt = smTerminal.get("prompt").toString();
							smCSRUseName = smTerminal.get("termUsername").toString();
							smCSRPwd = smTerminal.get("termPassword").toString();
							if (Constants.NE_TYPE_CSR.equalsIgnoreCase(neType)) {
								neConnectionLocationUserName = smCSRUseName;
								neConnectionLocationPwd = smCSRPwd;
							}
						} else if (SMTerminalName.equalsIgnoreCase(Constants.BSM_TERMINAL)) {
							smBSMPrompt = smTerminal.get("prompt").toString();
							smBSMUseName = smTerminal.get("termUsername").toString();
							smBSMPwd = smTerminal.get("termPassword").toString();
							if (Constants.NE_TYPE_BSM.equalsIgnoreCase(neType)) {
								neConnectionLocationUserName = smBSMUseName;
								neConnectionLocationPwd = smBSMPwd;
							}
						}
					}

				}
			}
			// Template changes end

			// This is for jump and sane connection
			for (NetworkConfigDetailsEntity neDetails : neDetailsLst) {

				String password = neDetails.getServerPassword();
				String sUserName = neDetails.getServerUserName();
				UserDetailsEntity userDetailsEntity = userActionRepositoryImpl.getUserDetailsBasedName(userName);

				// if the server is of type VLSM MCMA get mcma ip
				if (neDetails.getServerTypeEntity().getId() == Constants.NW_CONFIG_VLSM_MCMA_ID) {
					mcmaIp = neDetails.getServerIp();
				}

				if (first) {
					if (useCurrPassword == false && neDetails.getServerTypeEntity().getServerType()
							.equalsIgnoreCase(Constants.SANE_SERVERYYPE)) {
						password = sanePassword;
						if (password.contains("$")) {
							password = password.replace("$", "\\$");
						}
						sUserName = userDetailsEntity.getVpnUserName();
					} else if (useCurrPassword == true && neDetails.getServerTypeEntity().getServerType()
							.equalsIgnoreCase(Constants.SANE_SERVERYYPE)) {
						password = PasswordCrypt.decrypt(userDetailsEntity.getVpnPassword());
						if (password.contains("$")) {
							password = password.replace("$", "\\$");
						}
						sUserName = userDetailsEntity.getVpnUserName();
					}

					sb.append("#!/usr/bin/expect\n");
					sb.append("set timeout ").append(BASH_EXPECT_TIMEOUT).append("\n");
					sb.append("match_max 100000\n\n");

					/*
					 * sb.append("\n#proc ssh_login pass { \n");
					 * sb.append("#expect \"(yes/no)\" { send \"yes^M \"} \n");
					 * sb.append("#for {set x 0} {$x<3} {incr x} { \n");
					 * sb.append("#expect \"*word:\" { send $pass } \n"); sb.append("#} \n");
					 * sb.append("#expect \"Permission denied (publickey,password).\" {exit}  \n");
					 * sb.append("#sleep ").append(Constants.EXPECT_SLEEP_TIME).append("\n");
					 * sb.append("#} \n");
					 */
					String path = neDetails.getPath();

					String[] pathLst = path.split(",");
					sb.append("spawn ssh -o StrictHostKeyChecking=no -oCheckHostIP=no " + sUserName + "@"
							+ neDetails.getServerIp() + "\n");
					// sb.append("ssh_login \""+password + "\\r\" \n");
					// sb.append("interact -o -nobuffer -re $prompt return\n");
					sb.append("expect \"word:\" \n");
					sb.append("send \"" + password + "\\r\"\n\n");
					if (neDetails.getServerTypeEntity().getServerType().equalsIgnoreCase(Constants.SANE_SERVERYYPE)) {
						for (int i = 0; i < 3; i++) {
							sb.append("expect {");
							sb.append("\n");
							sb.append("\"word:\"\n" + "{");
							sb.append("send \"" + password + "\\r\"\n\n");
						}
						sb.append("expect {");
						sb.append("\n");
						sb.append("\"word:\"\n" + "{");
						sb.append("send \"" + "\\x3\\r\"" + "}" + "\n\n");
						sb.append("}");
						sb.append("\n");
						sb.append("expect {");
						for (int i = 0; i < 3; i++) {
							sb.append("\n\"" + neDetails.getUserPrompt() + "\"\n");
							sb.append("{");
							sb.append("send" + " ");
							sb.append("\"" + pathLst[0] + "\\r\"");
							sb.append("}");
							sb.append("\n");
							sb.append("}");
							sb.append("\n");
							sb.append("}");
						}
						sb.append("\n\"" + neDetails.getUserPrompt() + "\"\n");
						sb.append("{");
						sb.append("send" + " ");
						sb.append("\"" + pathLst[0] + "\\r\"");
						sb.append("}");
						sb.append("\n");
						sb.append("}");
						sb.append("\n");

					}
					if (!neDetails.getServerTypeEntity().getServerType().equalsIgnoreCase(Constants.SANE_SERVERYYPE)) {
						sb.append("expect \"" + neDetails.getUserPrompt() + "\" \n");
					}
					// sb.append("expect \"" + scriptEntity.getPrompt().replace("enbname",
					// neName).replace("enbId", neId)
					// + "\"" + " \n");
					// sb.append("\n");
					includeConnectingMethodss(sb, neDetails);
					first = false;
				} else {

					if (useCurrPassword == false && neDetails.getServerTypeEntity().getServerType()
							.equalsIgnoreCase(Constants.SANE_SERVERYYPE)) {
						password = sanePassword;
						sUserName = userDetailsEntity.getVpnUserName();
					} else if (useCurrPassword == true && neDetails.getServerTypeEntity().getServerType()
							.equalsIgnoreCase(Constants.SANE_SERVERYYPE)) {
						password = PasswordCrypt.decrypt(userDetailsEntity.getVpnPassword());
						sUserName = userDetailsEntity.getVpnUserName();
					}
					String path = neDetails.getPath();

					String[] pathLst = path.split(",");
					sb.append("send \"ssh -o StrictHostKeyChecking=no -oCheckHostIP=no " + sUserName + "@"
							+ neDetails.getServerIp() + "\\r\" \n");
					// sb.append("interact -o -nobuffer -re $prompt return\n");
					// sb.append("ssh_login \""+password + "\\r\" \n");
					sb.append("expect \"word:\" \n");
					sb.append("send \"" + password + "\\r\"\n\n");
					for (int i = 0; i < 3; i++) {
						sb.append("expect {");
						sb.append("\n");
						sb.append("\"word:\"\n" + "{");
						sb.append("send \"" + password + "\\r\"\n\n");
					}
					sb.append("expect {");
					sb.append("\n");
					sb.append("\"word:\"\n" + "{");
					sb.append("send \"" + "\\x3\\r\"" + "}" + "\n\n");
					sb.append("}");
					sb.append("\n");
					sb.append("expect {");
					for (int i = 0; i < 3; i++) {
						sb.append("\n\"" + neDetails.getUserPrompt() + "\"\n");
						sb.append("{");
						sb.append("send" + " ");
						sb.append("\"" + pathLst[0] + "\\r\"");
						sb.append("}");
						sb.append("\n");
						sb.append("}");
						sb.append("\n");
						sb.append("}");
					}
					sb.append("\n\"" + neDetails.getUserPrompt() + "\"\n");
					sb.append("{");
					sb.append("send" + " ");
					sb.append("\"" + pathLst[0] + "\\r\"");
					sb.append("}");
					sb.append("\n");
					sb.append("}");
					sb.append("\n");

					// sb.append("interact -o -nobuffer -re $prompt return\n");
					if (!neDetails.getServerTypeEntity().getServerType().equalsIgnoreCase(Constants.SANE_SERVERYYPE)) {
						sb.append("expect \"" + neDetails.getUserPrompt() + "\" \n");
					}

					// sb.append("expect \"" + scriptEntity.getPrompt().replace("enbname",
					// neName).replace("enbId", neId)
					// + "\"" + " \n");
					// sb.append("\n");
					includeConnectingMethodss(sb, neDetails);
				}

			}

			// This is for direct lsm
			if (neDetailsLst.isEmpty()) {

				sb.append("#!/usr/bin/expect\n");
				sb.append("set timeout ").append(BASH_EXPECT_TIMEOUT).append("\n");
				sb.append("match_max 100000\n\n");

				/*
				 * sb.append("\n#proc ssh_login pass { \n");
				 * sb.append("#expect \"(yes/no)\" { send \"yes^M \"} \n");
				 * sb.append("#for {set x 0} {$x<3} {incr x} { \n");
				 * sb.append("#expect \"*word:\" { send $pass } \n"); sb.append("#} \n");
				 * sb.append("#expect \"Permission denied (publickey,password).\" {exit}  \n");
				 * sb.append("#sleep ").append(Constants.EXPECT_SLEEP_TIME).append("\n");
				 * sb.append("#} \n");
				 */

				sb.append("spawn ssh -o StrictHostKeyChecking=no -oCheckHostIP=no "
						+ networkConfigEntity.getNeUserName() + "@" + networkConfigEntity.getNeIp() + "\n");
				// sb.append("ssh_login \""+networkConfigEntity.getNePassword() + "\\r\" \n");
				sb.append("expect \"word:\" \n");
				sb.append("send \"" + networkConfigEntity.getNePassword() + "\\r\"\n");

				// sb.append("interact -o -nobuffer -re $prompt return\n");
				// sb.append("expect \"" + scriptEntity.getPrompt().replace("enbname",
				// neName).replace("enbId", neId)
				// + "\"" + " \n");
				sb.append("expect \"" + networkConfigEntity.getNeUserName() + "\" \n");
				sb.append("\n");

				if (scriptEntity.getConnectionLocation() != null
						&& scriptEntity.getConnectionLocation().equalsIgnoreCase(Constants.SM_SERVERYYPE)) {
					if (!useCaseName.contains(Constants.RF_USECASE)
							&& !useCaseName.contains(Constants.COMMISION_USECASE)
							&& !useCaseName.contains(Constants.GROWCELLUSECASE)
							&& !useCaseName.contains(Constants.GROWENBUSECASE)
							&& !useCaseName.contains(Constants.PNPUSECASE) && !useCaseName.contains("AUCaCell")
							&& !useCaseName.contains("AU20B") && !useCaseName.contains("AU20A")
							&& !useCaseName.contains("pnp20AUsecase") && !useCaseName.contains("pnp20BUsecase")
							&& !useCaseName.contains("AU20C") && !useCaseName.contains("pnp20CUsecase")) {

						if (scriptEntity.getConnectionTerminal().equalsIgnoreCase(Constants.CURL_TERMINAL)) {

							/*
							 * sb.append(
							 * "curl -X POST -k -g -6 -u \\\"ais176\\@samsung.com:S\\@msung0ssuser\\\" -H \\'Content-type: application\\/xml\\\' -d \\@'"
							 * ); sb.append(text); sb.append("'"); sb.append(" https:\\/\\/\\[" + mcmaIp +
							 * "\\]:7443\\/oss\\/netconf\\/eNB_" + neId); sb.append("expect \"" //+
							 * scriptEntity.getPrompt().replace("enbname", neName).replace("enbId", neId) +
							 * "\"" + smCurlPrompt.replace("enbname", neName).replace("enbId",
							 * neId).replace("[", "\\\\\\[").replace("]", "\\\\\\]") + "\"" + " \n");
							 * sb.append("\n");
							 */

							/*
							 * sb.append("send \""); sb.
							 * append("curl -X POST -k -g -6 -u \\\"ais176\\@samsung.com:S\\@msung0ssuser\\\" -H \\'Content-type: application\\/xml\\\' -d \\'"
							 * ); sb.append(text); sb.append("\\'");
							 * sb.append(" https://"+mcmaIp+":7443/oss/netconf/eNB_" + neId+"");
							 * sb.append("\\r\"\n\n");
							 */

						}

						else if (scriptEntity.getConnectionTerminal().equalsIgnoreCase(Constants.BASH_TERMINAL)) {

							/*
							 * sb.append("expect \"" //+ scriptEntity.getPrompt().replace("enbname",
							 * neName).replace("enbId", neId) + "\"" + smBashPrompt.replace("enbname",
							 * neName).replace("enbId", neId).replace("[", "\\\\\\[").replace("]",
							 * "\\\\\\]") + "\"" + " \n");
							 */

						} else if (scriptEntity.getConnectionTerminal().equalsIgnoreCase(Constants.CMD_SYS_TERMINAL)) {
							sb.append("expect \""
									// + scriptEntity.getPrompt().replace("enbname", neName).replace("enbId", neId)
									// + "\""
									+ smCmdSysPrompt.replace("enbname", neName).replace("enbId", neId)
											.replace("[", "\\\\\\[").replace("]", "\\\\\\]")
									+ "\"" + " \n");
						} else if (scriptEntity.getConnectionTerminal().equalsIgnoreCase(Constants.CMDX_TERMINAL)) {
							sb.append("expect \""
									// + scriptEntity.getPrompt().replace("enbname", neName).replace("enbId", neId)
									// + "\""
									+ smCmdxPrompt.replace("enbname", neName).replace("enbId", neId)
											.replace("[", "\\\\\\[").replace("]", "\\\\\\]")
									+ "\"" + " \n");
						}
					}

				} else if (scriptEntity.getConnectionLocation() != null
						&& scriptEntity.getConnectionLocation().equalsIgnoreCase(Constants.NE_SERVERYYPE)) {

					sb.append("send \"ssh -o StrictHostKeyChecking=no -oCheckHostIP=no "
							// + scriptEntity.getConnectionLocationUserName() + "@" + eNBIp + "\\r\" \n");
							+ neConnectionLocationUserName + "@" + eNBIp + "\\r\" \n");
					// sb.append("interact -o -nobuffer -re $prompt return\n");
					// sb.append("ssh_login
					// \""+PasswordCrypt.decrypt(scriptEntity.getConnectionLocationPwd()) + "\\r\"
					// \n");
					// sb.append("ssh_login \""+neConnectionLocationPwd + "\\r\" \n");
					sb.append("expect \"word:\" \n");
					sb.append("send \"" + neConnectionLocationPwd + "\\r\"\n");
					// sb.append("interact -o -nobuffer -re $prompt return\n");
					// sb.append("expect \"" + scriptEntity.getPrompt().replace("enbname",
					// neName).replace("enbId", neId)
					// + "\"" + " \n\n");
					sb.append("expect \"" + neConnectionLocationUserName + "\" \n");
					if (!Constants.NE_TYPE_CSR.equalsIgnoreCase(neType)
							&& !Constants.NE_TYPE_BSM.equalsIgnoreCase(neType)) {
						// root login
						sb.append("\nsend \"" + Constants.ENB_SUDO_EXPECT + " \\r\" \n");
						sb.append("expect \"word*\" \n");
						sb.append("send \"" + neSudoPwd + "\\r\" \n");
						sb.append("expect \"root\" \n\n");
					}

					if (!useCaseName.contains(Constants.RF_USECASE)
							&& !useCaseName.contains(Constants.COMMISION_USECASE)
							&& !useCaseName.contains(Constants.GROWCELLUSECASE)
							&& !useCaseName.contains(Constants.GROWENBUSECASE)
							&& !useCaseName.contains(Constants.PNPUSECASE) && !useCaseName.contains("AUCaCell")
							&& !useCaseName.contains("AU20B") && !useCaseName.contains("AU20A")
							&& !useCaseName.contains("pnp20AUsecase") && !useCaseName.contains("pnp20BUsecase")
							&& !useCaseName.contains("AU20C") && !useCaseName.contains("pnp20CUsecase")) {
						if (scriptEntity.getConnectionTerminal().equalsIgnoreCase(Constants.CONFDCLI_TERMINAL)) {
							sb.append("send \"confd_cli -u vsmuser\\r\"\n");
							/*
							 * sb.append( //"send \"confd_cli -u " +
							 * scriptEntity.getConnectionTerminalUserName() + "\\r\" \n");
							 * "send \"confd_cli -u " + neConfidCLIConnectionTerminalUserName + "\\r\" \n");
							 */
							// sb.append("interact -o -nobuffer -re $prompt return\n");
							// sb.append("expect \"" + scriptEntity.getConnectionTerminalUserName() + "\\r\"
							// \n");
							// sb.append("expect \"" + neConfidCLIConnectionTerminalUserName + "\\r\" \n");
							/*
							 * sb.append("expect \"" //+ scriptEntity.getPrompt().replace("enbname",
							 * neName).replace("enbId", neId) + "\"" + neConfdCLIPrompt.replace("enbname",
							 * neName).replace("enbId", neId).replace("[", "\\\\\\[").replace("]",
							 * "\\\\\\]") + "\"" + " \n");
							 */

						} else if (scriptEntity.getConnectionTerminal().equalsIgnoreCase(Constants.BASH_TERMINAL)) {
							/*
							 * sb.append("expect \"" //+ scriptEntity.getPrompt().replace("enbname",
							 * neName).replace("enbId", neId) + "\"" + neBashPrompt.replace("enbname",
							 * neName).replace("enbId", neId).replace("[", "\\\\\\[").replace("]",
							 * "\\\\\\]") + "\"" + " \n");
							 */
						} else if (scriptEntity.getConnectionTerminal().equalsIgnoreCase(Constants.CLI_TERMINAL)) {
							// sb.append("expect \"root\" \n");

							/*
							 * sb.append("expect \"" //+ scriptEntity.getPrompt().replace("enbname",
							 * neName).replace("enbId", neId) + "\"" + neCLIPrompt.replace("enbname",
							 * neName).replace("enbId", neId).replace("[", "\\\\\\[").replace("]",
							 * "\\\\\\]") + "\"" + " \n");
							 */
						}
					}
				}

			}
			// This is to connect lsm after hopping
			else {

				sb.append("send \"ssh -o StrictHostKeyChecking=no -oCheckHostIP=no "
						+ networkConfigEntity.getNeUserName() + "@" + networkConfigEntity.getNeIp() + "\\r\" \n");
				// sb.append("interact -o -nobuffer -re $prompt return\n");
				// sb.append("ssh_login \""+networkConfigEntity.getNePassword()+ "\\r\" \n");
				sb.append("expect \"word:\" \n");
				sb.append("send \"" + networkConfigEntity.getNePassword() + "\\r\"\n");
				// sb.append("interact -o -nobuffer -re $prompt return\n");
				// sb.append("expect \"" + scriptEntity.getPrompt().replace("enbname",
				// neName).replace("enbId", neId)
				// + "\"" + " \n\n");
				sb.append("expect \"" + networkConfigEntity.getNeUserName() + "\" \n\n");

				if (scriptEntity.getConnectionLocation() != null
						&& scriptEntity.getConnectionLocation().equalsIgnoreCase(Constants.SM_SERVERYYPE)) {
					if (!useCaseName.contains(Constants.RF_USECASE)
							&& !useCaseName.contains(Constants.COMMISION_USECASE)
							&& !useCaseName.contains(Constants.GROWCELLUSECASE)
							&& !useCaseName.contains(Constants.GROWENBUSECASE)
							&& !useCaseName.contains(Constants.PNPUSECASE) && !useCaseName.contains("AUCaCell")
							&& !useCaseName.contains("AU20B") && !useCaseName.contains("AU20A")
							&& !useCaseName.contains("pnp20AUsecase") && !useCaseName.contains("pnp20BUsecase")
							&& !useCaseName.contains("AU20C") && !useCaseName.contains("pnp20CUsecase")) {

						if (scriptEntity.getConnectionTerminal().equalsIgnoreCase(Constants.CURL_TERMINAL)) {

							/*
							 * sb.append(
							 * "curl -X POST -k -g -6 -u \\\"ais176\\@samsung.com:S\\@msung0ssuser\\\" -H \\'Content-type: application\\/xml\\\' -d \\@'"
							 * ); sb.append(text); sb.append("'"); sb.append(" https:\\/\\/\\[" + mcmaIp +
							 * "\\]:7443\\/oss\\/netconf\\/eNB_" + neId); sb.append("expect \"" //+
							 * scriptEntity.getPrompt().replace("enbname", neName).replace("enbId", neId) +
							 * "\"" + smCurlPrompt.replace("enbname", neName).replace("enbId",
							 * neId).replace("[", "\\\\\\[").replace("]", "\\\\\\]") + "\"" + " \n");
							 * sb.append("\n");
							 */

							/*
							 * sb.append("send \""); sb.
							 * append("curl -X POST -k -g -6 -u \\\"ais176\\@samsung.com:S\\@msung0ssuser\\\" -H \\'Content-type: application\\/xml\\\' -d \\'"
							 * ); sb.append(text); sb.append("\\'");
							 * sb.append(" https://"+mcmaIp+":7443/oss/netconf/eNB_" + neId+"");
							 * sb.append("\\r\"\n\n");
							 */

						}

						else if (scriptEntity.getConnectionTerminal().equalsIgnoreCase(Constants.BASH_TERMINAL)) {

							/*
							 * sb.append("expect \"" //+ scriptEntity.getPrompt().replace("enbname",
							 * neName).replace("enbId", neId) + "\"" + smBashPrompt.replace("enbname",
							 * neName).replace("enbId", neId).replace("[", "\\\\\\[").replace("]",
							 * "\\\\\\]") + "\"" + " \n");
							 */

						} else if (scriptEntity.getConnectionTerminal().equalsIgnoreCase(Constants.CMD_SYS_TERMINAL)) {
							sb.append("expect \""
									// + scriptEntity.getPrompt().replace("enbname", neName).replace("enbId", neId)
									// + "\""
									+ smCmdSysPrompt.replace("enbname", neName).replace("enbId", neId)
											.replace("[", "\\\\\\[").replace("]", "\\\\\\]")
									+ "\"" + " \n");
						} else if (scriptEntity.getConnectionTerminal().equalsIgnoreCase(Constants.CMDX_TERMINAL)) {
							sb.append("expect \""
									// + scriptEntity.getPrompt().replace("enbname", neName).replace("enbId", neId)
									// + "\""
									+ smCmdxPrompt.replace("enbname", neName).replace("enbId", neId)
											.replace("[", "\\\\\\[").replace("]", "\\\\\\]")
									+ "\"" + " \n");
						}
					}

				} else if (scriptEntity.getConnectionLocation() != null
						&& scriptEntity.getConnectionLocation().equalsIgnoreCase(Constants.NE_SERVERYYPE)) {
					sb.append("send \"rm -rf .ssh/known_hosts" + "\\r\" \n");
					sb.append("expect \"" + networkConfigEntity.getNeUserName() + "\" \n\n");
					sb.append("send \"ssh -o StrictHostKeyChecking=no -oCheckHostIP=no "
							// + scriptEntity.getConnectionLocationUserName() + "@" + eNBIp + "\\r\" \n");
							+ neConnectionLocationUserName + "@" + eNBIp + "\\r\" \n");
					// sb.append("interact -o -nobuffer -re $prompt return\n");
					// sb.append("ssh_login
					// \""+PasswordCrypt.decrypt(scriptEntity.getConnectionLocationPwd())+ "\\r\"
					// \n");
					// sb.append("ssh_login \""+neConnectionLocationPwd+ "\\r\" \n");
					sb.append("expect \"word:\" \n");
					sb.append("send \"" + neConnectionLocationPwd + "\\r\"\n");
					// sb.append("interact -o -nobuffer -re $prompt return\n");
					// sb.append("expect \"" + scriptEntity.getPrompt().replace("enbname",
					// neName).replace("enbId", neId)
					// + "\"" + " \n\n");
					sb.append("expect \"" + neConnectionLocationUserName + "\" \n\n");

					// root login
					sb.append("\nsend \"" + Constants.ENB_SUDO_EXPECT + " \\r\" \n");
					sb.append("expect \"word*\" \n");
					sb.append("send \"" + neSudoPwd + "\\r\" \n");
					sb.append("expect \"root\" \n \n");

					if (!useCaseName.contains(Constants.RF_USECASE)
							&& !useCaseName.contains(Constants.COMMISION_USECASE)) {
						if (scriptEntity.getConnectionTerminal().equalsIgnoreCase(Constants.CONFDCLI_TERMINAL)) {
							sb.append("send \"confd_cli -u vsmuser\\r\"\n");
							/*
							 * sb.append( //"send \"confd_cli -u " +
							 * scriptEntity.getConnectionTerminalUserName() + "\\r\" \n");
							 * "send \"confd_cli -u " + neConfidCLIConnectionTerminalUserName + "\\r\" \n");
							 */
							// sb.append("interact -o -nobuffer -re $prompt return\n");
							// sb.append("expect \"" + scriptEntity.getConnectionTerminalUserName() + "\\r\"
							// \n");
							/*
							 * sb.append("expect \"" + neConfidCLIConnectionTerminalUserName + "\\r\" \n");
							 * sb.append("expect \"" //+ scriptEntity.getPrompt().replace("enbname",
							 * neName).replace("enbId", neId) + "\"" + neConfdCLIPrompt.replace("enbname",
							 * neName).replace("enbId", neId).replace("[", "\\\\\\[").replace("]",
							 * "\\\\\\]") + "\"" + " \n");
							 */

						} else if (scriptEntity.getConnectionTerminal().equalsIgnoreCase(Constants.BASH_TERMINAL)) {
							/*
							 * sb.append("expect \"" //+ scriptEntity.getPrompt().replace("enbname",
							 * neName).replace("enbId", neId) + "\"" + neBashPrompt.replace("enbname",
							 * neName).replace("enbId", neId).replace("[", "\\\\\\[").replace("]",
							 * "\\\\\\]") + "\"" + " \n");
							 */
						} else if (scriptEntity.getConnectionTerminal().equalsIgnoreCase(Constants.CLI_TERMINAL)) {
							sb.append("expect \""
									// + scriptEntity.getPrompt().replace("enbname", neName).replace("enbId", neId)
									// + "\""
									+ neCLIPrompt.replace("enbname", neName).replace("enbId", neId)
											.replace("[", "\\\\\\[").replace("]", "\\\\\\]")
									+ "\"" + " \n");
						}
					}
				}
			}

		} catch (Exception e) {
			logger.error(
					"Exception buildConnectionScript() in RunTestServiceImpl :" + ExceptionUtils.getFullStackTrace(e));

		}
		return sb;
	}

	private void includeConnectingMethods(StringBuilder sb, NetworkConfigDetailsEntity neDetails) {

		if (neDetails.getPath() != null && neDetails.getPath().length() != 0) {

			String path = neDetails.getPath();

			String[] pathLst = path.split(",");

			if (pathLst.length != 0) {

				for (int i = 0; i < pathLst.length; i++) {
					// sb.append("expect \"$\" \n");
					sb.append("expect \"" + neDetails.getUserPrompt() + "\" \n");
					sb.append("send \"" + pathLst[i] + "\\r\"\n\n");
					// sb.append(pathLst[i]).append(" \n");

				}
				sb.append("expect \"" + neDetails.getSuperUserPrompt() + "\" \n");
				sb.append("\n");
			}
		}
	}

	private void includeConnectingMethodss(StringBuilder sb, NetworkConfigDetailsEntity neDetails) {

		if (neDetails.getPath() != null && neDetails.getPath().length() != 0) {

			String path = neDetails.getPath();

			String[] pathLst = path.split(",");

			if (pathLst.length != 0) {

				for (int i = 1; i < pathLst.length; i++) {
					// sb.append("expect \"$\" \n");
					sb.append("expect \"" + neDetails.getUserPrompt() + "\" \n");
					sb.append("send \"" + pathLst[i] + "\\r\"\n\n");
					// sb.append(pathLst[i]).append(" \n");

				}
				sb.append("expect \"" + neDetails.getSuperUserPrompt() + "\" \n");
				sb.append("\n");
			}
		}
	}

	/**
	 * This method will return bandName for selected ciq and enb
	 * 
	 * @param fileName,enbId,enbName
	 * @return List<CIQDetailsModel>
	 */
	@Override
	public String[] getBandName(String enbId, String ciqFileName, String programId) {

		String dbcollectionFileName = CommonUtil.createMongoDbFileName(programId, ciqFileName);
		List<CIQDetailsModel> resultList = getCIQDetailsModelList(enbId, dbcollectionFileName);
		String[] bandNames = getColumnValuesBySheet(resultList, Constants.VZ_GROW_BandName);
		if (!CommonUtil.isValidObject(bandNames)) {
			bandNames = getColumnValuesBySheet(resultList, Constants.RAN_ATP_BAND_NAME);
		}
		return bandNames;
	}

	public List<CIQDetailsModel> getCIQDetailsModelList(String enbId, String dbcollectionFileName) {
		List<CIQDetailsModel> resultList = null;
		Query query = new Query();
		query.addCriteria(Criteria.where("eNBId").is(enbId));
		try {
			resultList = mongoTemplate.find(query, CIQDetailsModel.class, dbcollectionFileName);

		} catch (Exception e) {
			logger.error(
					"Exception getCIQDetailsModelList() in RunTestServiceImpl :" + ExceptionUtils.getFullStackTrace(e));

		}
		return resultList;
	}

	public String[] getColumnValuesBySheet(List<CIQDetailsModel> listCIQDetailsModel, String column) {

		String[] result = null;

		try {
			Set<String> objCellIdList = listCIQDetailsModel.stream().filter(X -> X.getCiqMap().containsKey(column))
					.map(X -> X.getCiqMap().get(column).getHeaderValue()).collect(Collectors.toSet());
			if (objCellIdList != null && !objCellIdList.isEmpty()) {
				result = new String[objCellIdList.size()];

				result = objCellIdList.toArray(result);
			}
		} catch (Exception e) {
			logger.error(
					"Exception getColumnValuesBySheet() in RunTestServiceImpl :" + ExceptionUtils.getFullStackTrace(e));
		}

		return result;

	}

	public String getEnbOamIp(List<CIQDetailsModel> listCIQDetailsModel) {
		List<Integer> objVlan = listCIQDetailsModel.stream()
				.filter(x -> x.getSheetAliasName().equals(Constants.VZ_GROW_IPPLAN))
				.map(x -> Integer.valueOf(x.getCiqMap().get(Constants.RAN_ATP_eNB_OAM_VLAN).getHeaderValue()))
				.distinct().collect(Collectors.toList());

		if (!objVlan.isEmpty()) {
			String vlan1 = objVlan.get(0).toString();
			String vlan2 = objVlan.get(1).toString();

			String oamVlan;

			if (vlan1.startsWith("4")) {
				oamVlan = vlan1;
			} else {
				oamVlan = vlan2;
			}

			return listCIQDetailsModel.stream()
					.filter(x -> x.getSheetAliasName().equals(Constants.VZ_GROW_IPPLAN)
							&& x.getCiqMap().get(Constants.VZ_GROW_eNB_OAM_VLAN).getHeaderValue().equals(oamVlan))
					.map(x -> x.getCiqMap().get(Constants.VZ_GROW_eNB_OAM_IP_eNB_SB_IP).getHeaderValue()).distinct()
					.collect(Collectors.joining(""));
		} else {
			return null;
		}

	}

	// function to sort hashmap by values
	public static HashMap<String, Integer> sortByValue(HashMap<String, Integer> hm) {
		// Create a list from elements of HashMap
		List<Map.Entry<String, Integer>> list = new LinkedList<>(hm.entrySet());

		// Sort the list
		Collections.sort(list, new Comparator<Map.Entry<String, Integer>>() {
			public int compare(Map.Entry<String, Integer> o1, Map.Entry<String, Integer> o2) {
				return (o1.getValue()).compareTo(o2.getValue());
			}
		});

		// put data from sorted list to hashmap
		HashMap<String, Integer> temp = new LinkedHashMap<>();
		for (Map.Entry<String, Integer> aa : list) {
			temp.put(aa.getKey(), aa.getValue());
		}
		return temp;
	}

	@Override
	public Map<String, Object> getRunTestDetails(RunTestModel runTestModel, int page, int count, Integer programId,
			String migrationType, String migrationSubType,boolean wfmKey) {
		Map<String, Object> objMap = new HashMap<String, Object>();
		List<RunTestEntity> runTestDetails = null;
		List<RunTestModel> objRunTestModelList = new ArrayList<>();
		List<WorkFlowManagementEntity> runTestDetailss = null;
		WorkFlowManagementModel runTestModelwfm = new WorkFlowManagementModel();
		AtomicBoolean inprogressStatus = new AtomicBoolean();
		try {
			Map<String, Object> resultMap = runTestRepository.getRunTestDetails(runTestModel, page, count, programId,
					migrationType, migrationSubType,wfmKey);
			if (resultMap != null && resultMap.get("list") != null) {
				runTestDetails = (List<RunTestEntity>) resultMap.get("list");
				if (runTestDetails != null && !runTestDetails.isEmpty()) {
					for (RunTestEntity runTestEntity : runTestDetails) {
						RunTestModel runModel = new RunTestModel();
						runModel.setTestName(runTestEntity.getTestName());
						runModel.setLsmVersion(runTestEntity.getLsmVersion());
						runModel.setLsmName(runTestEntity.getLsmName());
						runModel.setProgressStatus(runTestEntity.getProgressStatus());
						runModel.setStatus(runTestEntity.getStatus());
						runModel.setCiqName(runTestEntity.getCiqName());
						runModel.setNeName(runTestEntity.getNeName());
						runModel.setUseCase(runTestEntity.getUseCase());
						runModel.setId(runTestEntity.getId());
						runModel.setOutputFilepath(runTestEntity.getOutputFilepath());
						runModel.setResult(runTestEntity.getResult());
						runModel.setMigrationType(runTestEntity.getMigrationType());
						runModel.setMigrationSubType(runTestEntity.getMigrationSubType());
						runModel.setChecklistFileName(runTestEntity.getChecklistFileName());
						runModel.setUserName(runTestEntity.getUserName());
						runModel.setMigStatusDesc(runTestEntity.getMigStatusDesc());
						runModel.setOvUpdateStatus(runTestEntity.getOvUpdateStatus());
						runModel.setProgressCount(runTestEntity.getProgressScript());
						runModel.setTotalScript(runTestEntity.getTotalScript());
						runModel.setTotalRFScript(runTestEntity.getTotalRFScript());
						runModel.setTestInfo(runTestEntity.getTestInfo());
						if (runTestEntity.getTestName().contains("WFM")) {
							WorkFlowManagementEntity workFlowManagementEntity = null;
							if ("migration".equalsIgnoreCase(migrationType)
									&& "precheck".equalsIgnoreCase(migrationSubType)) {
								workFlowManagementEntity = workFlowManagementRepository
										.getWFMEntity(runTestEntity.getId(), "migration");
							} else if ("postmigration".equalsIgnoreCase(migrationType)
									&& "AUDIT".equalsIgnoreCase(migrationSubType)) {
								workFlowManagementEntity = workFlowManagementRepository
										.getWFMEntity(runTestEntity.getId(), "audit");
							} else if ("Premigration".equalsIgnoreCase(migrationType)
									&& "NEGrow".equalsIgnoreCase(migrationSubType)) {
								workFlowManagementEntity = workFlowManagementRepository
										.getWFMEntity(runTestEntity.getId(), "negrow");
							} else if ("postmigration".equalsIgnoreCase(migrationType)
									&& "RANATP".equalsIgnoreCase(migrationSubType)) {
								workFlowManagementEntity = workFlowManagementRepository
										.getWFMEntity(runTestEntity.getId(), "ranatp");
							}else if ("Premigration".equalsIgnoreCase(migrationType)
									&& "preaudit".equalsIgnoreCase(migrationSubType)) {
								workFlowManagementEntity = workFlowManagementRepository
										.getWFMEntity(runTestEntity.getId(), "preaudit");
							}else if ("Premigration".equalsIgnoreCase(migrationType)
									&& "nestatus".equalsIgnoreCase(migrationSubType)) {
								workFlowManagementEntity = workFlowManagementRepository
										.getWFMEntity(runTestEntity.getId(), "nestatus");
							}

							if (workFlowManagementEntity != null) {
								runModel.setWfmid(workFlowManagementEntity.getId());
							}
						}
						DateFormat dateFormat = new SimpleDateFormat("yyyy-MM-dd HH:mm:ss");
						String sCreationDate = dateFormat.format(runTestEntity.getCreationDate());
						runModel.setFailedScript(runTestEntity.getFailedScript());
						runModel.setCreationDate(sCreationDate);
						runModel.setTestDescription(runTestEntity.getTestDescription());
						runModel.setResultFilePath(runTestEntity.getResultFilePath());
						runModel.setGenerateScriptPath(runTestEntity.getGenerateScriptPath());
						if (StringUtils.isNotEmpty(runTestEntity.getProgressStatus())
								&& "InProgress".equalsIgnoreCase(runTestEntity.getProgressStatus())) {
							inprogressStatus.getAndSet(true);
						}
						objRunTestModelList.add(runModel);
					}
				}
			}
			objMap.put("list", objRunTestModelList);
			objMap.put("paginationNumber", resultMap.get("paginationNumber"));
			objMap.put("progressStatus", inprogressStatus);
		} catch (Exception e) {
			logger.error("Exception  in RunTestServiceImpl getRunTestDetails():" + ExceptionUtils.getFullStackTrace(e));
		}
		return objMap;
	}

	public String getDependentRuleOr(String elementName, String line, String result,
			DependentRuleValidationModel dependentRuleValidationModel) {
		List<String> list;
		String resultString = dependentRuleValidationModel.getResults();
		String[] inputValue = resultString.split(Pattern.quote("|"));
		list = Arrays.asList(inputValue);

		int stIndex = line.indexOf('<') + elementName.length() + 2;
		int endIndex = line.indexOf("</");
		try {
			String lineValue = "";
			if (StringUtils.isNotEmpty(elementName) && endIndex > stIndex) {
				lineValue = line.substring(stIndex, endIndex);
			} else {
				lineValue = line;
			}
			if (list.contains(lineValue)) {
				result = "YES";
			}
		} catch (NumberFormatException e) {
			result = "NO";
		}
		return result;
	}

	public String checkDependentRule(String elementName, String value, String line, String dbCollectionName,
			String enbId) {
		List<String> list = null;
		String result = "NO";
		try {
			ObjectMapper mapper = new ObjectMapper();

			JsonObject objData = CommonUtil.parseRequestDataToJson(value);

			DependentRuleValidationModel dependentRuleValidationModel = mapper
					.readValue(objData.get("ruleData").toString(), new TypeReference<DependentRuleValidationModel>() {
					});

			if (dependentRuleValidationModel != null) {
				String condition = dependentRuleValidationModel.getCondition();
				if (StringUtils.isNotEmpty(condition)) {
					if ("or".equalsIgnoreCase(condition))

					{
						result = getDependentRuleOr(elementName, line, result, dependentRuleValidationModel);

					} else if ("multilplication".equalsIgnoreCase(condition)) {

						result = getDependentRuleMultiplecation(elementName, line, result, dependentRuleValidationModel,
								dbCollectionName, enbId);

					} /*
						 * else if("startwithenb".equalsIgnoreCase(condition)) { result =
						 * getDependentRuleStartWithEnb(elementName, line, result,
						 * dependentRuleValidationModel, enbId); }
						 */

				}

			}

		} catch (Exception e) {
			logger.error(
					"Exception checkDependentRule() in RunTestServiceImpl :" + ExceptionUtils.getFullStackTrace(e));
		}

		return result;

	}

	public String getDependentRuleMultiplecation(String elementName, String line, String result,
			DependentRuleValidationModel dependentRuleValidationModel, String dbCollectionName, String endId) {
		List<String> list;
		if (StringUtils.isNotEmpty(dependentRuleValidationModel.getMultipleColunms())) {

			List<Double> outputlist = getElementResult(dbCollectionName, endId, dependentRuleValidationModel);
			int stIndex = line.indexOf('<') + elementName.length() + 2;
			int endIndex = line.indexOf("</");
			try {
				String lineValue = "";
				if (StringUtils.isNotEmpty(elementName) && endIndex > stIndex) {
					lineValue = line.substring(stIndex, endIndex);
				} else {
					lineValue = line;
				}

				if (NumberUtils.isNumber(lineValue)) {
					Double givenInput = Double.parseDouble(lineValue);
					long count = outputlist.stream().filter(x -> x.doubleValue() == givenInput.doubleValue()).count();
					if (count > 0) {
						result = "YES";
					}
				}
			} catch (NumberFormatException e) {
				result = "NO";
			}
		}
		return result;
	}

	public List<Double> getElementResult(String dbcollectionFileName, String enbId,
			DependentRuleValidationModel dependentRuleValidationModel) {

		List<CIQDetailsModel> resultList = getCiqDetailsForRuleValidation(enbId, dbcollectionFileName);
		List<Double> outputList = new ArrayList<>();
		try {

			List<String> listValues = getDependentColumnValues(resultList,
					dependentRuleValidationModel.getMultipleColunms());
			if (listValues != null && !listValues.isEmpty()) {
				for (String value : listValues) {

					if (NumberUtils.isNumber(value.trim())
							&& NumberUtils.isNumber(dependentRuleValidationModel.getMultipleBy())) {

						Double resultOutPuts = Double.parseDouble(value)
								* Double.parseDouble(dependentRuleValidationModel.getMultipleBy());
						outputList.add(resultOutPuts);

					}
				}
			}
			/*
			 * if (StringUtils.isNotEmpty(mulColumnValue) &&
			 * NumberUtils.isNumber(mulColumnValue.trim()) &&
			 * NumberUtils.isNumber(dependentRuleValidationModel.getMultipleBy())) results =
			 * Double.parseDouble(mulColumnValue)
			 * Double.parseDouble(dependentRuleValidationModel.getMultipleBy());
			 */
		} catch (Exception e) {
			logger.error("Exception getElementResult() in RunTestServiceImpl :" + ExceptionUtils.getFullStackTrace(e));
		}
		return outputList;
	}

	public List<String> getDependentColumnValues(List<CIQDetailsModel> listCIQDetailsModel, String reqiredColmn) {

		List<String> result = new ArrayList<>();

		try {

			/*
			 * result = listCIQDetailsModel.stream().filter(X ->
			 * X.getCiqMap().containsKey(reqiredColmn)) .map(X ->
			 * X.getCiqMap().get(reqiredColmn).getHeaderValue()).collect(Collectors.toList()
			 * );
			 */

			for (CIQDetailsModel objCIQDetailsModel : listCIQDetailsModel) {

				if (objCIQDetailsModel.getCiqMap().containsKey(reqiredColmn)) {
					result.add(objCIQDetailsModel.getCiqMap().get(reqiredColmn).getHeaderValue());
				}

			}

		} catch (Exception e) {
			logger.error(
					"Exception getColumnValuesBySheet() in RunTestServiceImpl :" + ExceptionUtils.getFullStackTrace(e));
		}

		return result;

	}

	public List<CIQDetailsModel> getCiqDetailsForRuleValidation(String enbId, String dbcollectionFileName) {
		List<CIQDetailsModel> resultList = null;
		Query query = new Query();
		query.addCriteria(Criteria.where("eNBId").is(enbId));
		try {
			resultList = mongoTemplate.find(query, CIQDetailsModel.class, dbcollectionFileName);

		} catch (Exception e) {
			logger.error("Exception getCiqDetailsForRuleValidation() in RunTestServiceImpl :"
					+ ExceptionUtils.getFullStackTrace(e));

		}
		return resultList;
	}

	/*
	 * public String getDependentRuleStartWithEnb(String elementName, String line,
	 * String result, DependentRuleValidationModel
	 * dependentRuleValidationModel,String enbId) { List<String> list; Map<String,
	 * String> inputMap = dependentRuleValidationModel.getStatWithEnbMap();
	 * 
	 * String resultOfOutPut=null; if(inputMap!=null && !inputMap.isEmpty()) {
	 * 
	 * mainLoop: for(Map.Entry<String, String> detailsOfEnbIp:inputMap.entrySet()) {
	 * String[] inputValue=detailsOfEnbIp.getKey().split(Pattern.quote("|"));
	 * for(String dataInput:inputValue) { boolean
	 * statusOfEnb=enbId.startsWith(dataInput); if(statusOfEnb) {
	 * resultOfOutPut=detailsOfEnbIp.getValue(); break mainLoop; } } } }
	 * 
	 * 
	 * 
	 * 
	 * int stIndex = line.indexOf('<') + elementName.length() + 2; int endIndex =
	 * line.indexOf("</"); try { String lineValue = ""; if
	 * (StringUtils.isNotEmpty(elementName) && endIndex > stIndex) { lineValue =
	 * line.substring(stIndex, endIndex); } else { lineValue = line; } if
	 * (StringUtils.isNotEmpty(resultOfOutPut) &&
	 * resultOfOutPut.equalsIgnoreCase(lineValue)) { result = "YES"; } } catch
	 * (NumberFormatException e) { result = "NO"; } return result; }
	 */

	@Override
	public List<Map> getMigrationUseCaseList(int programId, String migrationType, String subType, String ciqFileName,
			List<String> enbId, String programName) {

		List<Map> ucList = null;
		try {

			ucList = runTestRepository.getMigrationUseCaseList(programId, migrationType, subType, ciqFileName, enbId,
					programName);

		} catch (Exception e) {
			logger.error(" getMigrationUseCaseList service : " + ExceptionUtils.getFullStackTrace(e));
		}
		return ucList;

	}

	@Override
	public List<Map> getMigrationUseCaseListWFM(int programId, String migrationType, String subType, String ciqFileName,
			String enbId, String programName) {

		List<Map> ucList = null;
		try {

			ucList = runTestRepository.getMigrationUseCaseListWFM(programId, migrationType, subType, ciqFileName, enbId,
					programName);

		} catch (Exception e) {
			logger.error(" getMigrationUseCaseList service : " + ExceptionUtils.getFullStackTrace(e));
		}
		return ucList;

	}
	
	@Override
	public JSONObject getForceRunTestResult (String status,Integer runId){
		//Map<String, RunTestEntity> runTestEntityMap = new HashMap<>();
		JSONObject result = new JSONObject();
	     boolean status1 = false;
		try {
	
			RunTestEntity existEntity = runTestRepository.getRunTestEntity(runId);
		
	
			existEntity.setStatus(status);
						
			runTestRepository.updateRunTest(existEntity);
			status1 = true;
			result.put("status",status1);
			
		} catch (Exception e) {
			result.put("status",status1);
		}
		return result;
	}
	
	@Override
	public JSONObject getWFMRunTestResult(String status,Integer wfmTestId){
		//Map<String, RunTestEntity> runTestEntityMap = new HashMap<>();
		JSONObject result = new JSONObject();
	     boolean status1 = false;
		try {
	
			WorkFlowManagementEntity existEntity = runTestRepository.getWFMTestEntity(wfmTestId);
		
			
			//existEntity.setStatus(status);
			
			existEntity.setPostMigStatus(status);
			
			
			existEntity.setRemarks("Status is marked complete");
			
			runTestRepository.updateWfhRunTest(existEntity);
			status1 = true;
			result.put("status",status1);
			
		} catch (Exception e) {
			result.put("status",status1);
		}
		return result;
	}

	@Override
	@SuppressWarnings("rawtypes")
	public Map<String, RunTestEntity> getRunTestDetailsMap(JSONObject runTestParams, Integer runTestId) {
		Map<String, RunTestEntity> runTestEntityMap = new HashMap<>();
		try {

			@SuppressWarnings("unchecked")

			String serviceToken = runTestParams.get("serviceToken").toString();
			Map run = (Map) runTestParams.get("runTestFormDetails");
			List<LinkedHashMap> useCaseList = (List) run.get("useCase");
			List<Map> neList = (List<Map>) run.get("neDetails");
			RunTestEntity existEntity = runTestRepository.getRunTestEntity(runTestId);

			for (Map neid : neList) {
				if (existEntity.getNeName().contains(neid.get("neId").toString())) {
					String neName = neid.get("neName").toString();
					String neId = neid.get("neId").toString();

					existEntity.setStatus("InProgress");
					existEntity.setProgressStatus("InProgress");
					runTestRepository.updateRunTest(existEntity);

					runTestEntityMap.put(neId, existEntity);
				}
			}

		}

		catch (Exception e) {
			logger.error(
					"Exception RunTestServiceImpl in insertRunTestDetails() " + ExceptionUtils.getFullStackTrace(e));
		}
		return runTestEntityMap;

	}
	
	@Override
	@SuppressWarnings("rawtypes")
	public Map<String, RunTestEntity> getRunTestDetailsMapOVupdate(JSONObject runTestParams, Integer runTestId) {
		Map<String, RunTestEntity> runTestEntityMap = new HashMap<>();
		try {

			@SuppressWarnings("unchecked")

			String serviceToken = runTestParams.get("serviceToken").toString();
			Map run = (Map) runTestParams.get("runTestFormDetails");
			List<LinkedHashMap> useCaseList = (List) run.get("useCase");
			List<Map> neList = (List<Map>) run.get("neDetails");
			RunTestEntity existEntity = runTestRepository.getRunTestEntity(runTestId);

			for (Map neid : neList) {
				if (existEntity.getNeName().contains(neid.get("neId").toString())) {
					String neName = neid.get("neName").toString();
					String neId = neid.get("neId").toString();

					
					existEntity.setProgressStatus("InProgress");
					existEntity.setOvUpdateStatus("InProgress");
					runTestRepository.updateRunTest(existEntity);

					runTestEntityMap.put(neId, existEntity);
				}
			}

		}

		catch (Exception e) {
			logger.error(
					"Exception RunTestServiceImpl in insertRunTestDetails() " + ExceptionUtils.getFullStackTrace(e));
		}
		return runTestEntityMap;

	}


	@SuppressWarnings("rawtypes")
	public Map<String, RunTestEntity> getRunTestDetailsMapOVupdateforAudit(String neid, Integer runTestId) {
		Map<String, RunTestEntity> runTestEntityMap = new HashMap<>();
		try {

			@SuppressWarnings("unchecked")

			
			RunTestEntity existEntity = runTestRepository.getRunTestEntity(runTestId);

			
				if (existEntity.getNeName().contains(neid)) {
					

					
					existEntity.setProgressStatus("InProgress");
					existEntity.setOvUpdateStatus("InProgress");
					runTestRepository.updateRunTest(existEntity);

					runTestEntityMap.put(neid, existEntity);
				
			}

		}

		catch (Exception e) {
			logger.error(
					"Exception RunTestServiceImpl in insertRunTestDetails() " + ExceptionUtils.getFullStackTrace(e));
		}
		return runTestEntityMap;

	}
	
	@Override
	public JSONObject getInputRuntestJson(int runTestId) {
		JSONObject newJObject = null;
		try {
			RunTestInputEntity runTestInputEntity = runTestRepository.getInputRuntestJson(runTestId);
			if (!ObjectUtils.isEmpty(runTestInputEntity)
					&& StringUtils.isNotEmpty(runTestInputEntity.getRunTestInputJson())) {
				JSONParser parser = new JSONParser();
				newJObject = (JSONObject) parser.parse(runTestInputEntity.getRunTestInputJson());
			}
		} catch (Exception e) {
			logger.error(
					"Exception RunTestServiceImpl in getInputRuntestJson() " + ExceptionUtils.getFullStackTrace(e));
		}
		return newJObject;
	}

	@Override
	public List<String> getBandColumnValuesBySheet(String enbId, String ciqFileName, String programId,
			List<String> bandNamesList) {

		List<String> result = new ArrayList<>();

		try {
			String dbcollectionFileName = CommonUtil.createMongoDbFileName(programId, ciqFileName);
			List<CIQDetailsModel> listCIQDetailsModel = getCIQDetailsModelList(enbId, dbcollectionFileName);

			Map<String, LinkedHashSet<String>> bandMap = new LinkedHashMap<>();
			boolean aws1Status = false;
			boolean aws2Status = false;
			boolean aws3Status = false;
			if (listCIQDetailsModel != null && !listCIQDetailsModel.isEmpty()) {
				for (CIQDetailsModel locCIQDetailsModel : listCIQDetailsModel) {
					if (locCIQDetailsModel.getCiqMap() != null && locCIQDetailsModel.getCiqMap().containsKey("BandName")
							&& locCIQDetailsModel.getCiqMap().containsKey("EARFCN_DL")) {

						String bandName = locCIQDetailsModel.getCiqMap().get("BandName").getHeaderValue();
						if (bandName.contains("MHz") || bandName.contains("LTE")) {
							bandName = bandName.replaceAll("MHz", "").replaceAll("LTE", "");
						}
						if (bandName.contains("AWS-1")) {
							aws1Status = true;
							bandName = "AWS";
						}
						if (bandName.contains("AWS-2")) {
							aws2Status = true;
							bandName = "AWS";
						}
						if (bandName.contains("AWS-3")) {
							aws3Status = true;
							bandName = "AWS";
						}
						if (bandName.contains("PCS")) {
							bandName = "PCS";
						}

						if (bandName.contains("AWS3")) {
							bandName = "AWS3";
						}

						if (bandName.contains("850")) {
							bandName = "850";
						}

						if (bandName.contains("700")) {
							bandName = "700";
						}

						if (bandMap.containsKey(bandName)) {
							LinkedHashSet<String> earfcnData = bandMap.get(bandName);
							earfcnData.add(locCIQDetailsModel.getCiqMap().get("EARFCN_DL").getHeaderValue());
							bandMap.put(bandName, earfcnData);
						} else {
							LinkedHashSet<String> earfcnData = new LinkedHashSet<>();
							earfcnData.add(locCIQDetailsModel.getCiqMap().get("EARFCN_DL").getHeaderValue());
							bandMap.put(bandName, earfcnData);
						}

					}
				}
			}
			for (String locBandName : bandNamesList) {

				LinkedHashSet<String> earfcnDataList = bandMap.get(locBandName);
				if (earfcnDataList != null && earfcnDataList.size() > 1) {
					if (locBandName.contains("AWS-3")) {

						for (int i = 1; i <= earfcnDataList.size(); i++) {
							result.add("AWS-" + i);
						}

					} else if (locBandName.contains("AWS3")) {

						for (int i = 1; i <= earfcnDataList.size(); i++) {

							result.add("AWS3-" + i);

						}

					} /*
						 * else if("PCS".equalsIgnoreCase(locBandName)) { for(int
						 * i=1;i<=earfcnDataList.size();i++) { result.add("PCS-"+i); } }
						 */else if (locBandName.contains("CBRS")) {
						for (int i = 1; i <= earfcnDataList.size(); i++) {
							result.add("48-" + i);
						}
					} else if (locBandName.contains("LAA")) {
						for (int i = 1; i <= earfcnDataList.size(); i++) {
							result.add("46-" + i);
						}

					} else if (locBandName.equalsIgnoreCase("AWS")) {
						for (int i = 1; i <= earfcnDataList.size(); i++) {
							if (i == 1) {
								result.add(locBandName);
							} else {
								result.add(locBandName + "-" + i);
							}

						}

					} else if (locBandName.contains("PCS")) {
						for (int i = 1; i <= earfcnDataList.size(); i++) {
							result.add(locBandName + "-" + i);

						}

					} else if (locBandName.equalsIgnoreCase("AWS") && !aws1Status && aws2Status) {
						for (int i = 2; i <= earfcnDataList.size(); i++) {
							result.add("AWS2-" + i);
						}

					} else {
						for (int i = 1; i <= earfcnDataList.size(); i++) {
							if (i == 1) {
								result.add(locBandName);
							} else {
								result.add(locBandName + "-" + i);
							}
						}

					}
				} else if (earfcnDataList != null && earfcnDataList.size() == 1) {
					if (locBandName.contains("AWS-3")) {
						result.add("AWS");
					} else if (locBandName.contains("AWS3")) {
						result.add("AWS3");
					} else if (locBandName.contains("CBRS")) {
						result.add("48-1");
					} else if (locBandName.contains("LAA")) {
						result.add("46-1");
					} else if (locBandName.equalsIgnoreCase("AWS")) {
						result.add("AWS");
					} else if (locBandName.contains("PCS")) {
						result.add("PCS");
					} else {
						result.add(locBandName);
					}

				}
				// if
			}
			/*
			 * Set<String> objCellIdList = listCIQDetailsModel.stream().filter(X ->
			 * X.getCiqMap().containsKey(column)) .map(X ->
			 * X.getCiqMap().get(column).getHeaderValue()).collect(Collectors.toSet()); if
			 * (objCellIdList != null && !objCellIdList.isEmpty()) { result = new
			 * String[objCellIdList.size()];
			 * 
			 * result = objCellIdList.toArray(result); }
			 */
		} catch (Exception e) {
			logger.error(
					"Exception getColumnValuesBySheet() in RunTestServiceImpl :" + ExceptionUtils.getFullStackTrace(e));
		}

		return result;

	}
	

	private boolean savePreResponse(String neId, StringBuilder required5gOutput, int programId) {
		boolean saveStatus = false;
		try {
			PrePostMapping prePostMapping = new PrePostMapping();
			List<PrePostMapping> auditPrePostDetailsEntityList = prePostRepo.getAuditPrePostEntity(neId,programId);
			/*prePostMapping.setNeId(neId);
			prePostMapping.setOutPut(required5gOutput.toString());
			prePostMapping.setProgramId(programId);*/
			//prePostRepo.savePrePostDeatil(prePostMapping);
			if(auditPrePostDetailsEntityList!=null && !auditPrePostDetailsEntityList.isEmpty()) {
				prePostMapping = auditPrePostDetailsEntityList.get(0);
				prePostMapping.setOutPut(required5gOutput.toString());
				prePostRepo.savePrePostDeatil(prePostMapping);
				saveStatus=true;
			} else {
				prePostMapping.setNeId(neId);
				prePostMapping.setOutPut(required5gOutput.toString());
				prePostMapping.setProgramId(programId);
				prePostRepo.savePrePostDeatil(prePostMapping);
				saveStatus=true;
			}
			
		} catch (Exception e) {
			logger.error("Exception RunTestServiceImpl in savePreResponse() " + ExceptionUtils.getFullStackTrace(e));
		}
		return saveStatus;

	}

	@Override
	public JSONObject getRuntestExecResult5GDSSPrepost(JSONObject runTestParams, Map<String, RunTestEntity> runTestEntityMap,
			String runType, String htmlOutputFileName, Map<String, Object> reRunDetails, boolean rfScriptsFlag, Map<String, Object> auditoutput, Map<String, RunTestEntity> runTestEntityMap1)
			throws RctException {
		JSONObject dssResult = new JSONObject();
		Map run = (Map) runTestParams.get("runTestFormDetails");
		String testname = run.get("testname").toString();

		List<Map> scriptSeqDetails = (List<Map>) run.get("scripts");
		List<Map> neList = (List<Map>) run.get("neDetails");
		List<LinkedHashMap> useCaseList = (List) run.get("useCase");
		int programId = Integer.parseInt(runTestParams.get("programId").toString());

		boolean useCurrPassword = (boolean) run.get("currentPassword");
		String serviceToken = runTestParams.get("serviceToken").toString();
		String sanePassword = run.get("password").toString();
		String migType = runTestParams.get("migrationType").toString();
		String migSubType = runTestParams.get("migrationSubType").toString();
		String userName = runTestParams.get("userName").toString();
		String checklistFileName = run.get("checklistFileName").toString();
		String ciqFileName = run.get("ciqName").toString();
		String sProgramId = runTestParams.get("programId").toString();
		String remarks = run.get("testDesc").toString();
		String sessionId = runTestParams.get("sessionId").toString();
		CustomerDetailsEntity customerDetailsEntity = getCustomerDetailsEntity(programId);
		AtomicBoolean totalTestCompleted = new AtomicBoolean();
		AtomicBoolean isMultipleDUo = new AtomicBoolean();
		isMultipleDUo.set(false);
		if(run.containsKey("multipleDuo")) {
		boolean duo1234 = (boolean) run.get("multipleDuo");
		if(duo1234==true) {
			isMultipleDUo.set(true);
		}}
		// rssi
		List<String> newRadios = (List<String>) run.get("radioUnits");

		try {
			ExecutorService executorservice = Executors.newFixedThreadPool(neList.size());
			for (Map usecase : useCaseList) {
				Integer useCaseId = Integer.valueOf(usecase.get("useCaseId").toString());
				runTestRepository.updateUseCountForUseCase(useCaseId, Constants.USECOUNT_INCREMENT, neList.size());
			}
			for (Map neid : neList) {

				executorservice.submit(() -> {
					LocalDateTime l1 = LocalDateTime.now();
					Map<String, String> scriptFilesDetails = new HashMap<>();
					StringBuilder auditHtmlFilePath = new StringBuilder();
					StringBuilder auditHtmlFileName = new StringBuilder();
					NetworkConfigEntity neMappingEntitiesForVersion = null;
					ReportsEntity reportsEntity = null;

					String neId = neid.get("neId").toString();
					String neName = neid.get("neName").toString();
					logger.error("Started the thread for NE " + neId + " at : " + l1);
					String threadname = "RT_" + runTestEntityMap.get(neId).getId();
					Thread.currentThread().setName(threadname);
					runTestEntityMap.get(neId).setruntestThreadName(threadname);
					runTestRepository.updateRunTest(runTestEntityMap.get(neId));

					UserDetailsEntity userDetailsEntity2 = userActionRepositoryImpl.getUserDetailsBasedName(userName);
					if (GlobalStatusMap.userNeQueue.contains(userDetailsEntity2.getVpnUserName())) {
						GlobalStatusMap.userNeQueue.get(userDetailsEntity2.getVpnUserName()).add(neId);
					} else {
						GlobalStatusMap.userNeQueue.put(userDetailsEntity2.getVpnUserName(),
								new ConcurrentLinkedQueue<>());
						GlobalStatusMap.userNeQueue.get(userDetailsEntity2.getVpnUserName()).add(neId);
					}

					int lsmId = 0;
					String lsmName = run.get("lsmName").toString();
					String lsmVersion = run.get("lsmVersion").toString();

					if (!run.get("lsmId").toString().isEmpty()) {
						lsmId = Integer.parseInt(run.get("lsmId").toString());
					}
					if (lsmVersion.isEmpty() || lsmName.isEmpty()) {
						NeMappingModel neMappingModelversion = new NeMappingModel();
						CustomerDetailsEntity programDetailsEntityversion = new CustomerDetailsEntity();
						programDetailsEntityversion.setId(programId);
						neMappingModelversion.setProgramDetailsEntity(programDetailsEntityversion);
						neMappingModelversion.setEnbId(neId);
						neMappingEntitiesForVersion = runTestRepository.getNetWorkEntityDetails(neMappingModelversion);
						lsmId = neMappingEntitiesForVersion.getId();
						lsmVersion = neMappingEntitiesForVersion.getNeVersionEntity().getNeVersion();
						lsmName = neMappingEntitiesForVersion.getNeName();

					}
					NetworkConfigEntity networkConfigEntity = runTestRepository.getNeType(lsmId);

					NetworkConfigEntity neEntity = uploadFileServiceImpl.getNeEntity(lsmVersion, lsmName, programId);

					String migrationType = null;
					String migrationSubType = null;

					if (migType.equalsIgnoreCase(Constants.MIGRATION)) {
						migrationType = "Migration";
					} else if (migType.equalsIgnoreCase(Constants.POST_MIGRATION)) {
						migrationType = "PostMigration";
					}

					if ("precheck".equalsIgnoreCase(migSubType)) {
						migrationSubType = "PreCheck";
					} else if ("commission".equalsIgnoreCase(migSubType)) {
						migrationSubType = "Commission";
					} else if ("postcheck".equalsIgnoreCase(migSubType)) {
						migrationSubType = "PostCheck";
					} else if ("AUDIT".equalsIgnoreCase(migSubType)) {
						migrationSubType = "Audit";
					} else if ("RANATP".equalsIgnoreCase(migSubType)) {
						migrationSubType = "RanATP";
					}
					String generateScriptPath = "";

					try {
						StringBuilder required5GOutput = new StringBuilder();
						StringBuilder required5GOutputEnb = new StringBuilder();

						// PrePostStart
						boolean deleteStatusOfPrePost = false;
						List<PrePostMapping> auditPrePostDetailsEntityList = prePostRepo.getAuditPrePostEntity(neId,programId);
						
						if (!ObjectUtils.isEmpty(auditPrePostDetailsEntityList)) {
							String prePostrequired5GOutput = auditPrePostDetailsEntityList.get(auditPrePostDetailsEntityList.size()-1).getOutPut();
							required5GOutput.append(prePostrequired5GOutput.toString());
						}
						if (!ObjectUtils.isEmpty(auditPrePostDetailsEntityList)) {
							deleteStatusOfPrePost = prePostRepo.deletePrePostDeatil(neId,programId);
						}
						logger.error("deleteStatusOfPrePost: " + deleteStatusOfPrePost);
						// prePostEnds

						LinkedHashMap<String, Set<XmlElementEntity>> elementrulesMap = new LinkedHashMap<>();
						// generate script path
						StringBuilder generatedPath = new StringBuilder();
						generatedPath = generatedPath.append(LoadPropertyFiles.getInstance().getProperty("BASE_PATH"));
						generatedPath.append(Constants.CUSTOMER)
								.append(Constants.GENERATE_SCRIPT.replace("programId", sProgramId)
										.replace("migrationType", migrationType).replace("neId", neId)
										.replace("subType", migrationSubType));

						String finalStatusResult = "Success";
						int iUseCaseId = 0;
						Map<String, String> generateScriptMap = new HashMap<>();
						Map<String, String> scriptNameMap = new HashMap<>();
						if (scriptSeqDetails != null) {

							for (Map scriptInfoDetails : scriptSeqDetails) {
								String useGeneratedScriptsCheck = scriptInfoDetails.get("useGeneratedScript")
										.toString();
								String sScriptName = scriptInfoDetails.get("scriptName").toString();
								String useCaseNameInScript = scriptInfoDetails.get("useCaseName").toString();
								generateScriptMap.put(useCaseNameInScript + "_" + sScriptName,
										useGeneratedScriptsCheck);
								scriptNameMap.put(useCaseNameInScript + "_" + sScriptName, sScriptName);
							}
						}

						ArrayList scriptFinalLst = null;

						// Use case loop
						TreeSet<String> finalListFile = new TreeSet<>();
						scriptFinalLst = new ArrayList<ArrayList>();

						for (Map usecase : useCaseList) {
							Integer useCaseExeSeq = Integer.valueOf(usecase.get("executionSequence").toString());
							String useCaseName = (String) usecase.get("useCaseName");
							iUseCaseId = Integer.valueOf(usecase.get("useCaseId").toString());
							List<UseCaseBuilderParamEntity> scriptDetails = runTestRepository
									.getScriptDetails(iUseCaseId);

							Map<Integer, Integer> scriptIdAndSeqmap = new HashMap<>();
							for (UseCaseBuilderParamEntity scriptInfo : scriptDetails) {
								List scriptLst = new ArrayList<>();
								Integer scriptId = scriptInfo.getScriptsDetails().getId();

								int scriptUiExeSeq = getScriptExeSeq(scriptSeqDetails, scriptId);

								Integer scriptExeSeq = scriptUiExeSeq;

								Integer uploadedscriptId = scriptInfo.getId();
								if (scriptExeSeq != 0) {

									scriptLst.add(scriptId);
									scriptLst.add(scriptExeSeq);
									scriptLst.add(uploadedscriptId);
									scriptFinalLst.add(scriptLst);
									scriptIdAndSeqmap.put(scriptId, scriptExeSeq);

								}
							}

							// Script loop
							for (UseCaseBuilderParamEntity scriptEntity : scriptDetails) {

								Integer scriptId = scriptEntity.getScriptsDetails().getId();
								int scriptUiExeSeq = getScriptExeSeq(scriptSeqDetails, scriptId);
								Integer scriptExeSeq1 = scriptUiExeSeq;

								if (scriptExeSeq1 != 0) {
									int scriptExeSeq = scriptIdAndSeqmap.get(scriptId);

									// int scriptExeSeq = scriptEntity.getExecutionSequence();

									UploadFileEntity uploadFileEntity = runTestRepository.getScriptInfo(scriptId);

									String dbcollectionFileName = CommonUtil
											.createMongoDbFileName(String.valueOf(programId), ciqFileName);
									String vznEnbIP = fileUploadRepository.getEnBDataByPath(dbcollectionFileName,
											Constants.VZ_GROW_IPPLAN, neId,
											Constants.ORAN_SPRINT_COMM_SCRIPT_eNB_OAM_IP_eNB_S_B_IP);
									String eNB_OAM_IP = fileUploadRepository.getEnBDataByPath(dbcollectionFileName,
											Constants.SPT_GROW_SHEET_FDD_TDD, neId,
											Constants.ORAN_SPRINT_COMM_SCRIPT_8_CHG_IP_ADDR);

									String enbIP = "127.0.0.1";

									if (StringUtils.isNotEmpty(vznEnbIP)) {
										enbIP = vznEnbIP;
									} else if (StringUtils.isNotEmpty(eNB_OAM_IP)) {
										String sprintEnbIP = CommonUtil.getLeftSubStringWithLen(eNB_OAM_IP, 3);
										if (StringUtils.isNotEmpty(sprintEnbIP)) {
											enbIP = sprintEnbIP;
										} else {
											enbIP = eNB_OAM_IP;
										}
									}

									String CSR_OAM_IP = fileUploadRepository.getEnBDataByPath(dbcollectionFileName,
											Constants.SPT_GROW_SHEET_FDD_TDD, neId,
											Constants.ORAN_SPRINT_COMM_SCRIPT_9_CSR_OAM_IP);

									NeMappingModel neMappingModel = new NeMappingModel();
									CustomerDetailsEntity programDetailsEntity = new CustomerDetailsEntity();
									programDetailsEntity.setId(programId);
									neMappingModel.setProgramDetailsEntity(programDetailsEntity);
									neMappingModel.setEnbId(neId);
									List<NeMappingEntity> neMappingEntities = neMappingService
											.getNeMapping(neMappingModel);

									String neType = Constants.NE_TYPE_ENB;
									if (uploadFileEntity.getFileName().contains(Constants.PRECHECK_CSR_FILE_NAME)
											|| uploadFileEntity.getFileName()
													.contains(Constants.POSTCHECK_CSR_FILE_NAME)) {
										enbIP = CommonUtil.getLeftSubStringWithLen(CSR_OAM_IP, 3);
										neType = Constants.NE_TYPE_CSR;
									} else if (uploadFileEntity.getFileName().contains(Constants.PRECHECK_BSM_FILE_NAME)
											|| uploadFileEntity.getFileName()
													.contains(Constants.POSTCHECK_BSM_FILE_NAME)) {
										enbIP = neMappingEntities.get(0).getBsmIp();
										neType = Constants.NE_TYPE_BSM;
									}

									/*
									 * enbIP = fileUploadRepository.getEnBDataByPath(ciqPgmIdAndCiqName, "IPPLAN",
									 * neId,"eNB_OAM_IP&eNB_S&B_IP");
									 */
									String useGeneratedScriptsCheck = generateScriptMap
											.get(useCaseName + "_" + uploadFileEntity.getFileName());

									String[] scriptNameSplit = uploadFileEntity.getFileName().split("\\.");
									String checkLsmName = null;
									if (useGeneratedScriptsCheck != null
											&& "YES".equalsIgnoreCase(useGeneratedScriptsCheck.trim())) {
										File folder = new File(generatedPath.toString());
										if (!folder.exists()) {
											FileUtil.createDirectory(generatedPath.toString());
										}

										File[] listOfFiles = folder.listFiles();
										ArrayList<String> listOfFile = new ArrayList<>();
										if (listOfFiles.length > 0) {
											for (File file : listOfFiles) {
												listOfFile.add(file.getName());
											}

											String sLsmName = lsmName;
											String sUseCaseName = useCaseName;

											if (sLsmName.contains("_")) {
												sLsmName = charRemoveAt(sLsmName);
											}

											if (sUseCaseName.contains("_")) {
												sUseCaseName = charRemoveAt(sUseCaseName);
											}

											if (scriptNameSplit[0].contains("_")) {
												scriptNameSplit[0] = charRemoveAt(scriptNameSplit[0]);
											}

											sLsmName = sLsmName.replaceAll("\\s", "");
											sUseCaseName = sUseCaseName.replaceAll("\\s", "");
											scriptNameSplit[0] = scriptNameSplit[0].replaceAll("\\s", "");
											useCaseName = useCaseName.trim().replaceAll("\\s", "_");

											String filePathwithName = scriptExeSeq + "_" + sLsmName + "_" + sUseCaseName
													+ "_" + iUseCaseId + "_" + scriptNameSplit[0] + "_" + scriptId + "."
													+ scriptNameSplit[1];
											if (listOfFile.contains(filePathwithName)) {
												// do nothing
											} else {
												generateScriptWithOutExe5GAudit(neId, neName, sProgramId, migrationType,
														migrationSubType, uploadFileEntity, enbIP, neEntity,
														useCaseName, sessionId, lsmName, iUseCaseId, useCaseExeSeq,
														scriptId, scriptExeSeq, lsmId, useCurrPassword, sanePassword,
														userName, lsmVersion, ciqFileName, neType);
											}

										} else {
											generateScriptWithOutExe5GAudit(neId, neName, sProgramId, migrationType,
													migrationSubType, uploadFileEntity, enbIP, neEntity, useCaseName,
													sessionId, lsmName, iUseCaseId, useCaseExeSeq, scriptId,
													scriptExeSeq, lsmId, useCurrPassword, sanePassword, userName,
													lsmVersion, ciqFileName, neType);
										}

									} else {
										generateScriptWithOutExe5GAudit(neId, neName, sProgramId, migrationType,
												migrationSubType, uploadFileEntity, enbIP, neEntity, useCaseName,
												sessionId, lsmName, iUseCaseId, useCaseExeSeq, scriptId, scriptExeSeq,
												lsmId, useCurrPassword, sanePassword, userName, lsmVersion, ciqFileName,
												neType);
									}

									checkLsmName = lsmName;

									if (checkLsmName.contains("_")) {
										checkLsmName = charRemoveAt(checkLsmName);
									}

									checkLsmName = checkLsmName.replaceAll("\\s", "");

									File folder = new File(generatedPath.toString());
									File[] listOfFiles = folder.listFiles();

									if (listOfFiles.length > 0) {
										for (File file : listOfFiles) {
											String fileName = file.getName();
											if (fileName.contains(checkLsmName)
													&& fileName.contains(Integer.toString(iUseCaseId))
													&& fileName.contains(Integer.toString(scriptId))
													&& fileName.contains(Integer.toString(scriptExeSeq))) {
												finalListFile.add(fileName);
											} else {
												// do nothing
											}
										}
									}

								} else {
									// do nothing
								}
							}
						}

						Map<Integer, String> scriptExehashMap = new HashMap<>();

						for (String fileName : finalListFile) {

							String[] scriptExeSeq = fileName.split("_");
							int iScriptExeSeq = Integer.parseInt(scriptExeSeq[0]);

							scriptExehashMap.put(iScriptExeSeq, fileName);

						}

						Map<Integer, String> scriptexeSortedByExeSeqMap = scriptExehashMap.entrySet().stream()
								.sorted(Map.Entry.comparingByKey()).collect(Collectors.toMap(Map.Entry::getKey,
										Map.Entry::getValue, (e1, e2) -> e1, LinkedHashMap::new));

						// updating runTestEntity to update the generated script path before running the
						// run test
						mainloop1: for (Entry<Integer, String> file : scriptexeSortedByExeSeqMap.entrySet()) {
							String orderFileName = file.getValue();
							String fileNameWithPath = generatedPath.toString() + "/" + orderFileName;
							String filePathWithRunTestId = generatedPath.toString()
									+ runTestEntityMap.get(neId).getId();
							File dir = new File(filePathWithRunTestId);
							if (!dir.exists()) {
								FileUtil.createDirectory(filePathWithRunTestId);
							}
							FileUtils.copyFileToDirectory(new File(fileNameWithPath), dir);
							String filePath = filePathWithRunTestId.toString() + "/" + orderFileName;
							generateScriptPath = generateScriptPath
									+ filePath.replace(LoadPropertyFiles.getInstance().getProperty("BASE_PATH"), "")
									+ ",";

							if (StringUtils.isNotEmpty(generateScriptPath)) {
								runTestEntityMap.get(neId).setGenerateScriptPath(
										generateScriptPath.substring(0, generateScriptPath.length() - 1));
								runTestRepository.updateRunTest(runTestEntityMap.get(neId));
							}
						}
						// performance increasing
						Map<String, Boolean> createHtmlMapboo = new HashMap<>();
						AtomicBoolean sanePasswordBoo = new AtomicBoolean();
						sanePasswordBoo.set(true);
						// New Implementation: Nov-04-2020 : Audit HtmlName
						StringBuilder auditname = new StringBuilder();
						mainloop1: for (Entry<Integer, String> file : scriptexeSortedByExeSeqMap.entrySet()) {
							// Duration by tool
							LocalDateTime lshtool1 = LocalDateTime.now();
							long dshsec = 0;
							// swetha
							String orderFileName = file.getValue();

							// for (String orderFileName : finalListFile) {

							String fileNameWithPath = generatedPath.toString() + "/" + orderFileName;
							String dbcollectionFileName = CommonUtil.createMongoDbFileName(String.valueOf(programId),
									ciqFileName);
							String vznEnbIP = fileUploadRepository.getEnBDataByPath(dbcollectionFileName,
									Constants.VZ_GROW_IPPLAN, neId,
									Constants.ORAN_SPRINT_COMM_SCRIPT_eNB_OAM_IP_eNB_S_B_IP);
							String eNB_OAM_IP = fileUploadRepository.getEnBDataByPath(dbcollectionFileName,
									Constants.SPT_GROW_SHEET_FDD_TDD, neId,
									Constants.ORAN_SPRINT_COMM_SCRIPT_8_CHG_IP_ADDR);
							String enbIP = "127.0.0.1";

							if (StringUtils.isNotEmpty(vznEnbIP)) {
								enbIP = vznEnbIP;
							} else if (StringUtils.isNotEmpty(eNB_OAM_IP)) {
								String sprintEnbIP = CommonUtil.getLeftSubStringWithLen(eNB_OAM_IP, 3);
								if (StringUtils.isNotEmpty(sprintEnbIP)) {
									enbIP = sprintEnbIP;
								} else {
									enbIP = eNB_OAM_IP;
								}
							}

							String output = "";
							String shelloutput = "";
							String outputFileName = "";
							String outputFileNameAudit = "";
							StringBuilder newOutputFileDBPath = new StringBuilder();
							StringBuilder newOutputFilePath = new StringBuilder();

							String[] useCaseNameSplit = orderFileName.split("_");
							int iScriptExeSeq = Integer.parseInt(useCaseNameSplit[0]);
							String useCaseName = useCaseNameSplit[2];
							int scriptId = Integer.parseInt(useCaseNameSplit[5].split("\\.")[0]);
							String descFinalPath = "";
							String scriptFileName = useCaseNameSplit[4];
							iUseCaseId = Integer.parseInt(useCaseNameSplit[3]);

							UseCaseBuilderEntity useCaseBuilderEntity = runTestRepository.getUseCaseEntity(iUseCaseId);
							String originalUseCaseName = useCaseBuilderEntity.getUseCaseName();

							UploadFileEntity scriptEntity = runTestRepository.getScriptInfo(scriptId);

							/// not included
							// swetha
							String scriptAbsFileName = LoadPropertyFiles.getInstance().getProperty("BASE_PATH")
									+ scriptEntity.getFilePath() + "/" + originalUseCaseName.trim().replaceAll(" ", "_")
									+ "/" + scriptEntity.getFileName();

							scriptFilesDetails.put(scriptAbsFileName, scriptEntity.getPrompt());

							StringBuilder outputFilePath = new StringBuilder();

							StringBuilder comFilePath = new StringBuilder();
							String scriptArguments = scriptEntity.getArguments();

							// Template changes starts
							String connectionLocationUserName = null;
							String connectionLocationPwd = "";
							String connectionSudoPassword = "";

							ProgramTemplateEntity programTemplateEntity = fileUploadRepository
									.getProgramTemplate(programId, Constants.SCRIPT_STORE_TEMPLATE);
							if (programTemplateEntity != null) {
								if (programTemplateEntity.getValue() != null
										&& !programTemplateEntity.getValue().trim().isEmpty()) {
									JSONObject objData = CommonUtil.parseDataToJSON(programTemplateEntity.getValue());
									HashMap connLocation = (HashMap) objData.get("connLocation");

									// NE
									HashMap ne = (HashMap) connLocation.get("NE");
									connectionSudoPassword = ne.get("sudoPassword").toString();
									connectionLocationUserName = ne.get("username").toString();
									connectionLocationPwd = ne.get("password").toString();

								}
							}
							String finalArguments = "";
							// Template changes end
							if (CommonUtil.isValidObject(scriptArguments) && StringUtils.isNotEmpty(scriptArguments)) {
								String[] arguments = scriptArguments.split(Constants.DELIMITER);
								if (CommonUtil.isValidObject(arguments) && arguments.length > 0) {
									for (String argument : arguments) {
										String argPreceeding = "";
										argument = argument.trim();
										if (argument.contains(" ") && argument.contains("-")
												&& argument.startsWith("-")) {
											argPreceeding = StringUtils.substringBefore(argument, " ");
											argPreceeding = argPreceeding.trim();
											argument = StringUtils.substringAfter(argument, " ");
											argument = argument.trim();
										}
										UserDetailsEntity userDetailsEntity = userActionRepositoryImpl
												.getUserDetailsBasedName(userName);
										String saneUserName = "";
										String sanePwd = "";
										if (CommonUtil.isValidObject(userDetailsEntity)) {
											saneUserName = userDetailsEntity.getVpnUserName();
										}
										if (useCurrPassword == true) {
											sanePwd = PasswordCrypt.decrypt(userDetailsEntity.getVpnPassword());
										} else {
											sanePwd = sanePassword;
										}
										String newArgument = commonUtil.getArgumentValue(Integer.toString(programId),
												ciqFileName, neId, neName, networkConfigEntity, migrationType,
												migrationSubType, argument, userName, sessionId,
												connectionLocationUserName, connectionLocationPwd,
												connectionSudoPassword, saneUserName, sanePwd);
										if (argPreceeding != null) {
											if (argPreceeding.trim().contains("-")) {
												finalArguments = finalArguments + " " + argPreceeding + " ";
											}
										}
										if (newArgument != null) {
											newArgument = "'" + newArgument + "'";
										}
										finalArguments = finalArguments + newArgument + " ";

									}
								}
							}
							comFilePath.append(LoadPropertyFiles.getInstance().getProperty("BASE_PATH"))
									.append(Constants.CUSTOMER).append(Constants.SEPARATOR).append(programId);

							if (migrationType.equalsIgnoreCase(Constants.POST_MIGRATION)) {

								outputFilePath.append(comFilePath)
										.append(Constants.RUN_MIGRATION_OUTPUT.replace("migration", migrationType)
												.replace("enbId", StringUtils.substringBeforeLast(neId, "."))
												.replace("subtype", migrationSubType).replaceAll(" ", "_"));

								newOutputFilePath.append(comFilePath)
										.append(Constants.RUN_MIGRATION_OUTPUT.replace("migration", migrationType)
												.replace("enbId", StringUtils.substringBeforeLast(neId, "."))
												.replace("subtype", migrationSubType).replaceAll(" ", "_"))
										.append(testname).append("_").append(StringUtils.substringBeforeLast(neId, "."))
										.append("_").append(neName).append("/");

								newOutputFileDBPath.append(Constants.SEPARATOR).append(Constants.CUSTOMER)
										.append(Constants.SEPARATOR).append(programId).append(Constants.SEPARATOR)
										.append(Constants.RUN_MIGRATION_OUTPUT.replace("migration", migrationType)
												.replace("enbId", StringUtils.substringBeforeLast(neId, "."))
												.replace("subtype", migrationSubType).replaceAll(" ", "_"))
										.append(testname).append("_").append(StringUtils.substringBeforeLast(neId, "."))
										.append("_").append(neName).append("/");

								String timeStamp = new SimpleDateFormat("yyyy-MM-dd_HH:mm:ss").format(new Date());

								auditHtmlFileName.setLength(0);
								auditHtmlFileName.append("AUDIT_" + neId + "_" + timeStamp + ".html");

								auditHtmlFilePath.setLength(0);
								auditHtmlFilePath.append(comFilePath)
										.append(Constants.RUN_MIGRATION_OUTPUT.replace("migration", migrationType)
												.replace("enbId", StringUtils.substringBeforeLast(neId, "."))
												.replace("subtype", migrationSubType).replaceAll(" ", "_"))
										.append(auditHtmlFileName.toString());

								File newFilePath = new File(newOutputFilePath.toString());
								newFilePath.mkdirs();

								File outFilePath = new File(outputFilePath.toString());
								outFilePath.mkdirs();

								outputFileNameAudit = outputFilePath + serviceToken + "_" + "output.txt";

								// String subtype = null;
								if ("AUDIT".equalsIgnoreCase(migrationSubType)) {
									// subtype = "Audit"; Audit

									String endName = "";
									if (StringUtils.isNotEmpty(scriptEntity.getFileName())) {
										endName = scriptEntity.getFileName().substring(0,
												scriptEntity.getFileName().indexOf('_'));
									}

									if ("DSS".equalsIgnoreCase(endName)) {
										auditHtmlFileName.setLength(0);
										auditHtmlFileName.append("AUDIT" + "_" + neId + "_" + timeStamp + ".html");

										auditHtmlFilePath.setLength(0);
										auditHtmlFilePath.append(comFilePath)
												.append(Constants.RUN_MIGRATION_OUTPUT
														.replace("migration", migrationType)
														.replace("enbId", StringUtils.substringBeforeLast(neId, "."))
														.replace("subtype", migrationSubType).replaceAll(" ", "_"))
												.append(auditHtmlFileName.toString());
									}

									if ("eNB".equalsIgnoreCase(endName)) {
									}

									else {

										if (sanePasswordBoo.get()) {
											LocalDateTime lsh1 = LocalDateTime.now();
											// logger.error("Executing Script : " + scriptEntity.getFileName() + " NE :
											// " + neId + " at : " + lsh1);
											JSONObject duoData = isDuoApplicable(scriptEntity, networkConfigEntity,
													useCurrPassword, sanePassword);
											if (duoData.containsKey("status")
													&& duoData.get("status").equals(Constants.SUCCESS)) {
												JSONObject resultCurlCommand = getCurlCommandAudit(neId, sProgramId,
														migrationType, scriptEntity, neEntity, originalUseCaseName,
														ciqFileName);
												if (resultCurlCommand.containsKey("status")
														&& resultCurlCommand.get("status").equals(Constants.SUCCESS)) {
													String tempCommand = resultCurlCommand.get("command").toString();
													System.out.println("--------------Command --------------");
													System.out.println(tempCommand);
													System.out.println("--------------Command --------------");
													if (isMultipleDUo.get() ) {
														shelloutput = duoSessionAU(userName, outputFileNameAudit,
																scriptEntity.getFileName(), duoData, tempCommand, neId,
																sProgramId);
													} else {
													shelloutput = duoSession(userName, outputFileNameAudit,
															scriptEntity.getFileName(), duoData, tempCommand);
													}
													
												} else if (resultCurlCommand.containsKey("reason")) {
													shelloutput = resultCurlCommand.get("reason").toString();
												}

											} else if (!duoData.containsKey("reason")) {
												shelloutput = executeCommand5GAudit(fileNameWithPath,
														outputFileNameAudit, finalArguments, "");
											} else {
												shelloutput = duoData.get("reason").toString();
											}
											//shelloutput = returnshellop(scriptEntity.getFileName());
											LocalDateTime lsh2 = LocalDateTime.now();
											// logger.error("Completed Script : " + scriptEntity.getFileName() + " NE :
											// " + neId + " at : " + lsh2);
											dshsec = Duration.between(lsh1, lsh2).getSeconds();
											if (dshsec > Constants.SSH_TIMEOUT && !shelloutput.contains("<rpc-reply")
													&& !shelloutput.contains("</rpc-reply>")) {
												shelloutput = shelloutput + "\n\nMessage from SRCT : SSH Timeout";
											}
											logger.error("Duration for script in server : " + scriptEntity.getFileName()
													+ " NE : " + neId + "(HH:mm:ss) : " + String.format("%d:%02d:%02d",
															dshsec / 3600, (dshsec % 3600) / 60, dshsec % 60));
										}
										if (shelloutput.contains("spawn id exp")) {
											sanePasswordBoo.set(false);
										}
										if (shelloutput.contains("<rpc-reply")
												&& !(shelloutput.contains("<rpc-error"))) {
											createHtmlMapboo.put(
													FilenameUtils.removeExtension(scriptEntity.getFileName()), true);
										} else {
											createHtmlMapboo.put(
													FilenameUtils.removeExtension(scriptEntity.getFileName()), false);
										}

										String dataOutput = getRequiredOutPut5GAudit(shelloutput,
												scriptEntity.getFileName());
										required5GOutput.append(dataOutput);
										required5GOutput.append("/n");

									}
									// shelloutput = readFileAsString("/home/user/Desktop/audit_response");

								}
								// auditoutput.put(neId, required5GOutput);
								// dssResult.put("auditoutput", auditoutput);
								String path = LoadPropertyFiles.getInstance().getProperty("BASE_PATH") + "Customer/"
										+ programId + "/" + migrationType + "/" + neId + "/" + migrationSubType + "/"
										+ "Output" + "/";

								File duplicatePath = new File(path);
								duplicatePath.mkdirs();

								if ("AUDIT".equalsIgnoreCase(migrationSubType)) {

									timeStamp = new SimpleDateFormat("MMddyyyy_HH_mm_ss")
											.format(new Timestamp(System.currentTimeMillis()));
									String newOutputFileName = serviceToken + "_" + useCaseName + "_" + scriptFileName
											+ "_" + timeStamp + ".txt";
									descFinalPath = newOutputFilePath.toString() + newOutputFileName;
									FileWriter fileWriter = new FileWriter(descFinalPath);
									fileWriter.write(shelloutput);
									fileWriter.close();
								}

								// CommonUtil.removeCtrlChars(outputFileNameAudit);
								CommonUtil.removeCtrlChars(descFinalPath);

							}

							// complted executing

							UseCaseBuilderParamEntity useCaseBuilderParamEntity = null;

							for (int j = 0; j < scriptFinalLst.size(); j++) {
								ArrayList scritlst = (ArrayList) scriptFinalLst.get(j);
								int scriptID = (int) scritlst.get(0);

								if (scriptID == scriptEntity.getId()) {
									int scrpitid12 = (int) scritlst.get(2);
									useCaseBuilderParamEntity = useCaseBuilderRepository
											.getUseCaseBuilderParamEntity(scrpitid12);
									break;
								}
							}

							LinkedHashSet<UseCaseCmdRuleEntity> useCaseCmdRuleEntityset = useCaseBuilderParamEntity
									.getUseCaseCmdRuleEntitySet().parallelStream()
									.sorted((p1, p2) -> p1.getId().compareTo(p2.getId()))
									.collect((Collectors.toCollection(LinkedHashSet::new)));

							LinkedHashSet<UseCaseShellRuleEntity> useCaseShellRuleEntityset = useCaseBuilderParamEntity
									.getUseCaseShellRuleEntitySet().parallelStream()
									.sorted((p1, p2) -> p1.getId().compareTo(p2.getId()))
									.collect((Collectors.toCollection(LinkedHashSet::new)));

							LinkedHashSet<UseCaseFileRuleEntity> useCaseFileRuleEntityset = useCaseBuilderParamEntity
									.getUseCaseFileRuleEntitySet().parallelStream()
									.sorted((p1, p2) -> p1.getId().compareTo(p2.getId()))
									.collect((Collectors.toCollection(LinkedHashSet::new)));

							LinkedHashSet<UseCaseXmlRuleEntity> useCaseXmlRuleEntityset = useCaseBuilderParamEntity
									.getUseCaseXmlRuleEntitySet().parallelStream()
									.sorted((p1, p2) -> p1.getId().compareTo(p2.getId()))
									.collect((Collectors.toCollection(LinkedHashSet::new)));

							RunTestEntity runTestEntity = runTestEntityMap.get(neId);

							UseCaseBuilderEntity useCaseBuilderEntitybyId = useCaseBuilderService
									.getUseCaseBuilderEntity(iUseCaseId);

							UploadFileEntity uploadFileEntity = uploadFileRepository.getUploadFileEntity(scriptId);
							// Performance Upgradation
							ConcurrentHashMap<Integer, List<RunTestResultEntity>> runtestResultEntityListMap = new ConcurrentHashMap<>();

							for (UseCaseXmlRuleEntity xml : useCaseXmlRuleEntityset) {
								XmlRuleBuilderEntity xmlRuleEntity = xml.getXmlRuleBuilderEntity();
								int xmlRuleOccurenece = xml.getXmlRuleSequence();
								String xmlResult = "FAIL";

								if (xmlRuleEntity != null
										&& !ObjectUtils.isEmpty(xmlRuleEntity.getXmlElementEntitySet())) {

									Set<XmlElementEntity> elementSet = xmlRuleEntity.getXmlElementEntitySet();
									// Set<XmlElementEntity> listOfEntityes=new LinkedHashSet<>();
									// listOfEntityes.addAll(elementSet);
									if (!ObjectUtils.isEmpty(elementSet.isEmpty())) {
										if (elementrulesMap.containsKey(
												FilenameUtils.removeExtension(uploadFileEntity.getFileName()))) {
											Set<XmlElementEntity> listOfEntityes = elementrulesMap
													.get(FilenameUtils.removeExtension(uploadFileEntity.getFileName()));
											listOfEntityes.addAll(elementSet);
											elementrulesMap.put(
													FilenameUtils.removeExtension(uploadFileEntity.getFileName()),
													listOfEntityes);
										} else {
											elementrulesMap.put(
													FilenameUtils.removeExtension(uploadFileEntity.getFileName()),
													elementSet);
										}
									}
								}

								xmlResult = xmlParsing5GAudit(xmlRuleEntity, required5GOutput.toString(),
										xmlRuleOccurenece, neName, neId, dbcollectionFileName);

								Object obj = new JSONParser().parse(xmlResult);
								JSONObject jo = (JSONObject) obj;
								xmlResult = (String) jo.get("outputResult");
								Map ruleResultJsonMap = (Map) jo.get("ruleResultJson");
								String ruleResultJson = ruleResultJsonMap.toString();

								if (!"PASS".equalsIgnoreCase(xmlResult)) {
									finalStatusResult = FAILURE;
								}

								RunTestResultEntity runTestResultEntity = new RunTestResultEntity();
								runTestResultEntity.setRunTestEntity(runTestEntity);

								runTestResultEntity.setUseCaseBuilderEntity(useCaseBuilderEntitybyId);
								runTestResultEntity.setUploadFileEntity(uploadFileEntity);

								runTestResultEntity.setXmlRuleBuilderEntity(xmlRuleEntity);

								runTestResultEntity.setCurrentResult(xmlResult);
								runTestResultEntity.setCurrentScriptOutput(newOutputFileDBPath.toString());
								runTestResultEntity.setCustomerDetailsEntity(customerDetailsEntity);
								runTestResultEntity.setMigrationType(migrationType);
								runTestResultEntity.setMigrationSubType(migrationSubType);
								runTestResultEntity.setNeName(neId);
								runTestResultEntity.setRuleResultJson(ruleResultJson);
								runTestResultEntity.setScriptExeSeq(iScriptExeSeq);
								if (runtestResultEntityListMap.containsKey(scriptId)) {
									runtestResultEntityListMap.get(scriptId).add(runTestResultEntity);
								} else {
									List<RunTestResultEntity> runtestResultEntityList = new ArrayList<>();
									runtestResultEntityList.add(runTestResultEntity);
									runtestResultEntityListMap.put(scriptId, runtestResultEntityList);
								}

								runTestResultRepository.createRunTestResult(runTestResultEntity);

							}

							for (UseCaseShellRuleEntity j : useCaseShellRuleEntityset) {
								ShellCmdRuleBuilderEntity shellRuleEntity = j.getShellRuleBuilderEntity();
								int shellRuleOccurence = j.getShellRuleSequence();
								String shellResult = "FAIL";

								shellResult = shellProcess(shellRuleEntity, shelloutput, shellRuleOccurence, neName,
										neId);

								if (!"PASS".equalsIgnoreCase(shellResult)) {
									finalStatusResult = FAILURE;
								}

								RunTestResultEntity runTestResultEntity = new RunTestResultEntity();
								runTestResultEntity.setRunTestEntity(runTestEntity);

								runTestResultEntity.setUseCaseBuilderEntity(useCaseBuilderEntitybyId);
								runTestResultEntity.setUploadFileEntity(uploadFileEntity);

								runTestResultEntity.setShellCmdRuleBuilderEntity(shellRuleEntity);

								runTestResultEntity.setCurrentResult(shellResult);
								runTestResultEntity.setCurrentScriptOutput(newOutputFileDBPath.toString());
								runTestResultEntity.setCustomerDetailsEntity(customerDetailsEntity);
								runTestResultEntity.setMigrationType(migrationType);
								runTestResultEntity.setMigrationSubType(migrationSubType);
								runTestResultEntity.setNeName(neId);
								runTestResultEntity.setScriptExeSeq(iScriptExeSeq);
								if (runtestResultEntityListMap.containsKey(scriptId)) {
									runtestResultEntityListMap.get(scriptId).add(runTestResultEntity);
								} else {
									List<RunTestResultEntity> runtestResultEntityList = new ArrayList<>();
									runtestResultEntityList.add(runTestResultEntity);
									runtestResultEntityListMap.put(scriptId, runtestResultEntityList);
								}
								runTestResultRepository.createRunTestResult(runTestResultEntity);

							}

							for (UseCaseCmdRuleEntity j : useCaseCmdRuleEntityset) {
								CmdRuleBuilderEntity cmdRuleEntity = j.getCmdRuleBuilderEntity();
								int cmRuleOccurence = j.getCommandRuleSequence();
								String cmdResult = "FAIL";

								/*
								 * if ("AUDIT".equalsIgnoreCase(migrationSubType)) { shelloutput =
								 * readFileAsString(outputFileNameAudit); }else { shelloutput =
								 * readFileAsString(outputFileName); }
								 */

								cmdResult = cliProcess(cmdRuleEntity, shelloutput, cmRuleOccurence, neName, neId);

								Object obj = new JSONParser().parse(cmdResult);
								JSONObject jo = (JSONObject) obj;
								cmdResult = (String) jo.get("outputResult");
								Map ruleResultJsonMap = (Map) jo.get("ruleResultJson");
								String ruleResultJson = ruleResultJsonMap.toString();

								if (!"PASS".equalsIgnoreCase(cmdResult)) {
									finalStatusResult = FAILURE;
								}

								RunTestResultEntity runTestResultEntity = new RunTestResultEntity();
								runTestResultEntity.setRunTestEntity(runTestEntity);

								runTestResultEntity.setUseCaseBuilderEntity(useCaseBuilderEntitybyId);
								runTestResultEntity.setUploadFileEntity(uploadFileEntity);

								runTestResultEntity.setCmdRuleBuilderEntity(cmdRuleEntity);

								runTestResultEntity.setCurrentResult(cmdResult);
								runTestResultEntity.setCurrentScriptOutput(newOutputFileDBPath.toString());
								runTestResultEntity.setCustomerDetailsEntity(customerDetailsEntity);
								runTestResultEntity.setMigrationType(migrationType);
								runTestResultEntity.setMigrationSubType(migrationSubType);
								runTestResultEntity.setNeName(neId);
								runTestResultEntity.setRuleResultJson(ruleResultJson);
								runTestResultEntity.setScriptExeSeq(iScriptExeSeq);
								if (runtestResultEntityListMap.containsKey(scriptId)) {
									runtestResultEntityListMap.get(scriptId).add(runTestResultEntity);
								} else {
									List<RunTestResultEntity> runtestResultEntityList = new ArrayList<>();
									runtestResultEntityList.add(runTestResultEntity);
									runtestResultEntityListMap.put(scriptId, runtestResultEntityList);
								}

								runTestResultRepository.createRunTestResult(runTestResultEntity);

							}
							StringBuilder fileFinaloutput = new StringBuilder();
							for (UseCaseFileRuleEntity entity : useCaseFileRuleEntityset) {
								FileRuleBuilderEntity fileRuleEntity = entity.getFileRuleBuilderEntity();

								String fileName1 = "admin_" + fileRuleEntity.getFileName();
								// int count = fileRule.getOccCount();
								int count = 2;
								String serachParam = fileRuleEntity.getSearchParameter();
								String status = fileRuleEntity.getStatus();
								String finalResult = "FAIL";
								String outputString = null;

								boolean result = fileExists(fileName1);
								if (result) {
									Map finalResultMap = paramCount(fileName1, count, serachParam, status);
									outputString = (String) finalResultMap.get("outputString");

									fileFinaloutput = fileFinaloutput.append("\nfileName :").append(fileName1)
											.append("\n").append(outputString);

									FileWriter fileWriter = new FileWriter(descFinalPath, true);
									fileWriter.write(shelloutput);
									fileWriter.close();

									finalResult = (String) finalResultMap.get("status");
								}

								if (!"PASS".equalsIgnoreCase(finalResult)) {
									finalStatusResult = FAILURE;
								}

								RunTestResultEntity runTestResultEntity = new RunTestResultEntity();
								runTestResultEntity.setRunTestEntity(runTestEntity);

								runTestResultEntity.setUseCaseBuilderEntity(useCaseBuilderEntitybyId);
								runTestResultEntity.setUploadFileEntity(uploadFileEntity);

								runTestResultEntity.setFileRuleBuilderEntity(fileRuleEntity);

								runTestResultEntity.setCurrentResult(finalResult);
								runTestResultEntity.setCurrentScriptOutput(newOutputFileDBPath.toString());
								runTestResultEntity.setCustomerDetailsEntity(customerDetailsEntity);
								runTestResultEntity.setMigrationType(migrationType);
								runTestResultEntity.setMigrationSubType(migrationSubType);
								runTestResultEntity.setNeName(neId);
								runTestResultEntity.setScriptExeSeq(iScriptExeSeq);
								if (runtestResultEntityListMap.containsKey(scriptId)) {
									runtestResultEntityListMap.get(scriptId).add(runTestResultEntity);
								} else {
									List<RunTestResultEntity> runtestResultEntityList = new ArrayList<>();
									runtestResultEntityList.add(runTestResultEntity);
									runtestResultEntityListMap.put(scriptId, runtestResultEntityList);
								}

								runTestResultRepository.createRunTestResult(runTestResultEntity);

							}

							if (useCaseFileRuleEntityset.isEmpty() && useCaseCmdRuleEntityset.isEmpty()
									&& useCaseXmlRuleEntityset.isEmpty() && useCaseShellRuleEntityset.isEmpty()) {

								RunTestResultEntity runTestResultEntity = new RunTestResultEntity();

								// runTestResultEntity.setRunTestId(runTestEntityMap.get(neId).getId());
								runTestResultEntity.setRunTestEntity(runTestEntity);

								runTestResultEntity.setUseCaseBuilderEntity(useCaseBuilderEntitybyId);
								runTestResultEntity.setUploadFileEntity(uploadFileEntity);

								runTestResultEntity.setCurrentResult("PASS");
								runTestResultEntity.setCurrentScriptOutput(newOutputFileDBPath.toString());
								runTestResultEntity.setCustomerDetailsEntity(customerDetailsEntity);
								runTestResultEntity.setMigrationType(migrationType);
								runTestResultEntity.setMigrationSubType(migrationSubType);
								runTestResultEntity.setNeName(neId);
								runTestResultEntity.setScriptExeSeq(iScriptExeSeq);
								if (runtestResultEntityListMap.containsKey(scriptId)) {
									runtestResultEntityListMap.get(scriptId).add(runTestResultEntity);
								} else {
									List<RunTestResultEntity> runtestResultEntityList = new ArrayList<>();
									runtestResultEntityList.add(runTestResultEntity);
									runtestResultEntityListMap.put(scriptId, runtestResultEntityList);
								}

								runTestResultRepository.createRunTestResult(runTestResultEntity);
							}

							if (shelloutput.contains("DUO ERROR:")) {
								break mainloop1;

							}
							// kannan
							// }
							List<RunTestResultEntity> resultList = runtestResultEntityListMap.get(scriptId);
							boolean status = false;
							for (RunTestResultEntity runTestResultEntity : resultList) {
								if (runTestResultEntity.getCurrentResult().equalsIgnoreCase("PASS")) {
									status = true;
								} else {
									status = false;
									break;
								}
							}

							LocalDateTime lshtool2 = LocalDateTime.now();
							long dshtool = Duration.between(lshtool1, lshtool2).getSeconds() - dshsec;
							logger.error("Duration for script in tool : " + scriptEntity.getFileName() + " NE : " + neId
									+ "(HH:mm:ss) : " + String.format("%d:%02d:%02d", dshtool / 3600,
											(dshtool % 3600) / 60, dshtool % 60));
						}

						StringBuilder comFilePath = new StringBuilder();
						comFilePath.append(LoadPropertyFiles.getInstance().getProperty("BASE_PATH"))
								.append(Constants.CUSTOMER).append(Constants.SEPARATOR).append(programId);

						StringBuilder outputFilePath = new StringBuilder();

						outputFilePath.append(comFilePath)
								.append(Constants.RUN_MIGRATION_OUTPUT.replace("migration", migrationType)
										.replace("enbId", StringUtils.substringBeforeLast(neId, "."))
										.replace("subtype", migrationSubType).replaceAll(" ", "_"));

						String outputFileName = outputFilePath + serviceToken + "_" + "output.txt";

						CommonUtil.removeCtrlChars(outputFileName);
						String programName = customerDetailsEntity.getProgramName();
						if (migrationType.equalsIgnoreCase(Constants.POST_MIGRATION)
								&& "AUDIT".equalsIgnoreCase(migrationSubType)) {

							createAuditHtmlFile5GAudit(auditHtmlFilePath.toString(), runTestEntityMap.get(neId).getId(),
									ciqFileName, neId, neName, lsmName, scriptFilesDetails, networkConfigEntity, "xml",
									required5GOutput, elementrulesMap, required5GOutputEnb, programName,
									createHtmlMapboo);

						}
						// kannankumar ends

						int ucsleep = getUCSleepInterval(useCaseList, iUseCaseId);

						Thread.sleep(ucsleep);
						String fileSavePath = StringUtils.substringBeforeLast(auditHtmlFilePath.toString(), "/");
						fileSavePath = fileSavePath.replace(LoadPropertyFiles.getInstance().getProperty("BASE_PATH"),
								"");
						if (createHtmlMapboo.isEmpty()) {
							auditHtmlFileName.setLength(0);
							fileSavePath = "";
						}
						if (!sanePasswordBoo.get() || !createHtmlMapboo.containsValue(true)
								|| createHtmlMapboo.containsValue(false)) {
							finalStatusResult = FAILURE;
						}
						if (programName.contains("5G-DSS")) {
							List<Audit5GDSSSummaryEntity> audit5GDSSSummaryEntityList = audit5GDSSSummaryService
									.getAudit5GDSSSummaryEntityListByRunTestId(runTestEntityMap.get(neId).getId());
							if (audit5GDSSSummaryEntityList != null && !audit5GDSSSummaryEntityList.isEmpty()) {
								finalStatusResult = FAILURE;
								try {
									List<Audit5GDSSSummaryEntity> audit5GDSSSummaryEntityInfoList = audit5GDSSSummaryEntityList
											.stream().filter(x -> x.getAudit5gCbandRulesEntity().getErrorCode()
													.toUpperCase().contains("INFO"))
											.collect(Collectors.toList());
									if (audit5GDSSSummaryEntityInfoList.size() == audit5GDSSSummaryEntityList.size()) {
										finalStatusResult = "Success";
									}
								} catch (Exception e) {
									finalStatusResult = FAILURE;
									logger.error(ExceptionUtils.getMessage(e));
								}
							}
						}else if (programName.contains("5G-CBAND")) {
							List<Audit5GCBandSummaryEntity> audit5GCBandSummaryEntityList = audit5GCBandSummaryService
									.getAudit5GCBandSummaryEntityListByRunTestId(runTestEntityMap.get(neId).getId());
							if (audit5GCBandSummaryEntityList != null && !audit5GCBandSummaryEntityList.isEmpty()) {
								finalStatusResult = FAILURE;
								try {
									List<Audit5GCBandSummaryEntity> audit5GCBandSummaryEntityInfoList = audit5GCBandSummaryEntityList
											.stream().filter(x -> x.getAudit5gCbandRulesEntity().getErrorCode()
													.toUpperCase().contains("INFO"))
											.collect(Collectors.toList());
									if (audit5GCBandSummaryEntityInfoList.size() == audit5GCBandSummaryEntityList
											.size()) {
										finalStatusResult = "Success";
									}
								} catch (Exception e) {
									finalStatusResult = FAILURE;
									logger.error(ExceptionUtils.getMessage(e));
								}
							}
						}

						runTestEntityMap.get(neId).setResult(auditHtmlFileName.toString());
						runTestEntityMap.get(neId).setResultFilePath(fileSavePath);
						runTestEntityMap.get(neId).setProgressStatus("Completed");
						runTestEntityMap.get(neId).setStatus(finalStatusResult);
						String postMigrationResult ="";
						if (finalStatusResult.contains("Success")) {
							postMigrationResult="eNB PrePost OK";
						}else
						{
							 postMigrationResult ="eNB PrePost NOk";
						}

						//// change the progressstatus in migratiom
					
						runTestEntityMap1.get(neId).setResult(auditHtmlFileName.toString());
						runTestEntityMap1.get(neId).setResultFilePath(fileSavePath);
						runTestEntityMap1.get(neId).setMigStatusDesc(postMigrationResult);
						runTestEntityMap1.get(neId).setProgressStatus("Completed");
						runTestRepository.updateRunTest(runTestEntityMap1.get(neId));

						if (totalTestCompleted.get()) {
							runTestEntityMap.get(neId).setFailedScript("true");
							;
						} else {
							runTestEntityMap.get(neId).setFailedScript("false");
							;
						}

						if (StringUtils.isNotEmpty(generateScriptPath)) {
							runTestEntityMap.get(neId).setGenerateScriptPath(
									generateScriptPath.substring(0, generateScriptPath.length() - 1));
						}
						runTestRepository.updateRunTest(runTestEntityMap.get(neId));
						// User user = UserSessionPool.getInstance().getSessionUser(sessionId);
						reportService.insertPostMigAuditReportDetails(neId, programId,
								customerDetailsEntity.getProgramName(), userName, ciqFileName, scriptFilesDetails,
								finalStatusResult, migrationSubType);
						if (run.containsKey("trackerId")) {
							OvScheduledEntity ovScheduledEntity = ovScheduledTaskService
									.getOvScheduledServiceDetails(run.get("trackerId").toString(), neId);

							ovScheduledEntity.setPostMigAuditStatus(finalStatusResult);
							if (finalStatusResult.equals("Success")) {
								// ovScheduledEntity = fetchProcessService.statusUpdateApi(ovScheduledEntity,
								// "PostMigration","",runTestParams.get("programName").toString());
							}
							ovScheduledEntity = ovScheduledTaskService.mergeOvScheduledDetails(ovScheduledEntity);
						}
						auditCriticalParamsService.updateExecStatus(runTestEntityMap.get(neId).getId(), finalStatusResult);

					} catch (Exception e) {
						runTestEntityMap.get(neId).setProgressStatus("Completed");
						runTestEntityMap.get(neId).setStatus(FAILURE);
						auditCriticalParamsService.updateExecStatus(runTestEntityMap.get(neId).getId(), FAILURE);
						runTestRepository.updateRunTest(runTestEntityMap.get(neId));
						logger.error("Exception RunTestServiceImpl in getRuntestExecResult() "
								+ ExceptionUtils.getFullStackTrace(e));
					}
					LocalDateTime l2 = LocalDateTime.now();
					logger.error("Completed the thread for NE " + neId + " at : " + l2);
					long duthreadsec = Duration.between(l1, l2).getSeconds();
					logger.error("Duration for thread for NE " + neId + " (HH:mm:ss) : " + String.format("%d:%02d:%02d",
							duthreadsec / 3600, (duthreadsec % 3600) / 60, duthreadsec % 60));
					GlobalStatusMap.userNeQueue.get(userDetailsEntity2.getVpnUserName()).remove(neId);
					return Constants.SUCCESS;

				});
			}

			executorservice.shutdown();
		}

		catch (

		Exception e) {
			logger.error("Exception RunTestServiceImpl in getRuntestExecResult5GAudit() "
					+ ExceptionUtils.getFullStackTrace(e));
			dssResult.put("Status", e.getMessage());
			return dssResult;
		}
		dssResult.put("Status", Constants.SUCCESS);
		return dssResult;

	}
	
	
	

	@Override
	public String getRuntestExecResult5GAudit(JSONObject runTestParams, Map<String, RunTestEntity> runTestEntityMap,
			String runType, String htmlOutputFileName, Map<String, Object> reRunDetails, boolean rfScriptsFlag)
			throws RctException {

		Map run = (Map) runTestParams.get("runTestFormDetails");
		String testname = run.get("testname").toString();

		List<Map> scriptSeqDetails = (List<Map>) run.get("scripts");
		List<Map> neList = (List<Map>) run.get("neDetails");
		List<LinkedHashMap> useCaseList = (List) run.get("useCase");
		int programId = Integer.parseInt(runTestParams.get("programId").toString());

		boolean useCurrPassword = (boolean) run.get("currentPassword");
		String serviceToken = runTestParams.get("serviceToken").toString();
		String sanePassword = run.get("password").toString();
		String migType = runTestParams.get("migrationType").toString();
		String migSubType = runTestParams.get("migrationSubType").toString();
		String userName = runTestParams.get("userName").toString();
		String checklistFileName = run.get("checklistFileName").toString();
		String ciqFileName = run.get("ciqName").toString();
		String sProgramId = runTestParams.get("programId").toString();
		String remarks = run.get("testDesc").toString();
		String sessionId = runTestParams.get("sessionId").toString();
		CustomerDetailsEntity customerDetailsEntity = getCustomerDetailsEntity(programId);
		AtomicBoolean totalTestCompleted = new AtomicBoolean();
		AtomicBoolean isMultipleDUo = new AtomicBoolean();
		isMultipleDUo.set(false);
		if(run.containsKey("multipleDuo")) {
		boolean duo1234 = (boolean) run.get("multipleDuo");
		if(duo1234==true) {
			isMultipleDUo.set(true);
		}}
		//rssi
		//List<String> newRadios  = (List<String>) run.get("radioUnits");
		
		try {
			ExecutorService executorservice = Executors.newFixedThreadPool(neList.size());
			for (Map usecase : useCaseList) {
				Integer useCaseId = Integer.valueOf(usecase.get("useCaseId").toString());
				runTestRepository.updateUseCountForUseCase(useCaseId, Constants.USECOUNT_INCREMENT, neList.size());
			}
			for (Map neid : neList) {

				executorservice.submit(() -> {
					LocalDateTime l1 = LocalDateTime.now();
					Map<String, String> scriptFilesDetails = new HashMap<>();
					StringBuilder auditHtmlFilePath = new StringBuilder();
					StringBuilder auditHtmlFileName = new StringBuilder();
					NetworkConfigEntity neMappingEntitiesForVersion = null;
					ReportsEntity reportsEntity = null;
					String programName2 = customerDetailsEntity.getProgramName();

					String neId = neid.get("neId").toString();
					String neName = neid.get("neName").toString();
					logger.error("Started the thread for NE " + neId + " at : " + l1);
					String threadname = "RT_" + runTestEntityMap.get(neId).getId();
					Thread.currentThread().setName(threadname);
					runTestEntityMap.get(neId).setruntestThreadName(threadname);
					runTestRepository.updateRunTest(runTestEntityMap.get(neId));

					UserDetailsEntity userDetailsEntity2 = userActionRepositoryImpl.getUserDetailsBasedName(userName);
					if (GlobalStatusMap.userNeQueue.contains(userDetailsEntity2.getVpnUserName())) {
						GlobalStatusMap.userNeQueue.get(userDetailsEntity2.getVpnUserName()).add(neId);
					} else {
						GlobalStatusMap.userNeQueue.put(userDetailsEntity2.getVpnUserName(),
								new ConcurrentLinkedQueue<>());
						GlobalStatusMap.userNeQueue.get(userDetailsEntity2.getVpnUserName()).add(neId);
					}

					int lsmId = 0;
					String lsmName = run.get("lsmName").toString();
					String lsmVersion = run.get("lsmVersion").toString();

					if (!run.get("lsmId").toString().isEmpty()) {
						lsmId = Integer.parseInt(run.get("lsmId").toString());
					}
					if (lsmVersion.isEmpty() || lsmName.isEmpty()) {
						NeMappingModel neMappingModelversion = new NeMappingModel();
						CustomerDetailsEntity programDetailsEntityversion = new CustomerDetailsEntity();
						programDetailsEntityversion.setId(programId);
						neMappingModelversion.setProgramDetailsEntity(programDetailsEntityversion);
						neMappingModelversion.setEnbId(neId);
						neMappingEntitiesForVersion = runTestRepository.getNetWorkEntityDetails(neMappingModelversion);
						lsmId = neMappingEntitiesForVersion.getId();
						lsmVersion = neMappingEntitiesForVersion.getNeVersionEntity().getNeVersion();
						lsmName = neMappingEntitiesForVersion.getNeName();

					}
					NetworkConfigEntity networkConfigEntity = runTestRepository.getNeType(lsmId);

					NetworkConfigEntity neEntity = uploadFileServiceImpl.getNeEntity(lsmVersion, lsmName, programId);

					String migrationType = null;
					String migrationSubType = null;

					if (migType.equalsIgnoreCase(Constants.MIGRATION)) {
						migrationType = "Migration";
					} else if (migType.equalsIgnoreCase(Constants.POST_MIGRATION)) {
						migrationType = "PostMigration";
					} else if (migType.equalsIgnoreCase(Constants.PRE_MIGRATION)) {
						migrationType = "PreMigration";
					}

					if ("precheck".equalsIgnoreCase(migSubType)) {
						migrationSubType = "PreCheck";
					} else if ("commission".equalsIgnoreCase(migSubType)) {
						migrationSubType = "Commission";
					} else if ("postcheck".equalsIgnoreCase(migSubType)) {
						migrationSubType = "PostCheck";
					} else if ("AUDIT".equalsIgnoreCase(migSubType)) {
						migrationSubType = "Audit";
					} else if ("RANATP".equalsIgnoreCase(migSubType)) {
						migrationSubType = "RanATP";
					} else if ("PREAUDIT".equalsIgnoreCase(migSubType)) {
						migrationSubType = "PREAUDIT";
					}
					String generateScriptPath = "";

					try {
						StringBuilder required5GOutput = new StringBuilder();
						StringBuilder required5GOutputEnb = new StringBuilder();

						LinkedHashMap<String, Set<XmlElementEntity>> elementrulesMap = new LinkedHashMap<>();
						// generate script path
						StringBuilder generatedPath = new StringBuilder();
						generatedPath = generatedPath.append(LoadPropertyFiles.getInstance().getProperty("BASE_PATH"));
						generatedPath.append(Constants.CUSTOMER)
								.append(Constants.GENERATE_SCRIPT.replace("programId", sProgramId)
										.replace("migrationType", migrationType).replace("neId", neId)
										.replace("subType", migrationSubType));

						String finalStatusResult = "Success";
						int iUseCaseId = 0;
						Map<String, String> generateScriptMap = new HashMap<>();
						Map<String, String> scriptNameMap = new HashMap<>();
						if (scriptSeqDetails != null) {

							for (Map scriptInfoDetails : scriptSeqDetails) {
								String useGeneratedScriptsCheck = scriptInfoDetails.get("useGeneratedScript")
										.toString();
								String sScriptName = scriptInfoDetails.get("scriptName").toString();
								String useCaseNameInScript = scriptInfoDetails.get("useCaseName").toString();
								generateScriptMap.put(useCaseNameInScript + "_" + sScriptName,
										useGeneratedScriptsCheck);
								scriptNameMap.put(useCaseNameInScript + "_" + sScriptName, sScriptName);
							}
						}

						ArrayList scriptFinalLst = null;

						// Use case loop
						TreeSet<String> finalListFile = new TreeSet<>();
						scriptFinalLst = new ArrayList<ArrayList>();

						for (Map usecase : useCaseList) {
							Integer useCaseExeSeq = Integer.valueOf(usecase.get("executionSequence").toString());
							String useCaseName = (String) usecase.get("useCaseName");
							iUseCaseId = Integer.valueOf(usecase.get("useCaseId").toString());
							List<UseCaseBuilderParamEntity> scriptDetails = runTestRepository
									.getScriptDetails(iUseCaseId);

							Map<Integer, Integer> scriptIdAndSeqmap = new HashMap<>();
							for (UseCaseBuilderParamEntity scriptInfo : scriptDetails) {
								List scriptLst = new ArrayList<>();
								Integer scriptId = scriptInfo.getScriptsDetails().getId();

								int scriptUiExeSeq = getScriptExeSeq(scriptSeqDetails, scriptId);

								Integer scriptExeSeq = scriptUiExeSeq;

								Integer uploadedscriptId = scriptInfo.getId();
								if (scriptExeSeq != 0) {

									scriptLst.add(scriptId);
									scriptLst.add(scriptExeSeq);
									scriptLst.add(uploadedscriptId);
									scriptFinalLst.add(scriptLst);
									scriptIdAndSeqmap.put(scriptId, scriptExeSeq);

								}
							}

							// Script loop
							for (UseCaseBuilderParamEntity scriptEntity : scriptDetails) {

								Integer scriptId = scriptEntity.getScriptsDetails().getId();
								int scriptUiExeSeq = getScriptExeSeq(scriptSeqDetails, scriptId);
								Integer scriptExeSeq1 = scriptUiExeSeq;

								if (scriptExeSeq1 != 0) {
									int scriptExeSeq = scriptIdAndSeqmap.get(scriptId);

									// int scriptExeSeq = scriptEntity.getExecutionSequence();

									UploadFileEntity uploadFileEntity = runTestRepository.getScriptInfo(scriptId);

									String dbcollectionFileName = CommonUtil
											.createMongoDbFileName(String.valueOf(programId), ciqFileName);
									String vznEnbIP = fileUploadRepository.getEnBDataByPath(dbcollectionFileName,
											Constants.VZ_GROW_IPPLAN, neId,
											Constants.ORAN_SPRINT_COMM_SCRIPT_eNB_OAM_IP_eNB_S_B_IP);
									String eNB_OAM_IP = fileUploadRepository.getEnBDataByPath(dbcollectionFileName,
											Constants.SPT_GROW_SHEET_FDD_TDD, neId,
											Constants.ORAN_SPRINT_COMM_SCRIPT_8_CHG_IP_ADDR);

									String enbIP = "127.0.0.1";

									if (StringUtils.isNotEmpty(vznEnbIP)) {
										enbIP = vznEnbIP;
									} else if (StringUtils.isNotEmpty(eNB_OAM_IP)) {
										String sprintEnbIP = CommonUtil.getLeftSubStringWithLen(eNB_OAM_IP, 3);
										if (StringUtils.isNotEmpty(sprintEnbIP)) {
											enbIP = sprintEnbIP;
										} else {
											enbIP = eNB_OAM_IP;
										}
									}

									String CSR_OAM_IP = fileUploadRepository.getEnBDataByPath(dbcollectionFileName,
											Constants.SPT_GROW_SHEET_FDD_TDD, neId,
											Constants.ORAN_SPRINT_COMM_SCRIPT_9_CSR_OAM_IP);

									NeMappingModel neMappingModel = new NeMappingModel();
									CustomerDetailsEntity programDetailsEntity = new CustomerDetailsEntity();
									programDetailsEntity.setId(programId);
									neMappingModel.setProgramDetailsEntity(programDetailsEntity);
									neMappingModel.setEnbId(neId);
									List<NeMappingEntity> neMappingEntities = neMappingService
											.getNeMapping(neMappingModel);

									String neType = Constants.NE_TYPE_ENB;
									if (uploadFileEntity.getFileName().contains(Constants.PRECHECK_CSR_FILE_NAME)
											|| uploadFileEntity.getFileName()
													.contains(Constants.POSTCHECK_CSR_FILE_NAME)) {
										enbIP = CommonUtil.getLeftSubStringWithLen(CSR_OAM_IP, 3);
										neType = Constants.NE_TYPE_CSR;
									} else if (uploadFileEntity.getFileName().contains(Constants.PRECHECK_BSM_FILE_NAME)
											|| uploadFileEntity.getFileName()
													.contains(Constants.POSTCHECK_BSM_FILE_NAME)) {
										enbIP = neMappingEntities.get(0).getBsmIp();
										neType = Constants.NE_TYPE_BSM;
									}

									/*
									 * enbIP = fileUploadRepository.getEnBDataByPath(ciqPgmIdAndCiqName, "IPPLAN",
									 * neId,"eNB_OAM_IP&eNB_S&B_IP");
									 */
									String useGeneratedScriptsCheck = generateScriptMap
											.get(useCaseName + "_" + uploadFileEntity.getFileName());

									String[] scriptNameSplit = uploadFileEntity.getFileName().split("\\.");
									String checkLsmName = null;
									if (useGeneratedScriptsCheck != null
											&& "YES".equalsIgnoreCase(useGeneratedScriptsCheck.trim())) {
										File folder = new File(generatedPath.toString());
										if (!folder.exists()) {
											FileUtil.createDirectory(generatedPath.toString());
										}

										File[] listOfFiles = folder.listFiles();
										ArrayList<String> listOfFile = new ArrayList<>();
										if (listOfFiles.length > 0) {
											for (File file : listOfFiles) {
												listOfFile.add(file.getName());
											}

											String sLsmName = lsmName;
											String sUseCaseName = useCaseName;

											if (sLsmName.contains("_")) {
												sLsmName = charRemoveAt(sLsmName);
											}

											if (sUseCaseName.contains("_")) {
												sUseCaseName = charRemoveAt(sUseCaseName);
											}

											if (scriptNameSplit[0].contains("_")) {
												scriptNameSplit[0] = charRemoveAt(scriptNameSplit[0]);
											}

											sLsmName = sLsmName.replaceAll("\\s", "");
											sUseCaseName = sUseCaseName.replaceAll("\\s", "");
											scriptNameSplit[0] = scriptNameSplit[0].replaceAll("\\s", "");
											useCaseName = useCaseName.trim().replaceAll("\\s", "_");

											String filePathwithName = scriptExeSeq + "_" + sLsmName + "_" + sUseCaseName
													+ "_" + iUseCaseId + "_" + scriptNameSplit[0] + "_" + scriptId + "."
													+ scriptNameSplit[1];
											if (listOfFile.contains(filePathwithName)) {
												// do nothing
											} else {
												generateScriptWithOutExe5GAudit(neId, neName, sProgramId, migrationType,
														migrationSubType, uploadFileEntity, enbIP, neEntity,
														useCaseName, sessionId, lsmName, iUseCaseId, useCaseExeSeq,
														scriptId, scriptExeSeq, lsmId, useCurrPassword, sanePassword,
														userName, lsmVersion, ciqFileName, neType);
											}

										} else {
											generateScriptWithOutExe5GAudit(neId, neName, sProgramId, migrationType,
													migrationSubType, uploadFileEntity, enbIP, neEntity, useCaseName,
													sessionId, lsmName, iUseCaseId, useCaseExeSeq, scriptId,
													scriptExeSeq, lsmId, useCurrPassword, sanePassword, userName,
													lsmVersion, ciqFileName, neType);
										}

									} else {
										generateScriptWithOutExe5GAudit(neId, neName, sProgramId, migrationType,
												migrationSubType, uploadFileEntity, enbIP, neEntity, useCaseName,
												sessionId, lsmName, iUseCaseId, useCaseExeSeq, scriptId, scriptExeSeq,
												lsmId, useCurrPassword, sanePassword, userName, lsmVersion, ciqFileName,
												neType);
									}

									checkLsmName = lsmName;

									if (checkLsmName.contains("_")) {
										checkLsmName = charRemoveAt(checkLsmName);
									}

									checkLsmName = checkLsmName.replaceAll("\\s", "");

									File folder = new File(generatedPath.toString());
									File[] listOfFiles = folder.listFiles();

									if (listOfFiles.length > 0) {
										for (File file : listOfFiles) {
											String fileName = file.getName();
											if (fileName.contains(checkLsmName)
													&& fileName.contains(Integer.toString(iUseCaseId))
													&& fileName.contains(Integer.toString(scriptId))
													&& fileName.contains(Integer.toString(scriptExeSeq))) {
												finalListFile.add(fileName);
											} else {
												// do nothing
											}
										}
									}

								} else {
									// do nothing
								}
							}
						}

						Map<Integer, String> scriptExehashMap = new HashMap<>();

						for (String fileName : finalListFile) {

							String[] scriptExeSeq = fileName.split("_");
							int iScriptExeSeq = Integer.parseInt(scriptExeSeq[0]);

							scriptExehashMap.put(iScriptExeSeq, fileName);

						}

						Map<Integer, String> scriptexeSortedByExeSeqMap = scriptExehashMap.entrySet().stream()
								.sorted(Map.Entry.comparingByKey()).collect(Collectors.toMap(Map.Entry::getKey,
										Map.Entry::getValue, (e1, e2) -> e1, LinkedHashMap::new));

						// updating runTestEntity to update the generated script path before running the
						// run test
						mainloop1: for (Entry<Integer, String> file : scriptexeSortedByExeSeqMap.entrySet()) {
							String orderFileName = file.getValue();
							String fileNameWithPath = generatedPath.toString() + "/" + orderFileName;
							String filePathWithRunTestId = generatedPath.toString()
									+ runTestEntityMap.get(neId).getId();
							File dir = new File(filePathWithRunTestId);
							if (!dir.exists()) {
								FileUtil.createDirectory(filePathWithRunTestId);
							}
							FileUtils.copyFileToDirectory(new File(fileNameWithPath), dir);
							String filePath = filePathWithRunTestId.toString() + "/" + orderFileName;
							generateScriptPath = generateScriptPath
									+ filePath.replace(LoadPropertyFiles.getInstance().getProperty("BASE_PATH"), "")
									+ ",";

							if (StringUtils.isNotEmpty(generateScriptPath)) {
								runTestEntityMap.get(neId).setGenerateScriptPath(
										generateScriptPath.substring(0, generateScriptPath.length() - 1));
								runTestRepository.updateRunTest(runTestEntityMap.get(neId));
							}
						}
						// performance increasing
						Map<String, Boolean> createHtmlMapboo = new HashMap<>();
						AtomicBoolean sanePasswordBoo = new AtomicBoolean();
						sanePasswordBoo.set(true);
						// New Implementation: Nov-04-2020 : Audit HtmlName
						StringBuilder auditname = new StringBuilder();
						mainloop1: for (Entry<Integer, String> file : scriptexeSortedByExeSeqMap.entrySet()) {
							// Duration by tool
							LocalDateTime lshtool1 = LocalDateTime.now();
							long dshsec = 0;
							// swetha
							String orderFileName = file.getValue();

							// for (String orderFileName : finalListFile) {

							String fileNameWithPath = generatedPath.toString() + "/" + orderFileName;
							String dbcollectionFileName = CommonUtil.createMongoDbFileName(String.valueOf(programId),
									ciqFileName);
							String vznEnbIP = fileUploadRepository.getEnBDataByPath(dbcollectionFileName,
									Constants.VZ_GROW_IPPLAN, neId,
									Constants.ORAN_SPRINT_COMM_SCRIPT_eNB_OAM_IP_eNB_S_B_IP);
							String eNB_OAM_IP = fileUploadRepository.getEnBDataByPath(dbcollectionFileName,
									Constants.SPT_GROW_SHEET_FDD_TDD, neId,
									Constants.ORAN_SPRINT_COMM_SCRIPT_8_CHG_IP_ADDR);
							String enbIP = "127.0.0.1";

							if (StringUtils.isNotEmpty(vznEnbIP)) {
								enbIP = vznEnbIP;
							} else if (StringUtils.isNotEmpty(eNB_OAM_IP)) {
								String sprintEnbIP = CommonUtil.getLeftSubStringWithLen(eNB_OAM_IP, 3);
								if (StringUtils.isNotEmpty(sprintEnbIP)) {
									enbIP = sprintEnbIP;
								} else {
									enbIP = eNB_OAM_IP;
								}
							}

							String output = "";
							String shelloutput = "";
							String outputFileName = "";
							String outputFileNameAudit = "";
							StringBuilder newOutputFileDBPath = new StringBuilder();
							StringBuilder newOutputFilePath = new StringBuilder();

							String[] useCaseNameSplit = orderFileName.split("_");
							int iScriptExeSeq = Integer.parseInt(useCaseNameSplit[0]);
							String useCaseName = useCaseNameSplit[2];
							int scriptId = Integer.parseInt(useCaseNameSplit[5].split("\\.")[0]);
							String descFinalPath = "";
							String scriptFileName = useCaseNameSplit[4];
							iUseCaseId = Integer.parseInt(useCaseNameSplit[3]);

							UseCaseBuilderEntity useCaseBuilderEntity = runTestRepository.getUseCaseEntity(iUseCaseId);
							String originalUseCaseName = useCaseBuilderEntity.getUseCaseName();

							UploadFileEntity scriptEntity = runTestRepository.getScriptInfo(scriptId);

							if (scriptEntity.getFileName().contains(XmlCommandsConstants.AU_DIAGNOSTIC)) {
								continue;
							} else if (scriptEntity.getFileName().contains(XmlCommandsConstants.IAU_DIAGNOSTIC)) {
								continue;
							} else if (scriptEntity.getFileName()
									.contains(XmlCommandsConstants.AUDIT_4G_OCNS_TEST_TERMINATE)
									|| scriptEntity.getFileName().contains(XmlCommandsConstants.AUDIT_4G_CHECK_RSSI)
									|| scriptEntity.getFileName()
											.contains(XmlCommandsConstants.AUDIT_4G_CHECK_TXPOWER)
											|| scriptEntity.getFileName().contains(XmlCommandsConstants.AUDIT_4G_RSSIIMBALANCE)) {
								continue;
							} else if (scriptEntity.getFileName().contains(XmlCommandsConstants.CBAND_F1U_DESTINATIONIP)
									|| scriptEntity.getFileName().contains(XmlCommandsConstants.CBAND_F1U_TESTTWPING)
									|| scriptEntity.getFileName()
											.contains(XmlCommandsConstants.CBAND_F1U_TESTTWPING_DIAGNOSIS)) {
								continue;
							} else if (scriptEntity.getFileName().contains(XmlCommandsConstants.DSS_F1U_DESTINATIONIP)
									|| scriptEntity.getFileName().contains(XmlCommandsConstants.DSS_F1U_TESTTWPING)
									|| scriptEntity.getFileName()
											.contains(XmlCommandsConstants.DSS_F1U_TESTTWPING_DIAGNOSIS)) {
								continue;
							}else if (scriptEntity.getFileName().contains(XmlCommandsConstants.AUDIT_4G_FCC_CBSD_INFO)
									|| scriptEntity.getFileName().contains(XmlCommandsConstants.AUDIT_4G_CONFIGURE_FCC_ID)) {
								continue;
							}

							/// not included
							// swetha
							String scriptAbsFileName = LoadPropertyFiles.getInstance().getProperty("BASE_PATH")
									+ scriptEntity.getFilePath() + "/" + originalUseCaseName.trim().replaceAll(" ", "_")
									+ "/" + scriptEntity.getFileName();

							scriptFilesDetails.put(scriptAbsFileName, scriptEntity.getPrompt());
							// not included
							/*
							 * List<CheckListDetailsModel> sheetList =
							 * ciqUploadRepository.getCheckListAllSheetNames( checklistFileName,
							 * CommonUtil.createMongoDbFileNameCheckList(sProgramId, checklistFileName,
							 * ciqFileName)); Set<String> sheetDetails = sheetList.stream().map(x ->
							 * x.getSheetName()) .collect(Collectors.toSet());
							 * 
							 * RunTestEntity runTestEntityDetails =
							 * runTestRepository.getRunTestEntityDetails(programId, migrationType,
							 * migrationSubType, testname, neName);
							 * 
							 * if (sheetDetails != null) { for (String sheet : sheetDetails) {
							 * ciqUploadRepository .insertChecklistDetails(
							 * CommonUtil.createMongoDbFileNameCheckList(sProgramId, checklistFileName,
							 * ciqFileName), sheet, neName, remarks, runTestEntityDetails.getId()); } }
							 */
							StringBuilder outputFilePath = new StringBuilder();

							StringBuilder comFilePath = new StringBuilder();
							String scriptArguments = scriptEntity.getArguments();

							// Template changes starts
							String connectionLocationUserName = null;
							String connectionLocationPwd = "";
							String connectionSudoPassword = "";

							ProgramTemplateEntity programTemplateEntity = fileUploadRepository
									.getProgramTemplate(programId, Constants.SCRIPT_STORE_TEMPLATE);
							if (programTemplateEntity != null) {
								if (programTemplateEntity.getValue() != null
										&& !programTemplateEntity.getValue().trim().isEmpty()) {
									JSONObject objData = CommonUtil.parseDataToJSON(programTemplateEntity.getValue());
									HashMap connLocation = (HashMap) objData.get("connLocation");

									// NE
									HashMap ne = (HashMap) connLocation.get("NE");
									connectionSudoPassword = ne.get("sudoPassword").toString();
									connectionLocationUserName = ne.get("username").toString();
									connectionLocationPwd = ne.get("password").toString();

								}
							}
							String finalArguments = "";
							// Template changes end
							if (CommonUtil.isValidObject(scriptArguments) && StringUtils.isNotEmpty(scriptArguments)) {
								String[] arguments = scriptArguments.split(Constants.DELIMITER);
								if (CommonUtil.isValidObject(arguments) && arguments.length > 0) {
									for (String argument : arguments) {
										String argPreceeding = "";
										argument = argument.trim();
										if (argument.contains(" ") && argument.contains("-")
												&& argument.startsWith("-")) {
											argPreceeding = StringUtils.substringBefore(argument, " ");
											argPreceeding = argPreceeding.trim();
											argument = StringUtils.substringAfter(argument, " ");
											argument = argument.trim();
										}
										UserDetailsEntity userDetailsEntity = userActionRepositoryImpl
												.getUserDetailsBasedName(userName);
										String saneUserName = "";
										String sanePwd = "";
										if (CommonUtil.isValidObject(userDetailsEntity)) {
											saneUserName = userDetailsEntity.getVpnUserName();
										}
										if (useCurrPassword == true) {
											sanePwd = PasswordCrypt.decrypt(userDetailsEntity.getVpnPassword());
										} else {
											sanePwd = sanePassword;
										}
										String newArgument = commonUtil.getArgumentValue(Integer.toString(programId),
												ciqFileName, neId, neName, networkConfigEntity, migrationType,
												migrationSubType, argument, userName, sessionId,
												connectionLocationUserName, connectionLocationPwd,
												connectionSudoPassword, saneUserName, sanePwd);
										if (argPreceeding != null) {
											if (argPreceeding.trim().contains("-")) {
												finalArguments = finalArguments + " " + argPreceeding + " ";
											}
										}
										if (newArgument != null) {
											newArgument = "'" + newArgument + "'";
										}
										finalArguments = finalArguments + newArgument + " ";

									}
								}
							}
							comFilePath.append(LoadPropertyFiles.getInstance().getProperty("BASE_PATH"))
									.append(Constants.CUSTOMER).append(Constants.SEPARATOR).append(programId);

							if (migrationType.equalsIgnoreCase(Constants.POST_MIGRATION)
									|| migrationType.equalsIgnoreCase(Constants.PRE_MIGRATION)) {

								outputFilePath.append(comFilePath)
										.append(Constants.RUN_MIGRATION_OUTPUT.replace("migration", migrationType)
												.replace("enbId", StringUtils.substringBeforeLast(neId, "."))
												.replace("subtype", migrationSubType).replaceAll(" ", "_"));

								newOutputFilePath.append(comFilePath)
										.append(Constants.RUN_MIGRATION_OUTPUT.replace("migration", migrationType)
												.replace("enbId", StringUtils.substringBeforeLast(neId, "."))
												.replace("subtype", migrationSubType).replaceAll(" ", "_"))
										.append(testname).append("_").append(StringUtils.substringBeforeLast(neId, "."))
										.append("_").append(neName).append("/");

								newOutputFileDBPath.append(Constants.SEPARATOR).append(Constants.CUSTOMER)
										.append(Constants.SEPARATOR).append(programId).append(Constants.SEPARATOR)
										.append(Constants.RUN_MIGRATION_OUTPUT.replace("migration", migrationType)
												.replace("enbId", StringUtils.substringBeforeLast(neId, "."))
												.replace("subtype", migrationSubType).replaceAll(" ", "_"))
										.append(testname).append("_").append(StringUtils.substringBeforeLast(neId, "."))
										.append("_").append(neName).append("/");

								String timeStamp = new SimpleDateFormat("yyyy-MM-dd_HH:mm:ss").format(new Date());

								auditHtmlFileName.setLength(0);
								auditHtmlFileName.append("AUDIT_" + neId + "_" + timeStamp + ".html");

								auditHtmlFilePath.setLength(0);
								auditHtmlFilePath.append(comFilePath)
										.append(Constants.RUN_MIGRATION_OUTPUT.replace("migration", migrationType)
												.replace("enbId", StringUtils.substringBeforeLast(neId, "."))
												.replace("subtype", migrationSubType).replaceAll(" ", "_"))
										.append(auditHtmlFileName.toString());

								File newFilePath = new File(newOutputFilePath.toString());
								newFilePath.mkdirs();

								File outFilePath = new File(outputFilePath.toString());
								outFilePath.mkdirs();

								outputFileNameAudit = outputFilePath + serviceToken + "_" + "output.txt";

								// String subtype = null;
								if ("AUDIT".equalsIgnoreCase(migrationSubType)
										|| "PREAUDIT".equalsIgnoreCase(migrationSubType)) {
									// subtype = "Audit"; Audit

									String endName = "";
									if (StringUtils.isNotEmpty(scriptEntity.getFileName())) {
										endName = scriptEntity.getFileName().substring(0,
												scriptEntity.getFileName().indexOf('_'));
									}

									if ("DSS".equalsIgnoreCase(endName)) {
										auditHtmlFileName.setLength(0);
										auditHtmlFileName.append(
												"AUDIT" + "_" + neId + "_" + timeStamp + ".html");

										auditHtmlFilePath.setLength(0);
										auditHtmlFilePath.append(comFilePath)
												.append(Constants.RUN_MIGRATION_OUTPUT
														.replace("migration", migrationType)
														.replace("enbId", StringUtils.substringBeforeLast(neId, "."))
														.replace("subtype", migrationSubType).replaceAll(" ", "_"))
												.append(auditHtmlFileName.toString());
									}

									if ((scriptEntity.getFileName().contains(XmlCommandsConstants.AU_TWAMP_F1C_LINK))||
									(scriptEntity.getFileName().contains(XmlCommandsConstants.IAU_TWAMP_F1C_LINK))) {
										auditname.append("_TWAMP");

										auditHtmlFileName.setLength(0);
										auditHtmlFileName
												.append("AUDIT" + auditname + "_" + neId + "_" + timeStamp + ".html");

										auditHtmlFilePath.setLength(0);
										auditHtmlFilePath.append(comFilePath)
												.append(Constants.RUN_MIGRATION_OUTPUT
														.replace("migration", migrationType)
														.replace("enbId", StringUtils.substringBeforeLast(neId, "."))
														.replace("subtype", migrationSubType).replaceAll(" ", "_"))
												.append(auditHtmlFileName.toString());
									}
									

									if ("eNB".equalsIgnoreCase(endName)) {
										try {
											dbcollectionFileName = CommonUtil.createMongoDbFileName(sProgramId,
													ciqFileName);
											LinkedHashSet<String> siteIds = getEnbsiteIds(neId, ciqFileName,
													dbcollectionFileName);
											String dataDetails = readFile(fileNameWithPath);
											char ch = '"';
											String neType = Constants.NE_TYPE_ENB;
											if (!ObjectUtils.isEmpty(siteIds) && StringUtils.isNotEmpty(dataDetails)
													&& dataDetails.contains("send " + ch + "curl")) {
												List<String> curlComandsInput = getAllCurlCommands(dataDetails);

												String startConnection = dataDetails.substring(0,
														dataDetails.indexOf("send " + ch + "curl"));
												StringBuilder endConnection = buildConnectionEndScript(
														networkConfigEntity, scriptEntity, programId, neType,
														useCaseName);
												StringBuilder shellOutput5g = new StringBuilder();
												required5GOutputEnb.append(
														FilenameUtils.removeExtension(scriptEntity.getFileName()));
												required5GOutputEnb.append("\n\n");
												for (String siteId : siteIds) {

													String curlCommand = getCurlCommandWithSiteId(siteId,
															curlComandsInput);

													StringBuilder shCommand = new StringBuilder();
													shCommand.append(startConnection);
													shCommand.append("\n\n");
													shCommand.append(curlCommand);
													shCommand.append("\n\n");
													shCommand.append(endConnection);

													String enbSpecificFile = fileNameWithPath.replaceAll(orderFileName,
															"");
													enbSpecificFile = enbSpecificFile + Constants.SEPARATOR
															+ "EnbSites";

													File folder = new File(enbSpecificFile.toString());

													if (!folder.exists()) {
														FileUtil.createDirectory(enbSpecificFile.toString());
													}

													String enbSite = "eNB_" + siteId + "_" + orderFileName;
													enbSpecificFile = enbSpecificFile + Constants.SEPARATOR + enbSite;

													File fileWithNameExist = new File(enbSpecificFile);

													if (fileWithNameExist.exists()) {
														fileWithNameExist.delete();
													}
													writeEnbFilles(enbSpecificFile, shCommand.toString());
													shelloutput = "";
													if (sanePasswordBoo.get()) {
														LocalDateTime lsh1 = LocalDateTime.now();
														JSONObject duoData = isDuoApplicable(scriptEntity,
																networkConfigEntity, useCurrPassword, sanePassword);
														if (duoData.containsKey("status")
																&& duoData.get("status").equals(Constants.SUCCESS)) {
															String tempCommand = getCurlCommandAuditEnb(neId,
																	sProgramId, migrationType, scriptEntity, neEntity,
																	originalUseCaseName, ciqFileName, siteId);
															System.out.println("--------------Command --------------");
															System.out.println(tempCommand);
															System.out.println("--------------Command --------------");
															if(isMultipleDUo.get()) {
																shelloutput = duoSessionAU(userName, outputFileNameAudit,
																		scriptEntity.getFileName(), duoData, tempCommand, neId,
																		sProgramId);
															}else{
																shelloutput = duoSession(userName, outputFileNameAudit,
																		scriptEntity.getFileName(), duoData, tempCommand);
																
															}
															
														} else if (!duoData.containsKey("reason")) {
															shelloutput = executeCommand5GAudit(enbSpecificFile,
																	outputFileNameAudit, finalArguments, "");
														} else {
															shelloutput = duoData.get("reason").toString();
														}

														LocalDateTime lsh2 = LocalDateTime.now();
														dshsec = Duration.between(lsh1, lsh2).getSeconds();
														if (dshsec > Constants.SSH_TIMEOUT
																&& !shelloutput.contains("<rpc-reply")
																&& !shelloutput.contains("</rpc-reply>")) {
															shelloutput = shelloutput
																	+ "\n\nMessage from SRCT : SSH Timeout";
														}

													}
													if (shelloutput.contains("spawn id exp")) {
														sanePasswordBoo.set(false);
													}
													String dataOutputEnb = getRequiredOutPut5GAuditEnb(shelloutput,
															"eNB_" + siteId);
													required5GOutputEnb.append(dataOutputEnb);
													shellOutput5g.append(shelloutput);
													shelloutput = shellOutput5g.toString();
												}
												if (required5GOutputEnb.toString().contains("<rpc-reply")
														&& !(required5GOutputEnb.toString().contains("<rpc-error"))) {
													createHtmlMapboo.put(
															FilenameUtils.removeExtension(scriptEntity.getFileName()),
															true);
												} else {
													createHtmlMapboo.put(
															FilenameUtils.removeExtension(scriptEntity.getFileName()),
															false);
												}
												required5GOutputEnb.append("\n\n");
												required5GOutputEnb.append(XmlCommandsConstants.ENDTEXT5G);
												required5GOutputEnb.append("\n\n");

											}

										} catch (Exception e) {
											e.printStackTrace();
										}

									} else if (scriptEntity.getFileName()
											.contains(XmlCommandsConstants.AUDIT_4G_OCNS_TEST_CELL_NUM)) {
										shelloutput = audit4gTestUtil.get4GTestOutput(scriptEntity, "", neId,
												dbcollectionFileName, networkConfigEntity, useCurrPassword,
												sanePassword, neEntity, sProgramId, migrationType, originalUseCaseName,
												ciqFileName, userName, outputFileNameAudit, createHtmlMapboo,
												required5GOutput,isMultipleDUo);
									}else if (scriptEntity.getFileName()
											.contains(XmlCommandsConstants.AUDIT_4G_CARRIER_RSSI)) {
										shelloutput = audit4gTestUtil2.get4GTestOutput(scriptEntity, "", neId,
												dbcollectionFileName, networkConfigEntity, useCurrPassword,
												sanePassword, neEntity, sProgramId, migrationType, originalUseCaseName,
												ciqFileName, userName, outputFileNameAudit, createHtmlMapboo,
												required5GOutput);
									} else if (scriptEntity.getFileName()
											.contains(XmlCommandsConstants.CBAND_F1U_SOURCEIP)) {
										shelloutput = audit5GCbandUtil.getCbandTwampOutput(scriptEntity, "", neId,
												dbcollectionFileName, networkConfigEntity, useCurrPassword,
												sanePassword, neEntity, sProgramId, migrationType, originalUseCaseName,
												ciqFileName, userName, outputFileNameAudit, createHtmlMapboo,
												required5GOutput,isMultipleDUo);
									} else if (scriptEntity.getFileName()
											.contains(XmlCommandsConstants.DSS_F1U_SOURCEIP)) {
										shelloutput = audit5GDSSUtil.getCbandTwampOutput(scriptEntity, "", neId,
												dbcollectionFileName, networkConfigEntity, useCurrPassword,
												sanePassword, neEntity, sProgramId, migrationType, originalUseCaseName,
												ciqFileName, userName, outputFileNameAudit, createHtmlMapboo,
												required5GOutput,isMultipleDUo);
									}
									 else if(scriptEntity.getFileName().contains(XmlCommandsConstants.CBAND_VDU_MMUAUDIT)){
										shelloutput = audit5GCbandMMUUtil2.getCbandMMUAudit(scriptEntity, "", neId,
												dbcollectionFileName, networkConfigEntity, useCurrPassword,
												sanePassword, neEntity, sProgramId, migrationType, originalUseCaseName,
												ciqFileName, userName, outputFileNameAudit, createHtmlMapboo,
												required5GOutput,isMultipleDUo);
										
									}else if((scriptEntity.getFileName().contains(XmlCommandsConstants.CBAND_VDU_MH1IPFETCH))
											|| (scriptEntity.getFileName().contains(XmlCommandsConstants.DSS_VDU_MH1IPFETCH))){
										shelloutput = auditCbandMH1IPFetch.getmh1iPAudit(scriptEntity, "", neId,
												dbcollectionFileName, networkConfigEntity, useCurrPassword,
												sanePassword, neEntity, sProgramId, migrationType, originalUseCaseName,
												ciqFileName, userName, outputFileNameAudit, createHtmlMapboo,
												required5GOutput,isMultipleDUo);
										
									}//rssi
										else if(scriptEntity.getFileName().contains(XmlCommandsConstants.RSSI_USE_CASE)){
											shelloutput = rssiTestUtil.getRSSIAudit(scriptEntity, "", neId, dbcollectionFileName, 
													networkConfigEntity, useCurrPassword,
													sanePassword, neEntity, sProgramId, migrationType, originalUseCaseName,
													ciqFileName, userName, outputFileNameAudit, createHtmlMapboo,
													required5GOutput,isMultipleDUo);
										}else if(scriptEntity.getFileName().contains(XmlCommandsConstants.AUDIT4G_FSU_GROWPREFIX)){
										shelloutput = audit4gTestUtil3.getTestOutput(scriptEntity, "", neId,
												dbcollectionFileName, networkConfigEntity, useCurrPassword,
												sanePassword, neEntity, sProgramId, migrationType, originalUseCaseName,
												ciqFileName, userName, outputFileNameAudit, createHtmlMapboo,
												required5GOutput);
										
									}else if(scriptEntity.getFileName().contains(XmlCommandsConstants.AU_GROWPREFIX)){
										shelloutput = audit5GMMTestUtil.getTestOutput5GMM(scriptEntity, "", neId,
												dbcollectionFileName, networkConfigEntity, useCurrPassword,
												sanePassword, neEntity, sProgramId, migrationType, originalUseCaseName,
												ciqFileName, userName, outputFileNameAudit, createHtmlMapboo,
												required5GOutput,isMultipleDUo);
										
									}else if(scriptEntity.getFileName().contains(XmlCommandsConstants.DSS_VDU_GROWPREFIX)){
										shelloutput = audit5GDSSTestUtil.getTestOutput5GDSS(scriptEntity, "", neId,
												dbcollectionFileName, networkConfigEntity, useCurrPassword,
												sanePassword, neEntity, sProgramId, migrationType, originalUseCaseName,
												ciqFileName, userName, outputFileNameAudit, createHtmlMapboo,
												required5GOutput,isMultipleDUo);
										
									}else if(scriptEntity.getFileName().contains(XmlCommandsConstants.CBAND_VDU_GROWPREFIX)){
										shelloutput = audit5GCBANDTestUtil.getTestOutput5GCBAND(scriptEntity, "", neId,
												dbcollectionFileName, networkConfigEntity, useCurrPassword,
												sanePassword, neEntity, sProgramId, migrationType, originalUseCaseName,
												ciqFileName, userName, outputFileNameAudit, createHtmlMapboo,
												required5GOutput,isMultipleDUo);
										
									}else if(scriptEntity.getFileName().contains(XmlCommandsConstants.AUDIT_4G_GROWPREFIX)){
										shelloutput = audit4GUSMGrowUtil.getTestOutput4GUSMGROW(scriptEntity, "", neId,
												dbcollectionFileName, networkConfigEntity, useCurrPassword,
												sanePassword, neEntity, sProgramId, migrationType, originalUseCaseName,
												ciqFileName, userName, outputFileNameAudit, createHtmlMapboo,
												required5GOutput,isMultipleDUo);
										
									}else if(scriptEntity.getFileName().contains(XmlCommandsConstants.IAU_5GMMGROWPREFIX)){
										shelloutput = audit5GMMIAUTestUtil.getTestOutputIAU5GMM(scriptEntity, "", neId,
												dbcollectionFileName, networkConfigEntity, useCurrPassword,
												sanePassword, neEntity, sProgramId, migrationType, originalUseCaseName,
												ciqFileName, userName, outputFileNameAudit, createHtmlMapboo,
												required5GOutput,isMultipleDUo);
										
									}else if (scriptEntity.getFileName()
											.contains(XmlCommandsConstants.CBAND_VDU_MMUREPORTINGTOOL)) {
										shelloutput = cbandMMUReportingToolUtil.getmmuReportingToolOutput(scriptEntity, "", neId,
												dbcollectionFileName, networkConfigEntity, useCurrPassword,
												sanePassword, neEntity, sProgramId, migrationType, originalUseCaseName,
												ciqFileName, userName, outputFileNameAudit, createHtmlMapboo,
												required5GOutput,isMultipleDUo);
									}else if (scriptEntity.getFileName()
											.contains(XmlCommandsConstants.AUDIT_4G_FCC_RETRIEVE_RADIO_UNIT_INVENTORY)) {
										shelloutput = audit4GFccIdUtil.get4GFCCTestOutput(scriptEntity, "", neId,
												dbcollectionFileName, networkConfigEntity, useCurrPassword,
												sanePassword, neEntity, sProgramId, migrationType, originalUseCaseName,
												ciqFileName, userName, outputFileNameAudit, createHtmlMapboo,
												required5GOutput,isMultipleDUo);
									}

									else {

										if (sanePasswordBoo.get()) {
											LocalDateTime lsh1 = LocalDateTime.now();
											// logger.error("Executing Script : " + scriptEntity.getFileName() + " NE :
											// " + neId + " at : " + lsh1);
											JSONObject duoData = isDuoApplicable(scriptEntity, networkConfigEntity,
													useCurrPassword, sanePassword);
											if (duoData.containsKey("status")
													&& duoData.get("status").equals(Constants.SUCCESS)) {
												JSONObject resultCurlCommand = getCurlCommandAudit(neId, sProgramId,
														migrationType, scriptEntity, neEntity, originalUseCaseName,
														ciqFileName);
												if (resultCurlCommand.containsKey("status")
														&& resultCurlCommand.get("status").equals(Constants.SUCCESS)) {
													String tempCommand = resultCurlCommand.get("command").toString();
													System.out.println("--------------Command --------------");
													System.out.println(tempCommand);
													System.out.println("--------------Command --------------");
													if (isMultipleDUo.get() && sProgramId.equals("34")) {
														logger.error("DB LOGS:  Before Calling duoSession : "+neId);
														shelloutput = duoSessionNeId(userName, outputFileNameAudit,
																scriptEntity.getFileName(), duoData, tempCommand, neId,
																sProgramId);
														logger.error("DB LOGS:  After Calling duoSession : "+neId);
													}else if (isMultipleDUo.get() && !programName2.contains("4G")) {
														logger.error("DB LOGS:  Before Calling duoSession : "+neId);
														shelloutput = duoSessionAU(userName, outputFileNameAudit,
																scriptEntity.getFileName(), duoData, tempCommand, neId,
																sProgramId);
														logger.error("DB LOGS:  After Calling duoSession : "+neId);
													} else {
														logger.error("DB LOGS:  Before Calling duoSession : "+neId);
														shelloutput = duoSession(userName, outputFileNameAudit,
																scriptEntity.getFileName(), duoData, tempCommand);
														logger.error("DB LOGS:  After Calling duoSession : "+neId);
													}
												} else if (resultCurlCommand.containsKey("reason")) {
													shelloutput = resultCurlCommand.get("reason").toString();
												}

											} else if (!duoData.containsKey("reason")) {
												shelloutput = executeCommand5GAudit(fileNameWithPath,
														outputFileNameAudit, finalArguments, "");
											} else {
												shelloutput = duoData.get("reason").toString();
											}
										 //shelloutput = returnshellop(scriptEntity.getFileName());;
											LocalDateTime lsh2 = LocalDateTime.now();
											// logger.error("Completed Script : " + scriptEntity.getFileName() + " NE :
											// " + neId + " at : " + lsh2);
											dshsec = Duration.between(lsh1, lsh2).getSeconds();
											if (dshsec > Constants.SSH_TIMEOUT && !shelloutput.contains("<rpc-reply")
													&& !shelloutput.contains("</rpc-reply>")) {
												shelloutput = shelloutput + "\n\nMessage from SRCT : SSH Timeout";
											}
											logger.error("Duration for script in server : " + scriptEntity.getFileName()
													+ " NE : " + neId + "(HH:mm:ss) : " + String.format("%d:%02d:%02d",
															dshsec / 3600, (dshsec % 3600) / 60, dshsec % 60));
										}
										if (shelloutput.contains("spawn id exp")) {
											sanePasswordBoo.set(false);
										}
										if (shelloutput.contains("<rpc-reply")
												&& !(shelloutput.contains("<rpc-error"))) {
											createHtmlMapboo.put(
													FilenameUtils.removeExtension(scriptEntity.getFileName()), true);
										} else {
											createHtmlMapboo.put(
													FilenameUtils.removeExtension(scriptEntity.getFileName()), false);
										}

										String dataOutput = getRequiredOutPut5GAudit(shelloutput,
												scriptEntity.getFileName());
										required5GOutput.append(dataOutput);
										required5GOutput.append("/n");
										if (scriptEntity.getFileName().contains(XmlCommandsConstants.CBAND_VDU_SERIALNUMMMU)) {
											createHtmlMapboo.put(
													FilenameUtils.removeExtension(scriptEntity.getFileName()), true);
											String twampshellop = getSerialNumberOv(scriptEntity, dataOutput, neId,
													dbcollectionFileName, networkConfigEntity, useCurrPassword,
													sanePassword, neEntity, sProgramId, migrationType,
													originalUseCaseName, ciqFileName, userName, outputFileNameAudit,isMultipleDUo,neName,programName2);
											
											shelloutput = shelloutput + "\n" + twampshellop;

											String dataOutput1 = getRequiredOutPut5GOV(twampshellop,
													XmlCommandsConstants.CBAND_VDU_OVOUTPUT + ".xml");
											required5GOutput.append(dataOutput1);
											required5GOutput.append("/n");
											}
										if (scriptEntity.getFileName().contains(XmlCommandsConstants.AUDIT_4G_SERIAL_NUMBER)) {
											createHtmlMapboo.put(
													FilenameUtils.removeExtension(scriptEntity.getFileName()), true);
											String twampshellop = getSerialNumberOvUSM(scriptEntity, dataOutput, neId,
													dbcollectionFileName, networkConfigEntity, useCurrPassword,
													sanePassword, neEntity, sProgramId, migrationType,
													originalUseCaseName, ciqFileName, userName, outputFileNameAudit,isMultipleDUo,neName,programName2);
											
											shelloutput = shelloutput + "\n" + twampshellop;

											String dataOutput1 = getRequiredOutPut5GOV(twampshellop,
													XmlCommandsConstants.AUDIT_4G_OVOUTPUT + ".xml");
											required5GOutput.append(dataOutput1);
											required5GOutput.append("/n");
											}

										if (scriptEntity.getFileName().contains(XmlCommandsConstants.AU_TWAMP_F1C_LINK)
												&& shelloutput.contains("<rpc-reply")
												&& !(shelloutput.contains("<rpc-error"))) {
											String twampshellop = gettwampoutput(scriptEntity, dataOutput, neId,
													dbcollectionFileName, networkConfigEntity, useCurrPassword,
													sanePassword, neEntity, sProgramId, migrationType,
													originalUseCaseName, ciqFileName, userName, outputFileNameAudit,isMultipleDUo);
										
										
											if (!(twampshellop.contains("<rpc-reply")
													&& !(twampshellop.contains("<rpc-error")))) {
												createHtmlMapboo.remove(
														FilenameUtils.removeExtension(scriptEntity.getFileName()));
											}
											
											shelloutput = shelloutput + "\n" + twampshellop;

											String dataOutput1 = getRequiredOutPut5GAuditTwamp(twampshellop,
													XmlCommandsConstants.AU_DIAGNOSTIC + ".xml");
											required5GOutput.append(dataOutput1);
											required5GOutput.append("/n");

											JSONObject twampf1uop = gettwampoutputF1U(scriptEntity, neId,
													dbcollectionFileName, networkConfigEntity, useCurrPassword,
													sanePassword, neEntity, sProgramId, migrationType,
													originalUseCaseName, ciqFileName, userName, outputFileNameAudit,isMultipleDUo);
											if (twampf1uop.containsKey("required5GOutput")
													&& twampf1uop.containsKey("shelloutput")) {
												shelloutput = shelloutput + "\n"
														+ twampf1uop.get("shelloutput").toString();
												required5GOutput.append(twampf1uop.get("required5GOutput").toString());
											}

										} 
										if (scriptEntity.getFileName()
												.contains(XmlCommandsConstants.IAU_TWAMP_F1C_LINK)
												&& shelloutput.contains("<rpc-reply")
												&& !(shelloutput.contains("<rpc-error"))) {
											String twampshellop = gettwampoutputIAU(scriptEntity, dataOutput, neId,
													dbcollectionFileName, networkConfigEntity, useCurrPassword,
													sanePassword, neEntity, sProgramId, migrationType,
													originalUseCaseName, ciqFileName, userName, outputFileNameAudit,isMultipleDUo);
											
										

											if (!(twampshellop.contains("<rpc-reply")
													&& !(twampshellop.contains("<rpc-error")))) {
												createHtmlMapboo.remove(
														FilenameUtils.removeExtension(scriptEntity.getFileName()));
											}
											
											shelloutput = shelloutput + "\n" + twampshellop;

											String dataOutput1 = getRequiredOutPut5GAuditTwamp(twampshellop,
													XmlCommandsConstants.IAU_DIAGNOSTIC + ".xml");
											required5GOutput.append(dataOutput1);
											required5GOutput.append("/n");

											JSONObject twampf1uop = gettwampoutputF1UIAU(scriptEntity, neId,
													dbcollectionFileName, networkConfigEntity, useCurrPassword,
													sanePassword, neEntity, sProgramId, migrationType,
													originalUseCaseName, ciqFileName, userName, outputFileNameAudit,isMultipleDUo);
											if (twampf1uop.containsKey("required5GOutput")
													&& twampf1uop.containsKey("shelloutput")) {
												shelloutput = shelloutput + "\n"
														+ twampf1uop.get("shelloutput").toString();
												required5GOutput.append(twampf1uop.get("required5GOutput").toString());
											}

										}
										
										
										

									}
									// shelloutput = readFileAsString("/home/user/Desktop/audit_response");

								}
								String path = LoadPropertyFiles.getInstance().getProperty("BASE_PATH") + "Customer/"
										+ programId + "/" + migrationType + "/" + neId + "/" + migrationSubType + "/"
										+ "Output" + "/";

								File duplicatePath = new File(path);
								duplicatePath.mkdirs();

								if ("AUDIT".equalsIgnoreCase(migrationSubType)
										|| "PREAUDIT".equalsIgnoreCase(migrationSubType)) {

									timeStamp = new SimpleDateFormat("MMddyyyy_HH_mm_ss")
											.format(new Timestamp(System.currentTimeMillis()));
									String newOutputFileName = serviceToken + "_" + useCaseName + "_" + scriptFileName
											+ "_" + timeStamp + ".txt";
									descFinalPath = newOutputFilePath.toString() + newOutputFileName;
									FileWriter fileWriter = new FileWriter(descFinalPath);
									fileWriter.write(shelloutput);
									fileWriter.close();
								}

								// CommonUtil.removeCtrlChars(outputFileNameAudit);
								CommonUtil.removeCtrlChars(descFinalPath);

							}

							// complted executing

							UseCaseBuilderParamEntity useCaseBuilderParamEntity = null;

							for (int j = 0; j < scriptFinalLst.size(); j++) {
								ArrayList scritlst = (ArrayList) scriptFinalLst.get(j);
								int scriptID = (int) scritlst.get(0);

								if (scriptID == scriptEntity.getId()) {
									int scrpitid12 = (int) scritlst.get(2);
									useCaseBuilderParamEntity = useCaseBuilderRepository
											.getUseCaseBuilderParamEntity(scrpitid12);
									break;
								}
							}

							LinkedHashSet<UseCaseCmdRuleEntity> useCaseCmdRuleEntityset = useCaseBuilderParamEntity
									.getUseCaseCmdRuleEntitySet().parallelStream()
									.sorted((p1, p2) -> p1.getId().compareTo(p2.getId()))
									.collect((Collectors.toCollection(LinkedHashSet::new)));

							LinkedHashSet<UseCaseShellRuleEntity> useCaseShellRuleEntityset = useCaseBuilderParamEntity
									.getUseCaseShellRuleEntitySet().parallelStream()
									.sorted((p1, p2) -> p1.getId().compareTo(p2.getId()))
									.collect((Collectors.toCollection(LinkedHashSet::new)));

							LinkedHashSet<UseCaseFileRuleEntity> useCaseFileRuleEntityset = useCaseBuilderParamEntity
									.getUseCaseFileRuleEntitySet().parallelStream()
									.sorted((p1, p2) -> p1.getId().compareTo(p2.getId()))
									.collect((Collectors.toCollection(LinkedHashSet::new)));

							LinkedHashSet<UseCaseXmlRuleEntity> useCaseXmlRuleEntityset = useCaseBuilderParamEntity
									.getUseCaseXmlRuleEntitySet().parallelStream()
									.sorted((p1, p2) -> p1.getId().compareTo(p2.getId()))
									.collect((Collectors.toCollection(LinkedHashSet::new)));

							RunTestEntity runTestEntity = runTestEntityMap.get(neId);

							UseCaseBuilderEntity useCaseBuilderEntitybyId = useCaseBuilderService
									.getUseCaseBuilderEntity(iUseCaseId);

							UploadFileEntity uploadFileEntity = uploadFileRepository.getUploadFileEntity(scriptId);
							// Performance Upgradation
							ConcurrentHashMap<Integer, List<RunTestResultEntity>> runtestResultEntityListMap = new ConcurrentHashMap<>();

							for (UseCaseXmlRuleEntity xml : useCaseXmlRuleEntityset) {
								XmlRuleBuilderEntity xmlRuleEntity = xml.getXmlRuleBuilderEntity();
								int xmlRuleOccurenece = xml.getXmlRuleSequence();
								String xmlResult = "FAIL";

								if (xmlRuleEntity != null
										&& !ObjectUtils.isEmpty(xmlRuleEntity.getXmlElementEntitySet())) {

									Set<XmlElementEntity> elementSet = xmlRuleEntity.getXmlElementEntitySet();
									// Set<XmlElementEntity> listOfEntityes=new LinkedHashSet<>();
									// listOfEntityes.addAll(elementSet);
									if (!ObjectUtils.isEmpty(elementSet.isEmpty())) {
										if (elementrulesMap.containsKey(
												FilenameUtils.removeExtension(uploadFileEntity.getFileName()))) {
											Set<XmlElementEntity> listOfEntityes = elementrulesMap
													.get(FilenameUtils.removeExtension(uploadFileEntity.getFileName()));
											listOfEntityes.addAll(elementSet);
											elementrulesMap.put(
													FilenameUtils.removeExtension(uploadFileEntity.getFileName()),
													listOfEntityes);
										} else {
											elementrulesMap.put(
													FilenameUtils.removeExtension(uploadFileEntity.getFileName()),
													elementSet);
										}
									}
								}

								xmlResult = xmlParsing5GAudit(xmlRuleEntity, required5GOutput.toString(),
										xmlRuleOccurenece, neName, neId, dbcollectionFileName);

								Object obj = new JSONParser().parse(xmlResult);
								JSONObject jo = (JSONObject) obj;
								xmlResult = (String) jo.get("outputResult");
								Map ruleResultJsonMap = (Map) jo.get("ruleResultJson");
								String ruleResultJson = ruleResultJsonMap.toString();

								if (!"PASS".equalsIgnoreCase(xmlResult)) {
									finalStatusResult = FAILURE;
								}

								RunTestResultEntity runTestResultEntity = new RunTestResultEntity();
								runTestResultEntity.setRunTestEntity(runTestEntity);

								runTestResultEntity.setUseCaseBuilderEntity(useCaseBuilderEntitybyId);
								runTestResultEntity.setUploadFileEntity(uploadFileEntity);

								runTestResultEntity.setXmlRuleBuilderEntity(xmlRuleEntity);

								runTestResultEntity.setCurrentResult(xmlResult);
								runTestResultEntity.setCurrentScriptOutput(newOutputFileDBPath.toString());
								runTestResultEntity.setCustomerDetailsEntity(customerDetailsEntity);
								runTestResultEntity.setMigrationType(migrationType);
								runTestResultEntity.setMigrationSubType(migrationSubType);
								runTestResultEntity.setNeName(neId);
								runTestResultEntity.setRuleResultJson(ruleResultJson);
								runTestResultEntity.setScriptExeSeq(iScriptExeSeq);
								if (runtestResultEntityListMap.containsKey(scriptId)) {
									runtestResultEntityListMap.get(scriptId).add(runTestResultEntity);
								} else {
									List<RunTestResultEntity> runtestResultEntityList = new ArrayList<>();
									runtestResultEntityList.add(runTestResultEntity);
									runtestResultEntityListMap.put(scriptId, runtestResultEntityList);
								}

								runTestResultRepository.createRunTestResult(runTestResultEntity);

							}

							for (UseCaseShellRuleEntity j : useCaseShellRuleEntityset) {
								ShellCmdRuleBuilderEntity shellRuleEntity = j.getShellRuleBuilderEntity();
								int shellRuleOccurence = j.getShellRuleSequence();
								String shellResult = "FAIL";

								shellResult = shellProcess(shellRuleEntity, shelloutput, shellRuleOccurence, neName,
										neId);

								if (!"PASS".equalsIgnoreCase(shellResult)) {
									finalStatusResult = FAILURE;
								}

								RunTestResultEntity runTestResultEntity = new RunTestResultEntity();
								runTestResultEntity.setRunTestEntity(runTestEntity);

								runTestResultEntity.setUseCaseBuilderEntity(useCaseBuilderEntitybyId);
								runTestResultEntity.setUploadFileEntity(uploadFileEntity);

								runTestResultEntity.setShellCmdRuleBuilderEntity(shellRuleEntity);

								runTestResultEntity.setCurrentResult(shellResult);
								runTestResultEntity.setCurrentScriptOutput(newOutputFileDBPath.toString());
								runTestResultEntity.setCustomerDetailsEntity(customerDetailsEntity);
								runTestResultEntity.setMigrationType(migrationType);
								runTestResultEntity.setMigrationSubType(migrationSubType);
								runTestResultEntity.setNeName(neId);
								runTestResultEntity.setScriptExeSeq(iScriptExeSeq);
								if (runtestResultEntityListMap.containsKey(scriptId)) {
									runtestResultEntityListMap.get(scriptId).add(runTestResultEntity);
								} else {
									List<RunTestResultEntity> runtestResultEntityList = new ArrayList<>();
									runtestResultEntityList.add(runTestResultEntity);
									runtestResultEntityListMap.put(scriptId, runtestResultEntityList);
								}
								runTestResultRepository.createRunTestResult(runTestResultEntity);

							}

							for (UseCaseCmdRuleEntity j : useCaseCmdRuleEntityset) {
								CmdRuleBuilderEntity cmdRuleEntity = j.getCmdRuleBuilderEntity();
								int cmRuleOccurence = j.getCommandRuleSequence();
								String cmdResult = "FAIL";

								/*
								 * if ("AUDIT".equalsIgnoreCase(migrationSubType)) { shelloutput =
								 * readFileAsString(outputFileNameAudit); }else { shelloutput =
								 * readFileAsString(outputFileName); }
								 */

								cmdResult = cliProcess(cmdRuleEntity, shelloutput, cmRuleOccurence, neName, neId);

								Object obj = new JSONParser().parse(cmdResult);
								JSONObject jo = (JSONObject) obj;
								cmdResult = (String) jo.get("outputResult");
								Map ruleResultJsonMap = (Map) jo.get("ruleResultJson");
								String ruleResultJson = ruleResultJsonMap.toString();

								if (!"PASS".equalsIgnoreCase(cmdResult)) {
									finalStatusResult = FAILURE;
								}

								RunTestResultEntity runTestResultEntity = new RunTestResultEntity();
								runTestResultEntity.setRunTestEntity(runTestEntity);

								runTestResultEntity.setUseCaseBuilderEntity(useCaseBuilderEntitybyId);
								runTestResultEntity.setUploadFileEntity(uploadFileEntity);

								runTestResultEntity.setCmdRuleBuilderEntity(cmdRuleEntity);

								runTestResultEntity.setCurrentResult(cmdResult);
								runTestResultEntity.setCurrentScriptOutput(newOutputFileDBPath.toString());
								runTestResultEntity.setCustomerDetailsEntity(customerDetailsEntity);
								runTestResultEntity.setMigrationType(migrationType);
								runTestResultEntity.setMigrationSubType(migrationSubType);
								runTestResultEntity.setNeName(neId);
								runTestResultEntity.setRuleResultJson(ruleResultJson);
								runTestResultEntity.setScriptExeSeq(iScriptExeSeq);
								if (runtestResultEntityListMap.containsKey(scriptId)) {
									runtestResultEntityListMap.get(scriptId).add(runTestResultEntity);
								} else {
									List<RunTestResultEntity> runtestResultEntityList = new ArrayList<>();
									runtestResultEntityList.add(runTestResultEntity);
									runtestResultEntityListMap.put(scriptId, runtestResultEntityList);
								}

								runTestResultRepository.createRunTestResult(runTestResultEntity);

							}
							StringBuilder fileFinaloutput = new StringBuilder();
							for (UseCaseFileRuleEntity entity : useCaseFileRuleEntityset) {
								FileRuleBuilderEntity fileRuleEntity = entity.getFileRuleBuilderEntity();

								String fileName1 = "admin_" + fileRuleEntity.getFileName();
								// int count = fileRule.getOccCount();
								int count = 2;
								String serachParam = fileRuleEntity.getSearchParameter();
								String status = fileRuleEntity.getStatus();
								String finalResult = "FAIL";
								String outputString = null;

								boolean result = fileExists(fileName1);
								if (result) {
									Map finalResultMap = paramCount(fileName1, count, serachParam, status);
									outputString = (String) finalResultMap.get("outputString");

									fileFinaloutput = fileFinaloutput.append("\nfileName :").append(fileName1)
											.append("\n").append(outputString);

									FileWriter fileWriter = new FileWriter(descFinalPath, true);
									fileWriter.write(shelloutput);
									fileWriter.close();

									finalResult = (String) finalResultMap.get("status");
								}

								if (!"PASS".equalsIgnoreCase(finalResult)) {
									finalStatusResult = FAILURE;
								}

								RunTestResultEntity runTestResultEntity = new RunTestResultEntity();
								runTestResultEntity.setRunTestEntity(runTestEntity);

								runTestResultEntity.setUseCaseBuilderEntity(useCaseBuilderEntitybyId);
								runTestResultEntity.setUploadFileEntity(uploadFileEntity);

								runTestResultEntity.setFileRuleBuilderEntity(fileRuleEntity);

								runTestResultEntity.setCurrentResult(finalResult);
								runTestResultEntity.setCurrentScriptOutput(newOutputFileDBPath.toString());
								runTestResultEntity.setCustomerDetailsEntity(customerDetailsEntity);
								runTestResultEntity.setMigrationType(migrationType);
								runTestResultEntity.setMigrationSubType(migrationSubType);
								runTestResultEntity.setNeName(neId);
								runTestResultEntity.setScriptExeSeq(iScriptExeSeq);
								if (runtestResultEntityListMap.containsKey(scriptId)) {
									runtestResultEntityListMap.get(scriptId).add(runTestResultEntity);
								} else {
									List<RunTestResultEntity> runtestResultEntityList = new ArrayList<>();
									runtestResultEntityList.add(runTestResultEntity);
									runtestResultEntityListMap.put(scriptId, runtestResultEntityList);
								}

								runTestResultRepository.createRunTestResult(runTestResultEntity);

							}

							if (useCaseFileRuleEntityset.isEmpty() && useCaseCmdRuleEntityset.isEmpty()
									&& useCaseXmlRuleEntityset.isEmpty() && useCaseShellRuleEntityset.isEmpty()) {

								RunTestResultEntity runTestResultEntity = new RunTestResultEntity();

								// runTestResultEntity.setRunTestId(runTestEntityMap.get(neId).getId());
								runTestResultEntity.setRunTestEntity(runTestEntity);

								runTestResultEntity.setUseCaseBuilderEntity(useCaseBuilderEntitybyId);
								runTestResultEntity.setUploadFileEntity(uploadFileEntity);

								runTestResultEntity.setCurrentResult("PASS");
								runTestResultEntity.setCurrentScriptOutput(newOutputFileDBPath.toString());
								runTestResultEntity.setCustomerDetailsEntity(customerDetailsEntity);
								runTestResultEntity.setMigrationType(migrationType);
								runTestResultEntity.setMigrationSubType(migrationSubType);
								runTestResultEntity.setNeName(neId);
								runTestResultEntity.setScriptExeSeq(iScriptExeSeq);
								if (runtestResultEntityListMap.containsKey(scriptId)) {
									runtestResultEntityListMap.get(scriptId).add(runTestResultEntity);
								} else {
									List<RunTestResultEntity> runtestResultEntityList = new ArrayList<>();
									runtestResultEntityList.add(runTestResultEntity);
									runtestResultEntityListMap.put(scriptId, runtestResultEntityList);
								}

								runTestResultRepository.createRunTestResult(runTestResultEntity);
							}

							if (shelloutput.contains("DUO ERROR:")) {
								/*for (Map usecase : useCaseList) {
									if (usecase.get("useCaseName").equals("rssiImbalance_RangeCheck") && !createHtmlMapboo.containsKey("RSSI_USE_CASE")) {
										audit4GSummaryService.createAudit4GSummaryEntity(102, runTestEntity.getId(),
												neid.get("neId").toString().replaceAll("^0+(?!$)", ""),
												"RSSI_USE_CASE" + " : " + "Script_Not_Executed");
									}
								}*/
								break mainloop1;

							}
							// kannan
							// }
							List<RunTestResultEntity> resultList = runtestResultEntityListMap.get(scriptId);
							boolean status = false;
							for (RunTestResultEntity runTestResultEntity : resultList) {
								if (runTestResultEntity.getCurrentResult().equalsIgnoreCase("PASS")) {
									status = true;
								} else {
									status = false;
									break;
								}
							}

							// need to write some code balu

							/*
							 * if (status) {
							 * 
							 * NeMappingModel neMappingModel = new NeMappingModel(); CustomerDetailsEntity
							 * programDetailsEntity = new CustomerDetailsEntity();
							 * programDetailsEntity.setId(programId);
							 * neMappingModel.setProgramDetailsEntity(programDetailsEntity);
							 * neMappingModel.setEnbId(neId); List<NeMappingEntity> neMappingEntities =
							 * neMappingService.getNeMapping(neMappingModel);
							 * 
							 * CheckListScriptDetEntity checkListScriptDetEntity =
							 * useCaseBuilderRepositoryImpl .getCheckListDetails(programId);
							 * List<CheckListScriptDetEntity> CheckListScriptDetails = null; if
							 * ("AUDIT".equalsIgnoreCase(migrationSubType)) { CheckListScriptDetails =
							 * useCaseBuilderRepositoryImpl.getExeseq(programId,
							 * uploadFileEntity.getFileName(), null,
							 * checkListScriptDetEntity.getCheckListFileName()); } else if
							 * ("PreCheck".equalsIgnoreCase(migrationSubType)) { CheckListScriptDetails =
							 * useCaseBuilderRepositoryImpl.getExeseq(programId,
							 * uploadFileEntity.getFileName(), null,
							 * checkListScriptDetEntity.getCheckListFileName()); } else {
							 * CheckListScriptDetails = useCaseBuilderRepositoryImpl.getExeseq(programId,
							 * uploadFileEntity.getFileName(), neMappingEntities.get(0).getSiteConfigType(),
							 * checkListScriptDetEntity.getCheckListFileName()); }
							 * 
							 * List<CheckListModel> checkListModel =
							 * ciqUploadRepository.getCheckListDetails( "checkListModel", neName,
							 * runTestEntity.getId(), CheckListScriptDetails.get(0).getStepIndex()); //
							 * CheckListModel checkListModel = new CheckListModel();
							 * 
							 * CheckListModel createCheckListEntity = new CheckListModel();
							 * createCheckListEntity.setRunTestId(runTestEntity.getId());
							 * createCheckListEntity.setStepIndex(CheckListScriptDetails.get(0).getStepIndex
							 * ());
							 * 
							 * if (!checkListModel.isEmpty()) { LinkedHashMap<String, String> map =
							 * checkListModel.get(0).getCheckListMap(); // LinkedHashMap<String, String> map
							 * = new LinkedHashMap(); map.put("check", "true");
							 * createCheckListEntity.setCheckListMap(map);
							 * 
							 * ciqUploadRepository.updateCheckListFileDetails(createCheckListEntity,
							 * "checkListModel", neName); } }
							 */
							LocalDateTime lshtool2 = LocalDateTime.now();
							long dshtool = Duration.between(lshtool1, lshtool2).getSeconds() - dshsec;
							logger.error("Duration for script in tool : " + scriptEntity.getFileName() + " NE : " + neId
									+ "(HH:mm:ss) : " + String.format("%d:%02d:%02d", dshtool / 3600,
											(dshtool % 3600) / 60, dshtool % 60));
						}
						for (Map usecase : useCaseList) {
							if (usecase.get("useCaseName").equals("eNB_PreAudit")) {
								savePreResponse(neId, required5GOutput,programId);
							}}
						StringBuilder comFilePath = new StringBuilder();
						comFilePath.append(LoadPropertyFiles.getInstance().getProperty("BASE_PATH"))
								.append(Constants.CUSTOMER).append(Constants.SEPARATOR).append(programId);

						StringBuilder outputFilePath = new StringBuilder();

						outputFilePath.append(comFilePath)
								.append(Constants.RUN_MIGRATION_OUTPUT.replace("migration", migrationType)
										.replace("enbId", StringUtils.substringBeforeLast(neId, "."))
										.replace("subtype", migrationSubType).replaceAll(" ", "_"));

						String outputFileName = outputFilePath + serviceToken + "_" + "output.txt";

						CommonUtil.removeCtrlChars(outputFileName);
						String programName = customerDetailsEntity.getProgramName();
						if ((migrationType.equalsIgnoreCase(Constants.POST_MIGRATION)
								&& "AUDIT".equalsIgnoreCase(migrationSubType))
								|| "PREAUDIT".equalsIgnoreCase(migrationSubType)) {

							createAuditHtmlFile5GAudit(auditHtmlFilePath.toString(), runTestEntityMap.get(neId).getId(),
									ciqFileName, neId, neName, lsmName, scriptFilesDetails, networkConfigEntity, "xml",
									required5GOutput, elementrulesMap, required5GOutputEnb, programName,
									createHtmlMapboo);
							
						}
						// kannankumar ends
						
						for (Map usecase : useCaseList) {
							if ((usecase.get("useCaseName").equals("rssiImbalance_RangeCheck") || 
									usecase.get("useCaseName").equals("rssiImbalance_RangeCheck1"))
									&& !createHtmlMapboo.containsKey("RSSI_USE_CASE")
									&& programName.contains("4G-USM-LIVE")) {
								audit4GSummaryService.createAudit4GSummaryEntity(102,
										runTestEntityMap.get(neId).getId(),
										neid.get("neId").toString().replaceAll("^0+(?!$)", ""),
										"RSSI_USE_CASE" + " : " + "DUO SANE ERROR : RSSI Test did not run because of DUO SANE issue");
							}
						}

						int ucsleep = getUCSleepInterval(useCaseList, iUseCaseId);

						Thread.sleep(ucsleep);
						String fileSavePath = StringUtils.substringBeforeLast(auditHtmlFilePath.toString(), "/");
						fileSavePath = fileSavePath.replace(LoadPropertyFiles.getInstance().getProperty("BASE_PATH"),
								"");
						if (createHtmlMapboo.isEmpty()) {
							auditHtmlFileName.setLength(0);
							fileSavePath = "";
						}
						if (!sanePasswordBoo.get() || !createHtmlMapboo.containsValue(true)
								|| createHtmlMapboo.containsValue(false)) {
							finalStatusResult = FAILURE;
						}
						if (programName.contains("4G-USM-LIVE")) {
							List<Audit4GSummaryEntity> audit4GSummaryEntityList = audit4GSummaryService
									.getAudit4GSummaryEntityListByRunTestId(runTestEntityMap.get(neId).getId());

							if (audit4GSummaryEntityList != null && !audit4GSummaryEntityList.isEmpty()) {
								finalStatusResult = FAILURE;
								try {
									List<Audit4GSummaryEntity> audit4GSummaryEntityListInfoList = audit4GSummaryEntityList
											.stream().filter(x -> x.getAudit4gRulesEntity().getErrorCode()
													.toUpperCase().contains("INFO"))
											.collect(Collectors.toList());
									if (audit4GSummaryEntityListInfoList.size() == audit4GSummaryEntityList
											.size()) {
										finalStatusResult = "Success";
									}
								} catch (Exception e) {
									finalStatusResult = FAILURE;
									logger.error(ExceptionUtils.getMessage(e));
								}
							}
						} else if (programName.contains("5G-CBAND")) {
							List<Audit5GCBandSummaryEntity> audit5GCBandSummaryEntityList = audit5GCBandSummaryService
									.getAudit5GCBandSummaryEntityListByRunTestId(runTestEntityMap.get(neId).getId());
							if (audit5GCBandSummaryEntityList != null && !audit5GCBandSummaryEntityList.isEmpty()) {
								finalStatusResult = FAILURE;
								try {
									List<Audit5GCBandSummaryEntity> audit5GCBandSummaryEntityInfoList = audit5GCBandSummaryEntityList
											.stream().filter(x -> x.getAudit5gCbandRulesEntity().getErrorCode()
													.toUpperCase().contains("INFO"))
											.collect(Collectors.toList());
									if (audit5GCBandSummaryEntityInfoList.size() == audit5GCBandSummaryEntityList
											.size()) {
										finalStatusResult = "Success";
									}
								} catch (Exception e) {
									finalStatusResult = FAILURE;
									logger.error(ExceptionUtils.getMessage(e));
								}
							}
						} else if (programName.contains("5G-DSS")) {
							List<Audit5GDSSSummaryEntity> audit5GDSSSummaryEntityList = audit5GDSSSummaryService
									.getAudit5GDSSSummaryEntityListByRunTestId(runTestEntityMap.get(neId).getId());
							if (audit5GDSSSummaryEntityList != null && !audit5GDSSSummaryEntityList.isEmpty()) {
								finalStatusResult = FAILURE;
								try {
									List<Audit5GDSSSummaryEntity> audit5GDSSSummaryEntityInfoList = audit5GDSSSummaryEntityList
											.stream().filter(x -> x.getAudit5gCbandRulesEntity().getErrorCode()
													.toUpperCase().contains("INFO"))
											.collect(Collectors.toList());
									if (audit5GDSSSummaryEntityInfoList.size() == audit5GDSSSummaryEntityList.size()) {
										finalStatusResult = "Success";
									}
								} catch (Exception e) {
									finalStatusResult = FAILURE;
									logger.error(ExceptionUtils.getMessage(e));
								}
							}
						}else if (programName.contains("4G-FSU")) {
							List<Audit4GFsuSummaryEntity> audit4GFsuSummaryEntityList = audit4GFsuSummaryService
									.getAudit4GFsuSummaryEntityListByRunTestId(runTestEntityMap.get(neId).getId());

							if (audit4GFsuSummaryEntityList != null && !audit4GFsuSummaryEntityList.isEmpty()) {
								finalStatusResult = FAILURE;
							}
							
						}
						boolean RSSICheck=false;
						for (Map usecase : useCaseList) {
							String UseCaseName=usecase.get("useCaseName").toString();
							if ((UseCaseName.contains("rssiImbalance_RangeCheck"))){
								RSSICheck=true;
								System.out.println("RSSI Check is:True");
								break;
							}
									
						}
						
						boolean Type2 = false;
						if(run.containsKey("ovUpdate")) {
						Type2 = (boolean) run.get("ovUpdate");
						logger.error("OVupdate Key is "+Type2 );
						//System.out.println("OVupdate Key is ",Type2);
						}
					/*	if ( migrationSubType.equalsIgnoreCase("AUDIT") && Type2 && !RSSICheck )
						{
							String orderNo;
							if(migrationSubType.equalsIgnoreCase("AUDIT")) {
								ProgramTemplateEntity programTemplateEntity = fileUploadService.getProgramTemplate(programId,
										Constants.POST_MIGRATION_MILESTONE);
								orderNo=programTemplateEntity.getValue();
							}else {
								ProgramTemplateEntity programTemplateEntity = fileUploadService.getProgramTemplate(programId,
										Constants.MIGRATION_MILESTONE);
								orderNo=programTemplateEntity.getValue().toString();
							}
							String[] Mile=orderNo.split(",");
							JSONObject ovUpdateJson = new JSONObject();
							ovUpdateJson.put("neid", neId);
							ovUpdateJson.put("programName", programName);
							ovUpdateJson.put("programId", programId);
							ovUpdateJson.put("ciqFileName", ciqFileName);
							ovUpdateJson.put("enbName", neName);
							String date2=DateUtil.dateToString(new Date(), "yyyy-MM-dd HH:mm:ss");
							JSONObject trakerIdDetails = getTrakerIdList(ovUpdateJson,runTestEntityMap);
							logger.error("Tracker details:" + trakerIdDetails);
							String TrackerID="";
							String WorkplanID="";
							if (trakerIdDetails != null && trakerIdDetails.containsKey("trakerjson")) {
								List<TrackerDetailsModel> trakerdetails = (List<TrackerDetailsModel>) trakerIdDetails
										.get("trakerjson");
								if (!ObjectUtils.isEmpty(trakerdetails)) 
								{
													for (TrackerDetailsModel locTrackerDetailsModel : trakerdetails)
													{
														TrackerID=locTrackerDetailsModel.getTrackerId();
														logger.error("TrackerID:" + TrackerID);
													}
													JSONObject workPlanDetailsObject = getWorkPlanIdList(TrackerID);
													if (workPlanDetailsObject != null && workPlanDetailsObject.containsKey("workPlanjson"))
													{
														logger.error("Inside workPlanjson" + workPlanDetailsObject);
														TrackerDetailsModel workTrackerDetailsModel = (TrackerDetailsModel) workPlanDetailsObject.get("workPlanjson");
															if (!ObjectUtils.isEmpty(workTrackerDetailsModel)) 
															{
																WorkplanID= workTrackerDetailsModel.getWorkPlanId();
																JSONObject updateJsonAPI = patchMileStone(WorkplanID,migrationSubType,programId,runTestEntityMap,neId,Mile);
															}else
															{   for(int i=0;i<=Mile.length-1;i++) {
																	OvTestResultEntity ovTestResultEntity= new OvTestResultEntity();
																	ovTestResultEntity.setCurrentResult("["+date2+"]"+"-"+"failed to fetch  workplan ID for Tracker ID:"+TrackerID+",workplane ID fetching API has  empty respond");
																	RunTestEntity runTestEntity = getRunTestEntity(runTestEntityMap.get(neId).getId());
																	ovTestResultEntity.setRunTestEntity(runTestEntity);
																	ovTestResultEntity.setMilestone(Mile[i]);
																	runTestRepository.updateRunTestov(ovTestResultEntity);
																	runTestEntityMap.get(neId).setOvUpdateStatus("Failure");
																	runTestRepository.updateRunTest(runTestEntityMap.get(neId));
																	
															}
															logger.error("fail in 2nd Api" );
															}
													 }else 
													 {		for(int i=0;i<=Mile.length-1;i++) {
															OvTestResultEntity ovTestResultEntity= new OvTestResultEntity();
															ovTestResultEntity.setCurrentResult("["+date2+"]"+"-"+"failed to fetch  workplan ID for Tracker ID:"+TrackerID+",workplane ID fetching API has  empty respond");
															RunTestEntity runTestEntity = getRunTestEntity(runTestEntityMap.get(neId).getId());
															ovTestResultEntity.setRunTestEntity(runTestEntity);
															ovTestResultEntity.setMilestone(Mile[i]);
															runTestRepository.updateRunTestov(ovTestResultEntity);
															runTestEntityMap.get(neId).setOvUpdateStatus("Failure");
															//runTestEntityMap.get(neId).setOvUpdateReason("failed to fetch the workplan ID for Tracker ID:"+TrackerID);
															runTestRepository.updateRunTest(runTestEntityMap.get(neId));
															
													 }
													 logger.error("fail in 2nd Api" );
													 }
								}else
								{	
									for(int i=0;i<=Mile.length-1;i++) {
								
									OvTestResultEntity ovTestResultEntity= new OvTestResultEntity();
									ovTestResultEntity.setCurrentResult("["+date2+"]"+"-"+"failed to fetch the Tracker ID/ No Tracker ID on OV for: "+neId);
									RunTestEntity runTestEntity = getRunTestEntity(runTestEntityMap.get(neId).getId());
									ovTestResultEntity.setRunTestEntity(runTestEntity);
									ovTestResultEntity.setMilestone(Mile[i]);
									runTestRepository.updateRunTestov(ovTestResultEntity);
									runTestEntityMap.get(neId).setOvUpdateStatus("Failure");
									
									runTestRepository.updateRunTest(runTestEntityMap.get(neId));
									}
									logger.error("fail in 1nd Api" );
								}
								}else
								{
									for(int i=0;i<=Mile.length-1;i++) {
									OvTestResultEntity ovTestResultEntity= new OvTestResultEntity();
									if(trakerIdDetails.containsKey("reason")) {
									String reason=trakerIdDetails.get("reason").toString();
									ovTestResultEntity.setCurrentResult("["+date2+"]"+"-"+reason);
									}else {
										ovTestResultEntity.setCurrentResult("["+date2+"]"+"-"+"failed to fetch the Tracker ID/ No Tracker ID on OV for: "+neId);
									}
								
									//ovTestResultEntity.setCurrentResult("failed to fetch the Tracker ID");
									RunTestEntity runTestEntity = getRunTestEntity(runTestEntityMap.get(neId).getId());
									ovTestResultEntity.setRunTestEntity(runTestEntity);
									ovTestResultEntity.setMilestone(Mile[i]);
									runTestRepository.updateRunTestov(ovTestResultEntity);
									runTestEntityMap.get(neId).setOvUpdateStatus("Failure");
									//runTestEntityMap.get(neId).setOvUpdateReason("failed to fetch the Tracker ID " );
									
									runTestRepository.updateRunTest(runTestEntityMap.get(neId));
									}
									logger.error("fail in 1nd Api" );
								}
								
						}*/
						if (RSSICheck && Type2 && programName.contains("4G-USM-LIVE")) {
							//String preExisting= "RRH,FA_ID,EARFCN,FINAL_RSSI_SANITY_RESULT\nRRH_0_0_0,0,5230,FAIL,PASS";
							String preExisting=    rSSIAuditXmlRulesServiceUtil.getpreexiting(required5GOutput.toString(),XmlCommandsConstants.RSSI_USE_CASE).toString();
							if (preExisting!=null && !preExisting.isEmpty()) 
							{
							JSONObject ovUpdateJson = new JSONObject();
							ovUpdateJson.put("neid", neId);
							ovUpdateJson.put("programName", programName);
							ovUpdateJson.put("programId", programId);
							ovUpdateJson.put("ciqFileName", ciqFileName);
							ovUpdateJson.put("enbName", neName);
							String daTaPresent ="";
							String date2=DateUtil.dateToString(new Date(), "yyyy-MM-dd HH:mm:ss'");
							JSONObject preExistingDataInOV = getpreExistingDataInOV(ovUpdateJson,runTestEntityMap);
							if (preExistingDataInOV !=null && preExistingDataInOV.containsKey("P_PREEXISTING_RSSI")) {
							 daTaPresent =preExistingDataInOV.get("P_PREEXISTING_RSSI").toString();
							}
							if(!daTaPresent.equalsIgnoreCase("true")) {
							JSONObject trakerIdDetails = getTrakerIdList(ovUpdateJson,runTestEntityMap);
							String TrackerID="";
							String WorkplanID="";
							if (trakerIdDetails != null && trakerIdDetails.containsKey("trakerjson")) {
								List<TrackerDetailsModel> trakerdetails = (List<TrackerDetailsModel>) trakerIdDetails
										.get("trakerjson");
								if (!ObjectUtils.isEmpty(trakerdetails)) 
								{
													for (TrackerDetailsModel locTrackerDetailsModel : trakerdetails)
													{
														TrackerID=locTrackerDetailsModel.getTrackerId();
														logger.error("TrackerID:" + TrackerID);
													}
													JSONObject updateJsonAPI = patchMileStoneRSSI(TrackerID,migrationSubType,programId,runTestEntityMap,neId,preExisting);
												//	JSONObject trakerIdDetails = getTrakerIdList(ovUpdateJson,runTestEntityMap);patchMileStoneRSSI
								}else
								{	
									
								
									OvTestResultEntity ovTestResultEntity= new OvTestResultEntity();
									ovTestResultEntity.setCurrentResult("["+date2+"]"+"-"+"failed to fetch the Tracker ID/ No Tracker ID on OV for: "+neId);
									RunTestEntity runTestEntity = getRunTestEntity(runTestEntityMap.get(neId).getId());
									ovTestResultEntity.setRunTestEntity(runTestEntity);
									ovTestResultEntity.setMilestone("P_PREEXISTING_RSSI");
									ovTestResultEntity.setRssiContant(preExisting);
									runTestRepository.updateRunTestov(ovTestResultEntity);
									runTestEntityMap.get(neId).setOvUpdateStatus("Failure");
									
									runTestRepository.updateRunTest(runTestEntityMap.get(neId));
									
									logger.error("fail in 1nd Api" );
								}
								}else
								{
									 date2=DateUtil.dateToString(new Date(), "yyyy-MM-dd HH:mm:ss");
									 System.out.println(date2);
									OvTestResultEntity ovTestResultEntity= new OvTestResultEntity();
									if(trakerIdDetails.containsKey("reason")) {
									String reason=trakerIdDetails.get("reason").toString();
									ovTestResultEntity.setCurrentResult("["+date2+"]"+"-"+reason);
									}else {
										ovTestResultEntity.setCurrentResult("["+date2+"]"+"-"+"failed to fetch the Tracker ID/ No Tracker ID on OV for: "+neId);
									}
								
									//ovTestResultEntity.setCurrentResult("failed to fetch the Tracker ID");
									RunTestEntity runTestEntity = getRunTestEntity(runTestEntityMap.get(neId).getId());
									ovTestResultEntity.setRunTestEntity(runTestEntity);
									ovTestResultEntity.setMilestone("P_PREEXISTING_RSSI");
									ovTestResultEntity.setRssiContant(preExisting);
									runTestRepository.updateRunTestov(ovTestResultEntity);
									runTestEntityMap.get(neId).setOvUpdateStatus("Failure");
									//runTestEntityMap.get(neId).setOvUpdateReason("failed to fetch the Tracker ID " );
									
									runTestRepository.updateRunTest(runTestEntityMap.get(neId));
									
									logger.error("fail in 1nd Api" );
								}
							}else {
								date2=DateUtil.dateToString(new Date(), "yyyy-MM-dd HH:mm:ss");
								 System.out.println(date2);
								 if(preExistingDataInOV.containsKey("reason")) {
									 	OvTestResultEntity ovTestResultEntity= new OvTestResultEntity(); 
									 	String reason=preExistingDataInOV.get("reason").toString();
										ovTestResultEntity.setCurrentResult("["+date2+"]"+"-"+reason);
										RunTestEntity runTestEntity = getRunTestEntity(runTestEntityMap.get(neId).getId());
										ovTestResultEntity.setRunTestEntity(runTestEntity);
										ovTestResultEntity.setMilestone("P_PREEXISTING_RSSI");
										ovTestResultEntity.setRssiContant(preExisting);
										runTestRepository.updateRunTestov(ovTestResultEntity);
										runTestEntityMap.get(neId).setOvUpdateStatus("Failure");
										//runTestEntityMap.get(neId).setOvUpdateReason("failed to fetch the Tracker ID " );
										runTestRepository.updateRunTest(runTestEntityMap.get(neId));
								 }else {
									 runTestEntityMap.get(neId).setOvUpdateStatus("N/A");
									 runTestRepository.updateRunTest(runTestEntityMap.get(neId));
										
								 }
							}}else {
							runTestEntityMap.get(neId).setOvUpdateStatus("N/A");
							//runTestEntityMap.get(neId).setOvUpdateReason("failed to fetch the Tracker ID " );
							
							runTestRepository.updateRunTest(runTestEntityMap.get(neId));
							
						}
						
						}
						
						runTestEntityMap.get(neId).setResult(auditHtmlFileName.toString());
						runTestEntityMap.get(neId).setResultFilePath(fileSavePath);
						runTestRepository.updateRunTest(runTestEntityMap.get(neId));
						if(Type2) {
							JSONObject ovUpdateJson = new JSONObject();
							ovUpdateJson.put("neid", neId);
							ovUpdateJson.put("programName", programName);
							ovUpdateJson.put("programId", programId);
							ovUpdateJson.put("ciqFileName", ciqFileName);
							ovUpdateJson.put("enbName", neName);
							JSONObject uploadHTML= HTMLUploadToOV( ovUpdateJson,  runTestEntityMap) ;
							}
						runTestEntityMap.get(neId).setProgressStatus("Completed");
						runTestEntityMap.get(neId).setStatus(finalStatusResult);

						if (totalTestCompleted.get()) {
							runTestEntityMap.get(neId).setFailedScript("true");
							;
						} else {
							runTestEntityMap.get(neId).setFailedScript("false");
							;
						}

						if (StringUtils.isNotEmpty(generateScriptPath)) {
							runTestEntityMap.get(neId).setGenerateScriptPath(
									generateScriptPath.substring(0, generateScriptPath.length() - 1));
						}
						runTestRepository.updateRunTest(runTestEntityMap.get(neId));
						// User user = UserSessionPool.getInstance().getSessionUser(sessionId);
						reportService.insertPostMigAuditReportDetails(neId, programId,
								customerDetailsEntity.getProgramName(), userName, ciqFileName, scriptFilesDetails,
								finalStatusResult, migrationSubType);
						if (run.containsKey("trackerId")) {
							OvScheduledEntity ovScheduledEntity = ovScheduledTaskService
									.getOvScheduledServiceDetails(run.get("trackerId").toString(), neId);

							ovScheduledEntity.setPostMigAuditStatus(finalStatusResult);
							if (finalStatusResult.equals("Success")) {
								// ovScheduledEntity = fetchProcessService.statusUpdateApi(ovScheduledEntity,
								// "PostMigration","",runTestParams.get("programName").toString());
							}
							ovScheduledEntity = ovScheduledTaskService.mergeOvScheduledDetails(ovScheduledEntity);
						}
						auditCriticalParamsService.updateExecStatus(runTestEntityMap.get(neId).getId(), finalStatusResult);

							} catch (Exception e) {
						runTestEntityMap.get(neId).setProgressStatus("Completed");
						runTestEntityMap.get(neId).setStatus(FAILURE);
						auditCriticalParamsService.updateExecStatus(runTestEntityMap.get(neId).getId(), FAILURE);

						runTestRepository.updateRunTest(runTestEntityMap.get(neId));
						logger.error("Exception RunTestServiceImpl in getRuntestExecResult() "
								+ ExceptionUtils.getFullStackTrace(e));
					}
					LocalDateTime l2 = LocalDateTime.now();
					logger.error("Completed the thread for NE " + neId + " at : " + l2);
					long duthreadsec = Duration.between(l1, l2).getSeconds();
					logger.error("Duration for thread for NE " + neId + " (HH:mm:ss) : " + String.format("%d:%02d:%02d",
							duthreadsec / 3600, (duthreadsec % 3600) / 60, duthreadsec % 60));
					GlobalStatusMap.userNeQueue.get(userDetailsEntity2.getVpnUserName()).remove(neId);
					return Constants.SUCCESS;

				});
			}

			executorservice.shutdown();
		}

		catch (

		Exception e) {
			logger.error("Exception RunTestServiceImpl in getRuntestExecResult5GAudit() "
					+ ExceptionUtils.getFullStackTrace(e));

			return e.getMessage();
		}

		return Constants.SUCCESS;
	}
private String getSerialNumberOv(UploadFileEntity scriptEntity, String dataOutput, String neId,
			String dbcollectionFileName, NetworkConfigEntity networkConfigEntity, boolean useCurrPassword,
			String sanePassword, NetworkConfigEntity neEntity, String sProgramId, String migrationType,
			String originalUseCaseName, String ciqFileName, String userName, String outputFileNameAudit,
			AtomicBoolean isMultipleDUo, String neName, String programName2) {
		String trackerIdJson = "";
		JSONObject objTrackerIdDetails = new JSONObject();
		String URL = null;
		try {
			OutputStream os = new FileOutputStream(outputFileNameAudit, true);
			OvGeneralEntity objOvGeneralEntity = customerRepository.getOvlabelTemplate(Constants.OV_URL);
			StringBuilder urlBuilder = new StringBuilder();
			urlBuilder.append(objOvGeneralEntity.getValue());
			String authStr = getAuthencationString();
			String enbName = neName;
			String programName = programName2;
			String programId = sProgramId;

			String FuzeProjectID = "";
			String dbURL = "";
			List<AuditConstantsEntity> auditConstantsList = auditConstantsRepository.getAuditConstantsEntityList(
					AuditConstants.PROGRAMNAME_5G_CBAND, AuditConstants.CBAND_MMU_SERIAL_NUMBER_API);
			if (!ObjectUtils.isEmpty(auditConstantsList)) {
				dbURL = auditConstantsList.get(0).getParameterValue();
			}

			List<CIQDetailsModel> listCIQDetailsModel = getCIQDetailsModelList(neId, dbcollectionFileName);
			if (!ObjectUtils.isEmpty(listCIQDetailsModel)) {
				CIQDetailsModel ciqDetailsModel = listCIQDetailsModel.get(0);
				LinkedHashMap<String, CiqMapValuesModel> objMapDetails = ciqDetailsModel.getCiqMap();
				if (objMapDetails.containsKey("fuzeProjectId")) {
					FuzeProjectID = objMapDetails.get("fuzeProjectId").getHeaderValue().replaceAll("^0+(?!$)", "");
				}
			}
			 URL = Constants.OV_TRACKERID_URL + dbURL + FuzeProjectID;
			/*URL = Constants.OV_TRACKERID_URL
					+ "view=L:SRCT_SN_CBAND_AUDIT&page=1&per_page=1&Project.P_FUZE_PROJECT_ID_FZ=16233344";*/

			List<TrackerDetailsModel> listTrackerDetailsModel = new ArrayList<>();
			if (!FuzeProjectID.isEmpty() && FuzeProjectID != null) {
				urlBuilder.append(URL);
				String trakerIdUrl = urlBuilder.toString();
				String exeFileString = "\nExecuting " + "CBand_SerialNumMmu_API" + "\n" + trakerIdUrl + "\n";
				logger.error("Serial Number Data check URL: " + trakerIdUrl);
				os.write(exeFileString.getBytes());
				HttpHeaders headers = new HttpHeaders();
				headers.setAccept(Arrays.asList(MediaType.APPLICATION_JSON));
				headers.setContentType(MediaType.APPLICATION_JSON);
				String base64Creds = Base64.getEncoder().encodeToString(authStr.getBytes());
				
				headers.add("Authorization", "Basic " + base64Creds);
				HttpEntity requestEntity = new HttpEntity<>(headers);
				HttpComponentsClientHttpRequestFactory requestFactory = getHttpsConfiguration();

				RestTemplate restTemplate = new RestTemplate(requestFactory);
				

				ResponseEntity<String> response = restTemplate.exchange(trakerIdUrl, HttpMethod.GET, requestEntity,
						String.class);
				logger.error("Serial Number Data check Api Response :", response);

				int statusCode = response.getStatusCodeValue();
				System.out.println("statusCode : " + statusCode);

				if (200 == statusCode) {
					trackerIdJson = response.getBody();
					os.write(trackerIdJson.getBytes());
					logger.error("Serial Number Data check Api Response :", trackerIdJson);

				}
			} else {
               String exeFileString = "\nExecuting " + "CBand_SerialNumMmu_API" + "\n" + "Fuze ID is Empty in ciq for : " + neId + "\n";
				trackerIdJson = "Fuze ID is Empty in ciq for " + neId;
				os.write(exeFileString.getBytes());

			}
		} catch (HttpClientErrorException e) {
			trackerIdJson = e.getResponseBodyAsString();
		} catch (Exception e) {
			logger.error("error:" + e);
			logger.info(
					"Exception in getTrakerIdList in FetchProcessServiceImpl " + ExceptionUtils.getFullStackTrace(e));
		}

		return trackerIdJson;
	}
private String getSerialNumberOvUSM(UploadFileEntity scriptEntity, String dataOutput, String neId,
		String dbcollectionFileName, NetworkConfigEntity networkConfigEntity, boolean useCurrPassword,
		String sanePassword, NetworkConfigEntity neEntity, String sProgramId, String migrationType,
		String originalUseCaseName, String ciqFileName, String userName, String outputFileNameAudit,
			AtomicBoolean isMultipleDUo, String neName, String programName2) {
		String trackerIdJson = "";
		JSONObject objTrackerIdDetails = new JSONObject();
		String URL = null;
		try {
			OutputStream os = new FileOutputStream(outputFileNameAudit, true);
			OvGeneralEntity objOvGeneralEntity = customerRepository.getOvlabelTemplate(Constants.OV_URL);
			StringBuilder urlBuilder = new StringBuilder();
			urlBuilder.append(objOvGeneralEntity.getValue());
			String authStr = getAuthencationString();
			String enbName = neName;
			String FuzeProjectID = "";
			String dbURL = "";
			List<AuditConstantsEntity> auditConstantsList = auditConstantsRepository.getAuditConstantsEntityList(
					AuditConstants.PROGRAMNAME_4G_USM_LIVE, AuditConstants.USM_SERIAL_NUMBER_API);
			if (!ObjectUtils.isEmpty(auditConstantsList)) {
				dbURL = auditConstantsList.get(0).getParameterValue();
			}

			List<CIQDetailsModel> listCIQDetailsModelDay01 = fileUploadRepository
					.getEnbTableDetailsRanConfig(ciqFileName, neId, enbName, dbcollectionFileName, "CIQUpstateNY", "");
			if (!ObjectUtils.isEmpty(listCIQDetailsModelDay01)) {
				if (listCIQDetailsModelDay01.get(0).getCiqMap().containsKey("FuzeProjId")) {
					FuzeProjectID = listCIQDetailsModelDay01.get(0).getCiqMap().get("FuzeProjId").getHeaderValue();

				}
			}

			URL = Constants.OV_TRACKERID_URL + dbURL + FuzeProjectID;
			
			// URL = Constants.OV_TRACKERID_URL + "view=L:SRCT_SN_4G_AUDIT&page=1&per_page=1&Project.P_SPMS_SITE_ID=166176";
			 

			if (!FuzeProjectID.isEmpty() && FuzeProjectID != null) {
				urlBuilder.append(URL);
				String trakerIdUrl = urlBuilder.toString();
				String exeFileString = "\nExecuting " + "USM_SerialNumMmu_API" + "\n" + trakerIdUrl + "\n";
				logger.error("Serial Number Data check URL: " + trakerIdUrl);
				os.write(exeFileString.getBytes());
				HttpHeaders headers = new HttpHeaders();
				headers.setAccept(Arrays.asList(MediaType.APPLICATION_JSON));
				headers.setContentType(MediaType.APPLICATION_JSON);
				String base64Creds = Base64.getEncoder().encodeToString(authStr.getBytes());

				headers.add("Authorization", "Basic " + base64Creds);
				HttpEntity requestEntity = new HttpEntity<>(headers);
				HttpComponentsClientHttpRequestFactory requestFactory = getHttpsConfiguration();

				RestTemplate restTemplate = new RestTemplate(requestFactory);

				ResponseEntity<String> response = restTemplate.exchange(trakerIdUrl, HttpMethod.GET, requestEntity,
						String.class);

				int statusCode = response.getStatusCodeValue();
				System.out.println("statusCode : " + statusCode);

				if (200 == statusCode) {
					trackerIdJson = response.getBody();
					os.write(trackerIdJson.getBytes());

				}
			} else {
				String exeFileString = "\nExecuting " + "USM_SerialNumMmu_API" + "\n" + "Fuze ID is Empty in ciq for : "
						+ neId + "\n";
				trackerIdJson = "Fuze ID is Empty in ciq for " + neId;
				os.write(exeFileString.getBytes());

			}
		} catch (HttpClientErrorException e) {
			trackerIdJson = e.getResponseBodyAsString();
		} catch (Exception e) {
			logger.error("error:" + e);
			logger.info(
					"Exception in getTrakerIdList in FetchProcessServiceImpl " + ExceptionUtils.getFullStackTrace(e));
		}

		return trackerIdJson;
	}
////calling the api to check weather data is present in OV page?
	private JSONObject getpreExistingDataInOV(JSONObject ovUpdateJson, Map<String, RunTestEntity> runTestEntityMap) {
		
		JSONObject objTrackerIdDetails = new JSONObject();
		String URL = null;
		try {
			OvGeneralEntity objOvGeneralEntity = customerRepository.getOvlabelTemplate(Constants.OV_URL);
			StringBuilder urlBuilder = new StringBuilder();
			urlBuilder.append(objOvGeneralEntity.getValue());
			String authStr = getAuthencationString();
			String enbName=ovUpdateJson.get("enbName").toString();
			String programName =ovUpdateJson.get("programName").toString();
			String programId =ovUpdateJson.get("programId").toString();
			String ciqFileName =ovUpdateJson.get("ciqFileName").toString();
			String neId = ovUpdateJson.get("neid").toString().replaceAll("^0+(?!$)", "");
			
			String dbcollectionFileName = CommonUtil.createMongoDbFileName(String.valueOf(programId),ciqFileName);
			
			String  FuzeProjectID="";//=listCIQDetailsModel.get(0).getCiqMap().get("EquipmentLocation").getHeaderValue();
			if (programName.contains("USM-LIVE")) {
					List<CIQDetailsModel> listCIQDetailsModelDay01 = fileUploadRepository.getEnbTableDetailsRanConfig(ciqFileName, neId, enbName, dbcollectionFileName, "CIQUpstateNY", "");
					FuzeProjectID=listCIQDetailsModelDay01.get(0).getCiqMap().get("FuzeProjId").getHeaderValue();
					//FuzeProjectID="2718124";
					URL = Constants.OV_TRACKERID_URL1 +"fields=P_PREEXISTING_RSSI&Project.P_FUZE_PROJECT_ID_FZ="+FuzeProjectID;

				}
			
			
			//curl -X 'GET' 'https://dev-seavizion.onevizion.com/api/v3/trackor_types/Project/trackors?fields=P_PREEXISTING_RSSI&P_SPMS_SITE_ID=193526&P_4G_LTE_SCOPE=1' -H 'accept: application/json' -H 'Authorization: Basic c3JjdHVzZXI6c3JjdHVzZXJAMTIz'

			 
								List<TrackerDetailsModel> listTrackerDetailsModel = new ArrayList<>();
			if(!FuzeProjectID.isEmpty()&&FuzeProjectID !=null) {
			urlBuilder.append(URL);
			String trakerIdUrl = urlBuilder.toString();
			logger.error("PreExisting Data check URL: "+trakerIdUrl);
			HttpHeaders headers = new HttpHeaders();
			headers.setAccept(Arrays.asList(MediaType.APPLICATION_JSON));
			headers.setContentType(MediaType.APPLICATION_JSON);
			String base64Creds = Base64.getEncoder().encodeToString(authStr.getBytes());
			// create headers
			headers.add("Authorization", "Basic " + base64Creds);
			HttpEntity requestEntity = new HttpEntity<>(headers);
			HttpComponentsClientHttpRequestFactory requestFactory = getHttpsConfiguration();
			
			RestTemplate restTemplate = new RestTemplate(requestFactory);
			logger.error("RequestEntity:  from SRCT",requestEntity);
			
			ResponseEntity<String> response = restTemplate.exchange(trakerIdUrl, HttpMethod.GET, requestEntity,
					String.class);
			logger.error("PreExisting Data check Api Response :",response);
			System.out.println(response);
			int statusCode = response.getStatusCodeValue();

			if (200 == statusCode) {
				String trackerIdJson = response.getBody();
				List<HashMap<String, Object>> trakerList = new ObjectMapper().readValue(trackerIdJson,
						new TypeReference<List<HashMap<String, Object>>>() {
						});
				logger.error("OV Responce Json :"+ trackerIdJson);
				
				

				if (!ObjectUtils.isEmpty(trakerList)) {
					for (HashMap<String, Object> entryData : trakerList) {
						if (entryData.containsKey("P_PREEXISTING_RSSI")&&entryData.get("P_PREEXISTING_RSSI")!=null
								&& StringUtils.isNotEmpty(entryData.get("P_PREEXISTING_RSSI").toString())) {
							TrackerDetailsModel trackerDetailsModel = new TrackerDetailsModel();
							//trackerDetailsModel.setTrackerId(entryData.get("TRACKOR_ID").toString());
							//listTrackerDetailsModel.add(trackerDetailsModel);
							objTrackerIdDetails.put("P_PREEXISTING_RSSI", true);
						}else {
							objTrackerIdDetails.put("P_PREEXISTING_RSSI", false);
						}
					}
				}

				objTrackerIdDetails.put("trakerjson", listTrackerDetailsModel);
				objTrackerIdDetails.put("statusCode", response.getStatusCode());
			}
				}else {
					//objTrackerIdDetails.put("trakerjson", listTrackerDetailsModel);
					objTrackerIdDetails.put("reason", "Fuze ID is Empty for "+neId);
					objTrackerIdDetails.put("P_PREEXISTING_RSSI", true);
				}
		} catch (HttpClientErrorException e) {
			objTrackerIdDetails.put("sta'tusCode", e.getStatusCode());
			objTrackerIdDetails.put("response", e.getResponseBodyAsString());
			objTrackerIdDetails.put("P_PREEXISTING_RSSI", true);
		} catch (Exception e) {
			logger.error("error:"+ e);
			logger.info(
					"Exception in getTrakerIdList in FetchProcessServiceImpl " + ExceptionUtils.getFullStackTrace(e));
		}

	
		return objTrackerIdDetails;
	}

	private List<String> getAllCurlCommands(String dataDetails) {
		List<String> curlList = new ArrayList<>();
		try {
			String[] curlDetails = dataDetails.split("\\n");
			for (String datalocal : curlDetails) {
				if (datalocal.contains("curl")) {
					curlList.add(datalocal);
				}
			}

		} catch (Exception e) {
			logger.error("Exception RunTestServiceImpl in getCurlCommands() " + ExceptionUtils.getFullStackTrace(e));
		}
		return curlList;
	}

	private String getCurlCommandWithSiteId(String siteIds, List<String> curlList) {
		String curlCommand = "";
		try {
			for (String curlCommandLoc : curlList) {
				String enbSite = "eNB_" + siteIds;

				if (curlCommandLoc.contains(enbSite)) {
					curlCommand = curlCommandLoc;
				}

			}

		} catch (Exception e) {
			logger.error("Exception RunTestServiceImpl in getCurlCommands() " + ExceptionUtils.getFullStackTrace(e));
		}
		return curlCommand;
	}

	private String getRequiredOutPut5GAudit(String shelloutput, String fileName) {

		StringBuilder objBuilder = new StringBuilder();

		try {
			String fileNameWoExten = FilenameUtils.removeExtension(fileName);
			objBuilder.append("\n");
			objBuilder.append(fileNameWoExten);
			objBuilder.append("\n");

			String endName = "";
			if (StringUtils.isNotEmpty(shelloutput) && shelloutput.contains("<rpc-reply")
					&& shelloutput.contains("</rpc-reply>")) {
				shelloutput = shelloutput.substring(shelloutput.indexOf("<rpc-reply"),
						shelloutput.indexOf("</rpc-reply>"));
				objBuilder.append(shelloutput);
				objBuilder.append("\n");
				objBuilder.append("</rpc-reply>");
				objBuilder.append("\n");
			}

		} catch (Exception e) {
			logger.error("Exception RunTestServiceImpl in getRequiredOutPut5GAudit() "
					+ ExceptionUtils.getFullStackTrace(e));
		}
		// TODO Auto-generated method stub

		objBuilder.append(XmlCommandsConstants.ENDTEXT5G);
		objBuilder.append("\n");
		return objBuilder.toString();
	}

	private String getRequiredOutPut5GAuditTwamp(String shelloutput, String fileName) {

		StringBuilder objBuilder = new StringBuilder();

		try {
			String fileNameWoExten = FilenameUtils.removeExtension(fileName);
			objBuilder.append("\n");
			objBuilder.append(fileNameWoExten);
			objBuilder.append("\n");

			String endName = "";
			if (StringUtils.isNotEmpty(shelloutput) && shelloutput.contains("<rpc-reply")
					&& shelloutput.contains("</rpc-reply>")) {
				shelloutput = shelloutput.substring(shelloutput.indexOf("<rpc-reply"),
						shelloutput.indexOf("</rpc-reply>"));
				objBuilder.append(shelloutput);
				objBuilder.append("\n");
				objBuilder.append("</rpc-reply>");
				objBuilder.append("\n");
			}

		} catch (Exception e) {
			logger.error("Exception RunTestServiceImpl in getRequiredOutPut5GAudit() "
					+ ExceptionUtils.getFullStackTrace(e));
		}
		// TODO Auto-generated method stub

		objBuilder.append(XmlCommandsConstants.ENDTEXT5GTWAMP);
		objBuilder.append("\n");
		return objBuilder.toString();
	}

	private String getRequiredOutPut5GAuditEnb(String shelloutput, String fileName) {

		StringBuilder objBuilder = new StringBuilder();

		try {
			String fileNameWoExten = FilenameUtils.removeExtension(fileName);
			objBuilder.append("\n");
			objBuilder.append(fileNameWoExten);
			objBuilder.append("\n");

			String endName = "";
			if (StringUtils.isNotEmpty(shelloutput) && shelloutput.contains("<rpc-reply")
					&& shelloutput.contains("</rpc-reply>")) {
				shelloutput = shelloutput.substring(shelloutput.indexOf("<rpc-reply"),
						shelloutput.indexOf("</rpc-reply>"));
				objBuilder.append(shelloutput);
				objBuilder.append("\n");
				objBuilder.append("</rpc-reply>");
				objBuilder.append("\n");
			}

		} catch (Exception e) {
			logger.error("Exception RunTestServiceImpl in getRequiredOutPut5GAudit() "
					+ ExceptionUtils.getFullStackTrace(e));
		}
		// TODO Auto-generated method stub

		objBuilder.append(XmlCommandsConstants.ENDTEXT5GENB);
		objBuilder.append("\n");
		return objBuilder.toString();
	}

	public void writefile5GAudit(String text, int lsmId, boolean useCurrPassword, String eNBIp, String exeFileName,
			String sanePassword, String userName, UploadFileEntity scriptEntity, String useCaseName, String neId,
			int programId, String neName, String neType, String descFinalPaths) {

		NetworkConfigEntity networkConfigEntity = runTestRepository.getNeType(lsmId);
		StringBuilder sb = buildConnectionScript(networkConfigEntity, useCurrPassword, eNBIp, sanePassword, userName,
				scriptEntity, useCaseName, neId, text, neName, programId, neType);
		StringBuilder endSb = buildConnectionEndScript(networkConfigEntity, scriptEntity, programId, neType,
				useCaseName);
		try {
			StringBuilder commFilePath = new StringBuilder();
			commFilePath.append(LoadPropertyFiles.getInstance().getProperty("BASE_PATH")).append(Constants.CUSTOMER);
			StringBuilder xmlFilePath = new StringBuilder();
			xmlFilePath.append(commFilePath).append(Constants.SEPARATOR).append("xmlFlag.txt");
			File xmlfile = new File(xmlFilePath.toString());
			BufferedReader br = new BufferedReader(new FileReader(xmlfile));
			String line = br.readLine();
			br.close();
			if (scriptEntity.getConnectionTerminal().equalsIgnoreCase(Constants.CLI_TERMINAL)
					|| scriptEntity.getConnectionTerminal().equalsIgnoreCase(Constants.CONFDCLI_TERMINAL)) {
				sb.append(text);
				sb.append(endSb);
			} else if (useCaseName.contains(Constants.COMMISION_USECASE)) {
				sb.append(text);
				sb.append(endSb);
			} else if (useCaseName.contains(Constants.RF_USECASE)) {
				if (line.contains("0")) {
					sb.append(text);
					sb.append(endSb);
				} else {
					String before = StringUtils.substringBefore(text, "-d");
					String after = StringUtils.substringAfter(text, "https");
					String xmlName = descFinalPaths.substring(descFinalPaths.lastIndexOf("/") + 1);
					String rfScriptName = StringUtils.substringAfter(xmlName, "BASH_RF_NB-IoTAdd_");
					String finalRfScript = rfScriptName.substring(rfScriptName.lastIndexOf("_"));
					String scriptXml = StringUtils.substringBefore(rfScriptName, finalRfScript);
					String scriptName = scriptXml.substring(scriptXml.lastIndexOf("_"));
					String finalXmlName = StringUtils.substringBefore(scriptXml, scriptName);
					String finalString = before + "-d " + "\\@/home/vsm/rancomm/" + neId + "/" + finalXmlName + ".xml"
							+ "" + " " + "https" + after;
					sb.append(finalString);
					sb.append(endSb);
				}
			} else if ("XML".equalsIgnoreCase(scriptEntity.getScriptType())
					&& scriptEntity.getConnectionTerminal().equalsIgnoreCase(Constants.BASH_TERMINAL)) {
				sb.append(text);
				sb.append(endSb);
			} else if ("XML".equalsIgnoreCase(scriptEntity.getScriptType())
					&& scriptEntity.getConnectionTerminal().equalsIgnoreCase(Constants.CURL_TERMINAL)) {
				sb.append(text);
				sb.append(endSb);
			} else if (!scriptEntity.getConnectionTerminal().equalsIgnoreCase(Constants.CURL_TERMINAL)) {
				sb.append(text);
				sb.append("expect \"" + scriptEntity.getPrompt().replace("enbname", neName).replace("enbId", neId)
						+ "\"" + " \n");
			}
			String xm = null;
			String s = new String(sb);
			File file = new File(exeFileName);
			if (!file.exists()) {
				file.createNewFile();

			}

			OutputStream os = new FileOutputStream(file);

			os.write(s.getBytes(), 0, s.length());

			Runtime.getRuntime().exec("chmod -R 777 " + exeFileName);

			os.close();

		} catch (Exception e) {
			logger.info("Exception in writefile5GAudit() in RunTestServiceImpl" + ExceptionUtils.getFullStackTrace(e));
		}

	}

	public synchronized void generateScriptWithOutExe5GAudit(String neId, String neName, String sProgramId,
			String migrationType, String migrationSubType, UploadFileEntity scriptEntity, String enbIP,
			NetworkConfigEntity neEntity, String useCaseName, String sessionId, String lsmName, int useCaseId,
			int useCaseExeSeq, int scriptId, int scriptExeSeq, int lsmId, boolean useCurrPassword, String sanePassword,
			String userName, String lsmVersion, String ciqFileName, String neType) throws RctException {

		try {
			int programId = Integer.parseInt(sProgramId);
			StringBuilder sourcePath = new StringBuilder();
			StringBuilder destPath = new StringBuilder();
			String text;

			sourcePath = sourcePath.append(LoadPropertyFiles.getInstance().getProperty("BASE_PATH"));
			destPath = destPath.append(LoadPropertyFiles.getInstance().getProperty("BASE_PATH"));
			String scriptName = scriptEntity.getFileName();
			String scriptPath = scriptEntity.getFilePath();

			sourcePath.append(scriptPath).append(File.separator).append(useCaseName.trim().replaceAll(" ", "_"))
					.append(File.separator).append(scriptName);

			destPath.append(Constants.CUSTOMER)
					.append(Constants.GENERATE_SCRIPT.replace("programId", sProgramId)
							.replace("migrationType", migrationType).replace("neId", neId)
							.replace("subType", migrationSubType));

			File folder = new File(destPath.toString());

			if (!folder.exists()) {
				FileUtil.createDirectory(destPath.toString());
			}

			String[] fileName = scriptName.split("\\.");
			String[] exactFileName = scriptName.split("\\.");

			String scriptAbsFileName = "";
			if (useCaseName.contains(Constants.COMMISION_USECASE) || useCaseName.contains(Constants.RF_USECASE)) {
				scriptAbsFileName = LoadPropertyFiles.getInstance().getProperty("BASE_PATH") + Constants.CUSTOMER + "/"
						+ Constants.UPLOAD_FILE_PATH_WITHOUT_VERSION.replace("programId", String.valueOf(programId))
								.replace("migrationType", migrationType).replace("subType", scriptEntity.getSubType())
						+ useCaseName.trim().replaceAll(" ", "_") + "/" + scriptEntity.getFileName();
			} else {
				scriptAbsFileName = LoadPropertyFiles.getInstance().getProperty("BASE_PATH")
						+ scriptEntity.getFilePath() + "/" + useCaseName.trim().replaceAll(" ", "_") + "/"
						+ scriptEntity.getFileName();
			}

			String timeStamp = new SimpleDateFormat("MMddyyyy_HH_mm_ss")
					.format(new Timestamp(System.currentTimeMillis()));

			String convertFileName = LoadPropertyFiles.getInstance().getProperty("BASE_PATH")
					+ scriptEntity.getFilePath() + "/" + useCaseName.trim().replaceAll(" ", "_") + "/"
					+ StringUtils.substringBeforeLast(scriptEntity.getFileName(), ".") + "_" + timeStamp + ".sh";

			ProgramTemplateEntity programTemplateEntity = fileUploadService.getProgramTemplate(programId,
					Constants.SCRIPT_STORE_TEMPLATE);

			if ("BatchFile".equalsIgnoreCase(scriptEntity.getScriptType())
					&& scriptEntity.getConnectionTerminal().equalsIgnoreCase(Constants.CLI_TERMINAL)) {

				String relVersion = runTestRepository.getNeRelVer(programId, lsmVersion);

				CommonUtil.createCliFromBatch(scriptAbsFileName, convertFileName, lsmVersion, relVersion,
						programTemplateEntity, ciqFileName, neId, neName);
				text = readFile(convertFileName);

			} else if ("BatchFile".equalsIgnoreCase(scriptEntity.getScriptType())
					&& scriptEntity.getConnectionTerminal().equalsIgnoreCase(Constants.CMD_SYS_TERMINAL)) {

				CommonUtil.createCmdSysFromBatch(scriptAbsFileName, convertFileName, programTemplateEntity, ciqFileName,
						neId, neName);

				text = readFile(convertFileName);

			} else if ("BatchFile".equalsIgnoreCase(scriptEntity.getScriptType())
					&& scriptEntity.getConnectionTerminal().equalsIgnoreCase(Constants.CONFDCLI_TERMINAL)) {

				CommonUtil.createConfdCliFromBatch(scriptAbsFileName, convertFileName, programTemplateEntity,
						ciqFileName, neId, neName);

				text = readFile(convertFileName);

			} else if ("VbsFile".equalsIgnoreCase(scriptEntity.getScriptType())
					&& scriptEntity.getConnectionTerminal().equalsIgnoreCase(Constants.BASH_TERMINAL)) {

				CommonUtil.createBashFromVbs(scriptAbsFileName, convertFileName, programTemplateEntity, ciqFileName,
						neId, neName);

				text = readFile(convertFileName);

			} else if ("VbsFile".equalsIgnoreCase(scriptEntity.getScriptType())
					&& scriptEntity.getConnectionTerminal().equalsIgnoreCase(Constants.CLI_TERMINAL)) {
				String relVersion = runTestRepository.getNeRelVer(programId, lsmVersion);
				CommonUtil.createCliFromVbs(scriptAbsFileName, convertFileName, lsmVersion, relVersion,
						programTemplateEntity, ciqFileName, neId, neName);

				text = readFile(convertFileName);

			} else if ("XML".equalsIgnoreCase(scriptEntity.getScriptType())
					&& (scriptEntity.getConnectionTerminal().equalsIgnoreCase(Constants.BASH_TERMINAL)
							|| scriptEntity.getConnectionTerminal().equalsIgnoreCase(Constants.CURL_TERMINAL))) {

				String mcmip = "";

				if (CommonUtil.isValidObject(neEntity) && CommonUtil.isValidObject(neEntity.getNeTypeEntity())
						&& neEntity.getNeTypeEntity().getId() == Constants.NW_CONFIG_VLSM_ID
						&& CommonUtil.isValidObject(neEntity.getNeDetails())) {
					for (NetworkConfigDetailsEntity detailsEntity : neEntity.getNeDetails()) {
						if (CommonUtil.isValidObject(detailsEntity.getServerTypeEntity())) {
							if (detailsEntity.getServerTypeEntity().getId() == Constants.NW_CONFIG_VLSM_MCMA_ID
									&& CommonUtil.isValidObject(detailsEntity.getServerIp())
									&& detailsEntity.getServerIp().length() > 0) {
								mcmip = detailsEntity.getServerIp();
								break;
							}
						}
					}
				}
				if (CommonUtil.isValidObject(neEntity) && CommonUtil.isValidObject(neEntity.getNeTypeEntity())
						&& neEntity.getNeTypeEntity().getId() == Constants.NW_CONFIG_USM_ID) {
					mcmip = neEntity.getNeIp();
				}

				String endName = "";
				if (StringUtils.isNotEmpty(scriptEntity.getFileName())) {
					endName = scriptEntity.getFileName().substring(0, scriptEntity.getFileName().indexOf('_'));
				}
				if ("ACPF".equalsIgnoreCase(endName) || "AUPF".equalsIgnoreCase(endName)
						|| "AU".equalsIgnoreCase(endName) || "DU".equalsIgnoreCase(endName)
						|| "DSS".equalsIgnoreCase(endName) || "4GAudit".equalsIgnoreCase(endName)
						|| "IAU".equalsIgnoreCase(endName) || "CBand".equalsIgnoreCase(endName)
						|| "Audit4G".equalsIgnoreCase(endName) || "4GUSM".equalsIgnoreCase(endName)
						|| "4GFSU".equalsIgnoreCase(endName)) {
					String dbcollectionFileName = CommonUtil.createMongoDbFileName(sProgramId, ciqFileName);
					List<CIQDetailsModel> listCIQDetailsModel = getCIQDetailsModelList(neId, dbcollectionFileName);
					String gnbId = "";
					if (!ObjectUtils.isEmpty(listCIQDetailsModel))

					{
						CIQDetailsModel ciqDetailsModel = listCIQDetailsModel.get(0);

						LinkedHashMap<String, CiqMapValuesModel> objMapDetails = ciqDetailsModel.getCiqMap();

						if ("ACPF".equalsIgnoreCase(endName) && !ObjectUtils.isEmpty(objMapDetails)
								&& objMapDetails.containsKey("NE_ID ACPF")) {
							String acpfName = "";
							if (objMapDetails.containsKey("NE_ID_ACPF Name")) {
								acpfName = objMapDetails.get("NE_ID_ACPF Name").getHeaderValue();
							}
							gnbId = objMapDetails.get("NE_ID ACPF").getHeaderValue();
							gnbId = gnbId.trim();
							gnbId = gnbId.replaceAll("^0+(?!$)", "");
							/*
							 * if(acpfName.contains("ACPFP")) { gnbId = gnbId.trim(); gnbId =
							 * gnbId.replaceAll("^0+(?!$)", ""); } else if (StringUtils.isNotEmpty(gnbId) &&
							 * gnbId.length() >= 4) { gnbId = gnbId.trim(); gnbId =
							 * gnbId.substring(gnbId.length() - 4); gnbId = gnbId.replaceAll("^0+(?!$)",
							 * "");
							 * 
							 * }
							 */
						} else if ("AUPF".equalsIgnoreCase(endName) && !ObjectUtils.isEmpty(objMapDetails)
								&& objMapDetails.containsKey("NE_ID_AUPF")) {
							String aupfName = "";
							if (objMapDetails.containsKey("NE_ID_AUPF Name")) {
								aupfName = objMapDetails.get("NE_ID_AUPF Name").getHeaderValue();
							}
							gnbId = objMapDetails.get("NE_ID_AUPF").getHeaderValue();
							gnbId = gnbId.trim();
							gnbId = gnbId.replaceAll("^0+(?!$)", "");
							/*
							 * if(aupfName.contains("AUPFP")) { gnbId = gnbId.trim(); gnbId =
							 * gnbId.replaceAll("^0+(?!$)", ""); } else if (StringUtils.isNotEmpty(gnbId) &&
							 * gnbId.length() >= 4) { gnbId = gnbId.trim(); gnbId =
							 * gnbId.substring(gnbId.length() - 4); gnbId = gnbId.replaceAll("^0+(?!$)",
							 * "");
							 * 
							 * }
							 */
						} else if (("AU".equalsIgnoreCase(endName) || "DU".equalsIgnoreCase(endName)
								|| "IAU".equalsIgnoreCase(endName)) && !ObjectUtils.isEmpty(objMapDetails)
								&& objMapDetails.containsKey("NE ID AU")) {

							endName = "DU";
							gnbId = objMapDetails.get("NE ID AU").getHeaderValue();
							if (StringUtils.isNotEmpty(gnbId)) {
								gnbId = gnbId.trim();
								gnbId = gnbId.replaceAll("^0+(?!$)", "");
							}

						} else if ("DSS".equalsIgnoreCase(endName) && !ObjectUtils.isEmpty(objMapDetails)) {
							for (CIQDetailsModel ciqDetails : listCIQDetailsModel) {
								if (ciqDetails.getSheetAliasName().equals("vDUGrowSiteLevel(Day1)CQ")) {
									ciqDetailsModel = ciqDetails;
								}
							}
							objMapDetails = ciqDetailsModel.getCiqMap();
							if (scriptEntity.getFileName().contains("ACPF") && objMapDetails.containsKey("ACPF_ID")) {
								endName = "ACPF";
								gnbId = objMapDetails.get("ACPF_ID").getHeaderValue();
								// gnbId = objMapDetails.get("gNBID").getHeaderValue();
								// if (StringUtils.isNotEmpty(gnbId) && gnbId.length() >= 4) {
								// gnbId = gnbId.trim();
								// gnbId = gnbId.substring(gnbId.length() - 4);
								// gnbId = gnbId.replaceAll("^0+(?!$)", "");
								//
								// }
								NeMappingModel neMappingModel = new NeMappingModel();
								CustomerDetailsEntity programDetailsEntity = new CustomerDetailsEntity();
								programDetailsEntity.setId(programId);
								neMappingModel.setProgramDetailsEntity(programDetailsEntity);
								neMappingModel
										.setEnbId(objMapDetails.get("ACPF_ID").getHeaderValue().replaceAll("^0+(?!$)", ""));
								List<NeMappingEntity> neMappingEntities = neMappingService.getNeMapping(neMappingModel);
								if ((CommonUtil.isValidObject(neMappingEntities) && neMappingEntities.size() > 0)
										&& (CommonUtil.isValidObject(neMappingEntities.get(0))
												&& CommonUtil.isValidObject(neMappingEntities.get(0).getSiteConfigType())
												&& (neMappingEntities.get(0).getSiteConfigType().length() > 0))) {
									mcmip = neMappingEntities.get(0).getNetworkConfigEntity().getNeIp();
								}
							} else if (scriptEntity.getFileName().contains("AUPF")
									&& objMapDetails.containsKey("AUPF_ID")) {
								endName = "AUPF";
								gnbId = objMapDetails.get("AUPF_ID").getHeaderValue();
								// gnbId = objMapDetails.get("gNBID").getHeaderValue();
								// if (StringUtils.isNotEmpty(gnbId) && gnbId.length() >= 4) {
								// gnbId = gnbId.trim();
								// gnbId = gnbId.substring(gnbId.length() - 4);
								// gnbId = gnbId.replaceAll("^0+(?!$)", "");
								//
								// }
								NeMappingModel neMappingModel = new NeMappingModel();
								CustomerDetailsEntity programDetailsEntity = new CustomerDetailsEntity();
								programDetailsEntity.setId(programId);
								neMappingModel.setProgramDetailsEntity(programDetailsEntity);
								neMappingModel
										.setEnbId(objMapDetails.get("AUPF_ID").getHeaderValue().replaceAll("^0+(?!$)", ""));
								List<NeMappingEntity> neMappingEntities = neMappingService.getNeMapping(neMappingModel);
								if ((CommonUtil.isValidObject(neMappingEntities) && neMappingEntities.size() > 0)
										&& (CommonUtil.isValidObject(neMappingEntities.get(0))
												&& CommonUtil.isValidObject(neMappingEntities.get(0).getSiteConfigType())
												&& (neMappingEntities.get(0).getSiteConfigType().length() > 0))) {
									mcmip = neMappingEntities.get(0).getNetworkConfigEntity().getNeIp();
								}
							} else if (scriptEntity.getFileName().contains("vDU")
									&& objMapDetails.containsKey("NEID")) {
								endName = "ADPF";
								gnbId = objMapDetails.get("NEID").getHeaderValue().replaceAll("^0+(?!$)", "");
							} else if (scriptEntity.getFileName().contains("eNB")
									&& objMapDetails.containsKey("4GeNB")) {
								endName = "eNB";
								gnbId = objMapDetails.get("4GeNB").getHeaderValue().replaceAll("^0+(?!$)", "");
								NeMappingModel neMappingModel = new NeMappingModel();
								CustomerDetailsEntity programDetailsEntity = new CustomerDetailsEntity();
								//programDetailsEntity.setProgramName("VZN-4G-USM-LIVE");
								programDetailsEntity.setId(34);
								neMappingModel.setProgramDetailsEntity(programDetailsEntity);
								neMappingModel.setEnbId(
										objMapDetails.get("4GeNB").getHeaderValue().replaceAll("^0+(?!$)", ""));
								List<NeMappingEntity> neMappingEntities = neMappingService.getNeMapping(neMappingModel);
								if ((CommonUtil.isValidObject(neMappingEntities) && neMappingEntities.size() > 0)
										&& (CommonUtil.isValidObject(neMappingEntities.get(0))
												&& CommonUtil
														.isValidObject(neMappingEntities.get(0).getSiteConfigType())
												&& (neMappingEntities.get(0).getSiteConfigType().length() > 0))) {
									mcmip = neMappingEntities.get(0).getNetworkConfigEntity().getNeIp();
								}
							} else if (scriptEntity.getFileName().contains("FSU")
									&& objMapDetails.containsKey("NEID")) {
								endName = "FSU";
								List<CIQDetailsModel> listCIQsheetDetailsModel = fileUploadRepository
										.getEnbTableSheetDetailss(ciqFileName, "DSS_MOP_Parameters-1",
												objMapDetails.get("NEID").getHeaderValue(), dbcollectionFileName);
								if (!ObjectUtils.isEmpty(listCIQsheetDetailsModel)) {
									CIQDetailsModel ciqsheetDetailsModel = listCIQsheetDetailsModel.get(0);
									if (ciqsheetDetailsModel.getCiqMap().containsKey("FSUID")) {
										gnbId = ciqsheetDetailsModel.getCiqMap().get("FSUID").getHeaderValue()
												.replaceAll("^0+(?!$)", "");

										if (objMapDetails.containsKey("4GeNB")) {
											NeMappingModel neMappingModel = new NeMappingModel();
											CustomerDetailsEntity programDetailsEntity = new CustomerDetailsEntity();
											//programDetailsEntity.setProgramName("VZN-4G-USM-LIVE");
											programDetailsEntity.setId(34);
											neMappingModel.setProgramDetailsEntity(programDetailsEntity);
											neMappingModel.setEnbId(objMapDetails.get("4GeNB").getHeaderValue()
													.replaceAll("^0+(?!$)", ""));
											List<NeMappingEntity> neMappingEntities = neMappingService
													.getNeMapping(neMappingModel);
											if ((CommonUtil.isValidObject(neMappingEntities)
													&& neMappingEntities.size() > 0)
													&& (CommonUtil.isValidObject(neMappingEntities.get(0))
															&& CommonUtil.isValidObject(
																	neMappingEntities.get(0).getSiteConfigType())
															&& (neMappingEntities.get(0).getSiteConfigType()
																	.length() > 0))) {
												mcmip = neMappingEntities.get(0).getNetworkConfigEntity().getNeIp();
											}
											NeMappingModel neMappingModel1 = new NeMappingModel();
											CustomerDetailsEntity programDetailsEntity1 = new CustomerDetailsEntity();
											
											programDetailsEntity1.setId(programId);
											neMappingModel1.setProgramDetailsEntity(programDetailsEntity1);
											neMappingModel1.setEnbId(gnbId);
											List<NeMappingEntity> neMappingEntities1 = neMappingService
													.getNeMapping(neMappingModel1);
											if ((CommonUtil.isValidObject(neMappingEntities1)
													&& neMappingEntities1.size() > 0)
													&& (CommonUtil.isValidObject(neMappingEntities1.get(0))
															&& CommonUtil.isValidObject(
																	neMappingEntities1.get(0).getSiteConfigType())
															&& (neMappingEntities1.get(0).getSiteConfigType()
																	.length() > 0))) {
												mcmip = neMappingEntities1.get(0).getNetworkConfigEntity().getNeIp();
											}
										}
									}
								}
							}

						} else if ("CBand".equalsIgnoreCase(endName) && !ObjectUtils.isEmpty(objMapDetails)) {
							if (scriptEntity.getFileName().contains(XmlCommandsConstants.CBAND_F1U_DESTINATIONIP)
									&& objMapDetails.containsKey("AUPF_ID")) {
								endName = "AUPF";
								gnbId = objMapDetails.get("AUPF_ID").getHeaderValue().replaceAll("^0+(?!$)", "");
								NeMappingModel neMappingModel = new NeMappingModel();
								CustomerDetailsEntity programDetailsEntity = new CustomerDetailsEntity();
								programDetailsEntity.setId(programId);
								neMappingModel.setProgramDetailsEntity(programDetailsEntity);
								neMappingModel
										.setEnbId(objMapDetails.get("AUPF_ID").getHeaderValue().replaceAll("^0+(?!$)", ""));
								List<NeMappingEntity> neMappingEntities = neMappingService.getNeMapping(neMappingModel);
								if ((CommonUtil.isValidObject(neMappingEntities) && neMappingEntities.size() > 0)
										&& (CommonUtil.isValidObject(neMappingEntities.get(0))
												&& CommonUtil.isValidObject(neMappingEntities.get(0).getSiteConfigType())
												&& (neMappingEntities.get(0).getSiteConfigType().length() > 0))) {
									mcmip = neMappingEntities.get(0).getNetworkConfigEntity().getNeIp();
								}
							} else if (scriptEntity.getFileName().contains("vDU")
									&& objMapDetails.containsKey("NEID")) {
								endName = "ADPF";
								gnbId = objMapDetails.get("NEID").getHeaderValue().replaceAll("^0+(?!$)", "");
							} else if (scriptEntity.getFileName().contains("AUPF")
									&& objMapDetails.containsKey("AUPF_ID")) {
								endName = "AUPF";
								gnbId = objMapDetails.get("AUPF_ID").getHeaderValue().replaceAll("^0+(?!$)", "");
								NeMappingModel neMappingModel = new NeMappingModel();
								CustomerDetailsEntity programDetailsEntity = new CustomerDetailsEntity();
								programDetailsEntity.setId(programId);
								neMappingModel.setProgramDetailsEntity(programDetailsEntity);
								neMappingModel
										.setEnbId(objMapDetails.get("AUPF_ID").getHeaderValue().replaceAll("^0+(?!$)", ""));
								List<NeMappingEntity> neMappingEntities = neMappingService.getNeMapping(neMappingModel);
								if ((CommonUtil.isValidObject(neMappingEntities) && neMappingEntities.size() > 0)
										&& (CommonUtil.isValidObject(neMappingEntities.get(0))
												&& CommonUtil.isValidObject(neMappingEntities.get(0).getSiteConfigType())
												&& (neMappingEntities.get(0).getSiteConfigType().length() > 0))) {
									mcmip = neMappingEntities.get(0).getNetworkConfigEntity().getNeIp();
								}
							} else if (scriptEntity.getFileName().contains("ACPF")
									&& objMapDetails.containsKey("ACPF_ID")) {
								endName = "ACPF";
								gnbId = objMapDetails.get("ACPF_ID").getHeaderValue().replaceAll("^0+(?!$)", "");
								NeMappingModel neMappingModel = new NeMappingModel();
								CustomerDetailsEntity programDetailsEntity = new CustomerDetailsEntity();
								programDetailsEntity.setId(programId);
								neMappingModel.setProgramDetailsEntity(programDetailsEntity);
								neMappingModel
										.setEnbId(objMapDetails.get("ACPF_ID").getHeaderValue().replaceAll("^0+(?!$)", ""));
								List<NeMappingEntity> neMappingEntities = neMappingService.getNeMapping(neMappingModel);
								if ((CommonUtil.isValidObject(neMappingEntities) && neMappingEntities.size() > 0)
										&& (CommonUtil.isValidObject(neMappingEntities.get(0))
												&& CommonUtil.isValidObject(neMappingEntities.get(0).getSiteConfigType())
												&& (neMappingEntities.get(0).getSiteConfigType().length() > 0))) {
									mcmip = neMappingEntities.get(0).getNetworkConfigEntity().getNeIp();
								}
							} else if (scriptEntity.getFileName().contains("eNB")
									&& objMapDetails.containsKey("ENB_ID")) {
								endName = "eNB";
								gnbId = objMapDetails.get("ENB_ID").getHeaderValue().replaceAll("^0+(?!$)", "");
								NeMappingModel neMappingModel = new NeMappingModel();
								CustomerDetailsEntity programDetailsEntity = new CustomerDetailsEntity();
								programDetailsEntity.setId(programId);
								neMappingModel.setProgramDetailsEntity(programDetailsEntity);
								neMappingModel.setEnbId(
										objMapDetails.get("ENB_ID").getHeaderValue().replaceAll("^0+(?!$)", ""));
								List<NeMappingEntity> neMappingEntities = neMappingService.getNeMapping(neMappingModel);
								if ((CommonUtil.isValidObject(neMappingEntities) && neMappingEntities.size() > 0)
										&& (CommonUtil.isValidObject(neMappingEntities.get(0))
												&& CommonUtil
														.isValidObject(neMappingEntities.get(0).getSiteConfigType())
												&& (neMappingEntities.get(0).getSiteConfigType().length() > 0))) {
									mcmip = neMappingEntities.get(0).getNetworkConfigEntity().getNeIp();
								}
							}
						} else if ("4GAudit".equalsIgnoreCase(endName)||"4GUSM".equalsIgnoreCase(endName)) {
							endName = "eNB";
							gnbId = neId.replaceAll("^0+(?!$)", "");
						} else if ((("Audit4G".equalsIgnoreCase(endName)) || ("4GFSU".equalsIgnoreCase(endName)))  && !ObjectUtils.isEmpty(objMapDetails)) {
							if (scriptEntity.getFileName().contains("FSU")
									&& objMapDetails.containsKey("NE_ID")) {
								endName = "FSU";
								gnbId = objMapDetails.get("NE_ID").getHeaderValue().replaceAll("^0+(?!$)", "");
							}else if (scriptEntity.getFileName().contains("eNB")
									&& objMapDetails.containsKey("eNB_Name")) {
								endName = "eNB";
								gnbId = objMapDetails.get("eNB_Name").getHeaderValue().replaceAll("^0+(?!$)", "");
							}
							
						}

					}
					if (scriptEntity.getFileName().contains(XmlCommandsConstants.AU_TWAMP_F1C_LINK)) {
						CIQDetailsModel ciqDetailsModel = listCIQDetailsModel.get(0);
						LinkedHashMap<String, CiqMapValuesModel> objMapDetails = ciqDetailsModel.getCiqMap();
						if (objMapDetails.containsKey("Remote_IP_Address")) {
							String remoteIp = objMapDetails.get("Remote_IP_Address").getHeaderValue().trim();
							CommonUtil.createBashFromXml5GAuditTwamp(scriptAbsFileName, convertFileName, mcmip, gnbId,
									endName, scriptEntity.getFileName(), remoteIp);
						}
					} else if (scriptEntity.getFileName().contains(XmlCommandsConstants.IAU_TWAMP_F1C_LINK)) {
						CIQDetailsModel ciqDetailsModel = listCIQDetailsModel.get(0);
						LinkedHashMap<String, CiqMapValuesModel> objMapDetails = ciqDetailsModel.getCiqMap();
						if (objMapDetails.containsKey("Remote_IP_Address")) {
							String remoteIp = objMapDetails.get("Remote_IP_Address").getHeaderValue().trim();
							CommonUtil.createBashFromXml5GAuditTwampIAU(scriptAbsFileName, convertFileName, mcmip,
									gnbId, endName, scriptEntity.getFileName(), remoteIp);
						}
					} else {
						CommonUtil.createBashFromXml5GAudit(scriptAbsFileName, convertFileName, mcmip, gnbId, endName);
					}

				} else if ("eNB".equalsIgnoreCase(endName)) {
					String dbcollectionFileName = CommonUtil.createMongoDbFileName(sProgramId, ciqFileName);
					LinkedHashSet<String> siteIds = getEnbsiteIds(neId, ciqFileName, dbcollectionFileName);
					NetworkConfigEntity networkConfigEntity = runTestRepository.getNeType(lsmId);
					StringBuilder endSb = buildConnectionEndScript(networkConfigEntity, scriptEntity, programId, neType,
							useCaseName);
					String expectPrompt = getPromtbetweenCurlCommans(endSb);
					CommonUtil.createBashFromXml5GAuditEnbSites(scriptAbsFileName, convertFileName, mcmip, neId,
							endName, siteIds, expectPrompt);

				}
				text = readFile(convertFileName);

			} else if ("py".equalsIgnoreCase(fileName[1]) || "perl".equalsIgnoreCase(fileName[1])
					|| "pl".equalsIgnoreCase(fileName[1])) {

				text = readFile(scriptAbsFileName);
			} else if (useCaseName.contains(Constants.COMMISION_USECASE) || useCaseName.contains(Constants.RF_USECASE)
					|| useCaseName.contains("ACPF_A1A2") || useCaseName.contains("CSLUsecase")
					|| useCaseName.contains("Comm") || useCaseName.contains("ENDC") || useCaseName.contains("Anchor")
					|| useCaseName.contains("NBR") || useCaseName.contains("GP_Script")
					|| useCaseName.contains("GPScript") || useCaseName.contains("RF_Scripts_Usecase")
					|| useCaseName.contains("RFScriptsUsecase") || useCaseName.contains("vDU_RF_Scripts_Usecase")
					|| useCaseName.contains("eNB_RF_Scripts_Usecase") || useCaseName.contains("ACPF_RF_Scripts_Usecase")
					|| useCaseName.contains("AUPF_RF_Scripts_Usecase") || useCaseName.contains("FSU_RF_Scripts_Usecase")
					|| useCaseName.contains("vDURFScriptsUsecase") || useCaseName.contains("eNBRFScriptsUsecase")
					|| useCaseName.contains("ACPFRFScriptsUsecase") || useCaseName.contains("AUPFRFScriptsUsecase")
					|| useCaseName.contains("FSURFScriptsUsecase") || useCaseName.contains(Constants.GROWCELLUSECASE)
					|| useCaseName.contains(Constants.GROWENBUSECASE) || useCaseName.contains(Constants.PNPUSECASE)
					|| useCaseName.contains("AUCaCell") || useCaseName.contains("AU20B")
					|| useCaseName.contains("AU20A") || useCaseName.contains("pnp20BUsecase")
					|| useCaseName.contains("pnp20AUsecase") || useCaseName.contains("Pre-Check_RF_Scripts_Usecase")
					|| useCaseName.contains("Cutover_RF_Scripts_Usecase") || useCaseName.contains("Extended_Usecase")
					|| useCaseName.contains("ExtendedUsecase") || useCaseName.contains("Rollback_RF_Scripts_Usecase")
					|| useCaseName.contains("AU20C") || useCaseName.contains("pnp20CUsecase")||useCaseName.contains("DeleteNEUsecase")
					|| useCaseName.contains("NeCreationTimeUsecase")||useCaseName.contains("DeleteNE21AUsecase")
					|| useCaseName.contains("NeCreationTime21AUsecase")
					||useCaseName.contains("DeleteNE21BUsecase")
					|| useCaseName.contains("NeCreationTime21BUsecase")
					||useCaseName.contains("DeleteNE21CUsecase")
					|| useCaseName.contains("NeCreationTime21CUsecase")
					||useCaseName.contains("DeleteNE21DUsecase")
					|| useCaseName.contains("NeCreationTime21DUsecase")
					||useCaseName.contains("DeleteNE22AUsecase")
					|| useCaseName.contains("NeCreationTime22AUsecase")) {
				text = readFile(scriptAbsFileName);
			} else {
				CommonUtil.createExpect(scriptAbsFileName, convertFileName, scriptEntity, neId, neName);
				text = readFile(convertFileName);
			}

			if (lsmName.contains("_")) {
				lsmName = charRemoveAt(lsmName);
			}

			if (useCaseName.contains("_")) {
				useCaseName = charRemoveAt(useCaseName);
			}

			if (fileName[0].contains("_")) {
				fileName[0] = charRemoveAt(fileName[0]);
			}

			lsmName = lsmName.replaceAll("\\s", "");
			useCaseName = useCaseName.replaceAll("\\s", "");
			fileName[0] = fileName[0].replaceAll("\\s", "");

			String descFileName = scriptExeSeq + "_" + lsmName + "_" + useCaseName + "_" + useCaseId + "_" + fileName[0]
					+ "_" + scriptId + "." + fileName[1];
			String descFinalPath = destPath.toString() + "/" + descFileName;

			if ("py".equalsIgnoreCase(fileName[1]) || "perl".equalsIgnoreCase(fileName[1])
					|| "pl".equalsIgnoreCase(fileName[1])) {

				File file = new File(descFinalPath);
				if (!file.exists()) {
					file.createNewFile();
				}
				FileWriter fw = new FileWriter(descFinalPath);
				fw.write(text);
				fw.close();

			} else {
				descFileName = scriptExeSeq + "_" + lsmName + "_" + useCaseName + "_" + useCaseId + "_" + fileName[0]
						+ "_" + scriptId + "." + "sh";
				descFinalPath = destPath.toString() + "/" + descFileName;
				String descFileNames = scriptExeSeq + "_" + lsmName + "_" + useCaseName + "_" + useCaseId + "_"
						+ exactFileName[0] + "_" + scriptId + "." + "xml";
				String descFinalPaths = destPath.toString() + "/" + descFileNames;

				writefile5GAudit(text, lsmId, useCurrPassword, enbIP, descFinalPath, sanePassword, userName,
						scriptEntity, useCaseName, neId, programId, neName, neType, descFinalPaths);
			}

		} catch (Exception e) {
			logger.error("Exception RunTestServiceImpl in generateScriptWithOutExe() "
					+ ExceptionUtils.getFullStackTrace(e));
		}

	}

	private LinkedHashSet<String> getEnbsiteIds(String neId, String ciqFileName, String dbcollectionFileName) {
		LinkedHashSet<String> neIdList = new LinkedHashSet<>();

		try {

			List<CIQDetailsModel> listCIQDetailsModel = getCIQDetailsModelList(neId, dbcollectionFileName);

			if (!ObjectUtils.isEmpty(listCIQDetailsModel)
					&& listCIQDetailsModel.get(0).getCiqMap().containsKey("NE ID AU")) {
				String neidau = listCIQDetailsModel.get(0).getCiqMap().get("NE ID AU").getHeaderValue();

				List<CIQDetailsModel> listCIQDetailsModelDetails = getCIQDetailsModelList(neidau, dbcollectionFileName);

				if (!ObjectUtils.isEmpty(listCIQDetailsModelDetails)) {

					for (CIQDetailsModel objCIQDetailsModel : listCIQDetailsModelDetails) {

						if (objCIQDetailsModel.getCiqMap().containsKey("eNB_ID") && StringUtils
								.isNotEmpty(objCIQDetailsModel.getCiqMap().get("eNB_ID").getHeaderValue())) {
							neIdList.add(objCIQDetailsModel.getCiqMap().get("eNB_ID").getHeaderValue()
									.replaceAll("^0+(?!$)", ""));
						}
					}

					if (ObjectUtils.isEmpty(neIdList)) {
						for (CIQDetailsModel objCIQDetailsModel : listCIQDetailsModelDetails) {

							if (objCIQDetailsModel.getCiqMap().containsKey("Samsung eNB_ID") && StringUtils.isNotEmpty(
									objCIQDetailsModel.getCiqMap().get("Samsung eNB_ID").getHeaderValue())) {
								neIdList.add(objCIQDetailsModel.getCiqMap().get("Samsung eNB_ID").getHeaderValue()
										.replaceAll("^0+(?!$)", ""));
							}
						}
					}

					if (ObjectUtils.isEmpty(neIdList)) {
						for (CIQDetailsModel objCIQDetailsModel : listCIQDetailsModelDetails) {

							if (objCIQDetailsModel.getCiqMap().containsKey("Nokia eNB_ID") && StringUtils
									.isNotEmpty(objCIQDetailsModel.getCiqMap().get("Nokia eNB_ID").getHeaderValue())) {
								neIdList.add(objCIQDetailsModel.getCiqMap().get("Nokia eNB_ID").getHeaderValue()
										.replaceAll("^0+(?!$)", ""));
							}
						}
					}
				}

			}

		} catch (Exception e) {
			logger.error("Exception RunTestServiceImpl in getEnbsiteIds() " + ExceptionUtils.getFullStackTrace(e));
		}

		return neIdList;

	}

	public String executeCommand5GAudit(String command, String outputFileName, String scriptArguments,
			String useCaseName) throws RctException {
		StringBuilder output = new StringBuilder();
		Process p = null;
		try {

			String[] fileName = command.split("\\.");
			String cmdExe = command;
			String[] cmdToExec = { "timeout", Constants.SSH_TIMEOUT.toString(), "/bin/sh", "-c", cmdExe };
			if (scriptArguments != null) {
				if ("py".equalsIgnoreCase(fileName[1])) {
					cmdExe = "python ".concat(command).concat(" ").concat(scriptArguments);
				} else if ("perl".equalsIgnoreCase(fileName[1]) || "pl".equalsIgnoreCase(fileName[1])) {
					cmdExe = "perl ".concat(command).concat(" ").concat(scriptArguments);
				} else if ("sh".equalsIgnoreCase(fileName[1])) {
					cmdExe = command.concat(" ").concat(scriptArguments);
				}
			}
			Runtime.getRuntime().exec("chmod -R 777 " + cmdExe);

			Thread.sleep(2000);

			p = Runtime.getRuntime().exec(cmdToExec);

			Thread.sleep(2000);

			BufferedReader reader = new BufferedReader(new InputStreamReader(p.getInputStream()));
			BufferedReader error = new BufferedReader(new InputStreamReader(p.getErrorStream()));

			OutputStream os = new FileOutputStream(outputFileName, true);

			String[] paths = command.split("/");

			String exeFileString = "Executing " + paths[paths.length - 1] + "\n";

			os.write(exeFileString.getBytes());
			output.append(exeFileString);

			if (reader != null) {
				String line;
				while ((line = reader.readLine()) != null) {

					if (line.contains("Permission denied, please try again")) {
						os.write("Operation Failed wrong password : Permission denied, please try again.".getBytes());
					}
					if (line.contains("No route to host")) {
						os.write("Operation Failed No route to host :ssh connect to host IP port 22: No route to host."
								.getBytes());
					}

					String lineData = line + "\n";

					String resultString = lineData.replaceAll("\\[\\dm", "").replaceAll("\\[[\\d;]*m", "")
							.replaceAll("\\u0007", "").replaceAll("\\u001B", "").replaceAll("\\]\\d;", "")
							.replaceAll("[*\\[]K", "");

					output.append(resultString);
					os.write(resultString.getBytes());
				}
			}
			if (error != null) {
				String line;
				while ((line = error.readLine()) != null) {

					String lineData = line + "\n";

					String resultString = lineData.replaceAll("\\[\\dm", "").replaceAll("\\[[\\d;]*m", "")
							.replaceAll("\\u0007", "").replaceAll("\\u001B", "").replaceAll("\\]\\d;", "")
							.replaceAll("[*\\[]K", "");

					output.append(resultString);
					os.write(resultString.getBytes());
				}
			}
			os.close();

		} catch (Exception e) {
			logger.error("Exception RunTestServiceImpl in executeCommand() " + ExceptionUtils.getFullStackTrace(e));
		} finally {
			if (CommonUtil.isValidObject(p)) {
				p.destroyForcibly();
			}
		}

		return output.toString();
	}

	// swetha
	@SuppressWarnings("unchecked")
	private void createAuditHtmlFile5GAudit(String htmlOutputFilPath, Integer runTestId, String ciqName, String enbId,
			String enbName, String lsmName, Map<String, String> scriptFilesDetails,
			NetworkConfigEntity networkConfigEntity, String type, StringBuilder required5GOutput,
			LinkedHashMap<String, Set<XmlElementEntity>> elementrulesMap, StringBuilder required5GOutputEnb,
			String programName, Map<String, Boolean> createHtmlMapBoo) {

		StringBuilder htmlContent = new StringBuilder();
		String timeStamp = new SimpleDateFormat("MMddyyyy").format(new Timestamp(System.currentTimeMillis()));
		String cascasdeId = "";
		BufferedReader bufferedReader = null;
		FileReader fileReader = null;
		String line = "";
		String scriptFilePath = "";
		String prompt = "";
		Map<String, Integer> cmdOccurances = new HashMap<>();
		try {
			String dbcollectionFileName = CommonUtil.createMongoDbFileName(
					String.valueOf(networkConfigEntity.getProgramDetailsEntity().getId()), ciqName);
			cascasdeId = fileUploadRepository.getEnBDataByPath(dbcollectionFileName, Constants.AUDIT_FDD_TDD, enbId,
					Constants.AUDIT_CASCADE);
			if (!StringUtils.isNotEmpty(cascasdeId)) {
				cascasdeId = enbId;
			}
			List<RunTestResultEntity> runTestResultEntityList = runTestResultRepository.getRunTestResultList(runTestId);
			String filePath = runTestService.loadRunningLog(runTestId);
			filePath = LoadPropertyFiles.getInstance().getProperty("BASE_PATH") + filePath;

			/*** Testing Code Starts ***/
			/*
			 * filePath = "/home/user/Desktop/Sprint_Output_Log.txt"; if (type == "xml") {
			 * filePath = "/home/user/Desktop/Vzn_Output_Log.txt"; }
			 */
			String fullOutputLog = required5GOutput.toString();
			String endcOutputlog = required5GOutputEnb.toString();

			/*
			 * if (type == "xml") {
			 * 
			 * filePath = "/home/bala/Desktop/audit5GResponse"; fullOutputLog =
			 * runTestService.readOutputFile(filePath); filePath =
			 * "/home/bala/Desktop/endc5GResponse"; endcOutputlog =
			 * runTestService.readOutputFile(filePath); }
			 */

			/*** Testing Code End ***/
			String useCaseNameList="";
			RunTestEntity runTestEntity1= null;
			String migrationSubType="";
			
				if (runTestResultEntityList != null && !runTestResultEntityList.isEmpty()) {
					runTestEntity1 = runTestResultEntityList.get(0).getRunTestEntity();
					useCaseNameList = runTestEntity1.getUseCase();
					migrationSubType=runTestEntity1.getMigrationSubType();

				}
			String enbNameColumnName = "NE NAME";
			String enbIdColumnName = "NE ID";
			String enbidcolumnvalue = enbId;
			String packageVersion = networkConfigEntity.getNeVersionEntity().getNeVersion();
			if (programName.contains("VZN-5G-DSS")) {
				enbNameColumnName = "NE NAME";
				enbIdColumnName = "eNB ID";
				packageVersion="-";
				List<CIQDetailsModel> listCIQDetailsModel = getCIQDetailsModelList(enbId, dbcollectionFileName);
				if (!ObjectUtils.isEmpty(listCIQDetailsModel)) {
					if (listCIQDetailsModel.get(0).getCiqMap().containsKey("4GeNB")) {
						enbidcolumnvalue = listCIQDetailsModel.get(0).getCiqMap().get("4GeNB").getHeaderValue()
								.replaceAll("^0+(?!$)", "");
					}
					if (listCIQDetailsModel.get(0).getCiqMap().containsKey("FR1_Solution")) {
						packageVersion = listCIQDetailsModel.get(0).getCiqMap().get("FR1_Solution").getHeaderValue()
								.trim();
					}else {
						List<CIQDetailsModel> listOfCiqDetails = auditXmlRulesServiceUtil5GDSS.getCiqDetailsForRuleValidationsheet(enbId, dbcollectionFileName,
								"vDUGrowSiteLevel(Day1)CQ", "eNBId");
						if (listOfCiqDetails.get(0).getCiqMap().containsKey("FR1_Solution")) {
							packageVersion = listOfCiqDetails.get(0).getCiqMap().get("FR1_Solution").getHeaderValue().trim()
									.replaceAll("^0+(?!$)", "");
						}
					}
				}
			} else if (programName.contains("5G-MM")) {
				List<CIQDetailsModel> listCIQDetailsModel = fileUploadRepository.getEnbTableDetailsRanConfig(ciqName,
						enbId, enbName, dbcollectionFileName, "5GNRCIQAU", "");
				enbNameColumnName = "NE NAME";
				enbIdColumnName = "SITE NAME";
				if (listCIQDetailsModel.get(0).getCiqMap().containsKey("VZW Site Name")) {
					enbidcolumnvalue = listCIQDetailsModel.get(0).getCiqMap().get("VZW Site Name").getHeaderValue()
							.replaceAll("^0+(?!$)", "");
				}
				if (!ObjectUtils.isEmpty(listCIQDetailsModel)) {
					if (listCIQDetailsModel.get(0).getCiqMap().containsKey("ne_version")) {
						packageVersion = listCIQDetailsModel.get(0).getCiqMap().get("ne_version").getHeaderValue()
								.trim();
					}
				}
			} else if (programName.contains("4G-USM-LIVE")) {
				List<CIQDetailsModel> listCIQDetailsModel = fileUploadRepository.getEnbTableDetailsRanConfig(ciqName,
						enbId, enbName, dbcollectionFileName, "CIQUpstateNY", "");
				if (!ObjectUtils.isEmpty(listCIQDetailsModel)) {
					if (listCIQDetailsModel.get(0).getCiqMap().containsKey("ne_version")) {
						packageVersion = listCIQDetailsModel.get(0).getCiqMap().get("ne_version").getHeaderValue()
								.trim();
					}
				}
			} else if (programName.contains("5G-CBAND")) {
				List<CIQDetailsModel> listCIQDetailsModel = fileUploadRepository.getEnbTableDetailsRanConfig(ciqName,
						enbId, enbName, dbcollectionFileName, "Day0_1", "");
				enbNameColumnName = "NE NAME";
				enbIdColumnName = "eNB ID";
				if (!ObjectUtils.isEmpty(listCIQDetailsModel)) {
					if (listCIQDetailsModel.get(0).getCiqMap().containsKey("ENB_ID")) {
						enbidcolumnvalue = listCIQDetailsModel.get(0).getCiqMap().get("ENB_ID").getHeaderValue()
								.replaceAll("^0+(?!$)", "");
					}
					if (listCIQDetailsModel.get(0).getCiqMap().containsKey("eNB_Version")) {
						packageVersion = listCIQDetailsModel.get(0).getCiqMap().get("eNB_Version").getHeaderValue()
								.trim();
					}
				}
			}else if (programName.contains("4G-FSU")) {
				List<CIQDetailsModel> listCIQDetailsModel = fileUploadRepository.getEnbTableDetailsRanConfig(ciqName,
						enbId, enbName, dbcollectionFileName, "FSUCIQ", "");
				enbNameColumnName = "NE NAME";
				enbIdColumnName = "eNB ID";
				if (!ObjectUtils.isEmpty(listCIQDetailsModel)) {
					if (listCIQDetailsModel.get(0).getCiqMap().containsKey("eNB_Name")) {
						enbidcolumnvalue = listCIQDetailsModel.get(0).getCiqMap().get("eNB_Name").getHeaderValue()
								.replaceAll("^0+(?!$)", "");
					}
					if (listCIQDetailsModel.get(0).getCiqMap().containsKey("NE_Version")) {
						packageVersion = listCIQDetailsModel.get(0).getCiqMap().get("NE_Version").getHeaderValue()
								.trim();
					}
				}
			}

			htmlContent.append("<table width=100% cellspacing=0 cellpadding=5 border=0>\n");
			if (createHtmlMapBoo.containsKey(XmlCommandsConstants.AU_TWAMP_F1C_LINK)
					&& createHtmlMapBoo.get(XmlCommandsConstants.AU_TWAMP_F1C_LINK)) {
				htmlContent.append("<tr><td align=center><font size=+3>" + cascasdeId + " " + enbName
						+ " TWAMP AUDIT REPORT " + timeStamp + " </font></td></tr>\n");
			} else if (createHtmlMapBoo.containsKey(XmlCommandsConstants.IAU_TWAMP_F1C_LINK)
					&& createHtmlMapBoo.get(XmlCommandsConstants.IAU_TWAMP_F1C_LINK)) {
				htmlContent.append("<tr><td align=center><font size=+3>" + cascasdeId + " " + enbName
						+ " TWAMP AUDIT REPORT " + timeStamp + " </font></td></tr>\n");
			} else if (createHtmlMapBoo.containsKey(XmlCommandsConstants.CBAND_VDU_MMUAUDIT)
					&& createHtmlMapBoo.get(XmlCommandsConstants.CBAND_VDU_MMUAUDIT)) {
				htmlContent.append("<tr><td align=center><font size=+3>" + cascasdeId + " " + enbName
						+ " MMU AUDIT REPORT " + timeStamp + " </font></td></tr>\n");
			} else if (programName.contains("5G-DSS")) {
				htmlContent.append("<tr><td align=center><font size=+3>" + cascasdeId + " " + enbName
						+ " AUDIT REPORT " + timeStamp + " </font></td></tr>\n");
			} else {
				htmlContent.append("<tr><td align=center><font size=+3>" + cascasdeId + " " + enbName + " AUDIT REPORT "
						+ timeStamp + " </font></td></tr>\n");
			}
			htmlContent.append("</table>\n");
			htmlContent.append("<br><br><table width=100% cellspacing=0 cellpadding=5 border=1 bordercolor=#000000>\n");
			if(programName.contains("4G-USM-LIVE")) {
			htmlContent.append("<tr><th align=center>NE ID</th><th align=center>" + enbNameColumnName
					+ "</th><th align=center>USM</th><th align=center>CIQ NAME</th><th align=center>CIQ PACKAGE VERSION</th><th align=center>USECASE NAME</th></tr>\n");
			}else if(programName.contains("VZN-5G-DSS")) {
			htmlContent.append("<tr><th align=center>NE ID</th><th align=center>" + enbIdColumnName
						+ "</th><th align=center>" + enbNameColumnName
						+ "</th><th align=center>USM</th><th align=center>CIQ NAME</th><th align=center>RAN TECHNOLOGY</th><th align=center>USECASE NAME</th></tr>\n");
			}else {
			htmlContent.append("<tr><th align=center>NE ID</th><th align=center>" + enbIdColumnName
						+ "</th><th align=center>" + enbNameColumnName
						+ "</th><th align=center>USM</th><th align=center>CIQ NAME</th><th align=center>CIQ PACKAGE VERSION</th><th align=center>USECASE NAME</th></tr>\n");
			}
			htmlContent.append("<tr><td align=center>" + cascasdeId + "</td>\n");
			if(!programName.contains("4G-USM-LIVE")) {
			htmlContent.append("<td align=center>" + enbidcolumnvalue + "</td>\n");
			}
			htmlContent.append("<td align=center>" + enbName + "</td>\n");
			htmlContent.append("<td align=center>" + networkConfigEntity.getNeName() + "</td>\n");
			htmlContent.append("<td align=center>" + ciqName + "</td>\n");
			htmlContent.append("<td align=center>" + packageVersion + "</td>\n");
			
			htmlContent.append("<td align=center>" + useCaseNameList + "</td>\n");
			
			htmlContent.append("</td>\n");
			htmlContent.append("</tr>\n");
			htmlContent.append("</table>\n");

			RunTestEntity runTestEntity = null;
			if (programName.contains("4G-USM-LIVE")) {
				if (runTestResultEntityList != null && !runTestResultEntityList.isEmpty()) {
					runTestEntity = runTestResultEntityList.get(0).getRunTestEntity();
					if(!migrationSubType.equalsIgnoreCase("PREAUDIT")) {
					audit4GIssueService.createAudit4GIssueEntity(enbId.replaceAll("^0+(?!$)", ""), runTestEntity);
					}
				}
				ArrayList<String> commandList = new ArrayList<>();
				commandList.add(XmlCommandsConstants.AUDIT_4G_PACKAGE_INVENTORY);
				commandList.add(XmlCommandsConstants.AUDIT_4G_REQUEST);
				commandList.add(XmlCommandsConstants.AUDIT_4G_NTP_STATUS_REQUEST);
				commandList.add(XmlCommandsConstants.AUDIT_4G_UCR_INVENTORY);
				commandList.add(XmlCommandsConstants.AUDIT_4G_REQUEST);
				commandList.add(XmlCommandsConstants.AUDIT_4G_PROCESSOR_FIRMWARE_INVENTORY);
				commandList.add(XmlCommandsConstants.AUDIT_4G_RADIO_UNIT_INVENTORY_MMU);
				commandList.add(XmlCommandsConstants.AUDIT_4G_RADIO_UNIT_INVENTORY_RRH);
				commandList.add(XmlCommandsConstants.AUDIT_4G_TTLNA_INFO);
				commandList.add(XmlCommandsConstants.AUDIT_4G_REQUEST);
				commandList.add(XmlCommandsConstants.AUDIT_4G_CELL_THROUGHPUT);
				commandList.add(XmlCommandsConstants.AUDIT_4G_REQUEST);
				commandList.add(XmlCommandsConstants.AUDIT_4G_SFP_INVENTORY);
				commandList.add(XmlCommandsConstants.AUDIT_4G_DU_OPTIC_LEVEL);
				commandList.add(XmlCommandsConstants.AUDIT_4G_REQUEST);
				commandList.add(XmlCommandsConstants.AUDIT_4G_RADIO_UNIT_SFP_INVENTORY);
				commandList.add(XmlCommandsConstants.AUDIT_4G_RU_OPTIC_LEVEL);
				commandList.add(XmlCommandsConstants.AUDIT_4G_REQUEST);
				commandList.add(XmlCommandsConstants.AUDIT_4G_TRUECALL_TRACEJOB);
				commandList.add(XmlCommandsConstants.AUDIT_4G_ENB_STATE_CHECK);
				commandList.add(XmlCommandsConstants.AUDIT_4G_OPTICDISTANCECHECK);
				commandList.add(XmlCommandsConstants.AUDIT_4G_TERMPOINTENB);
				commandList.add(XmlCommandsConstants.AUDIT_4G_ACTIVE_SOFTWARE);
				commandList.add(XmlCommandsConstants.AUDIT_4G_FW_AUTO_FUSING);
				commandList.add(XmlCommandsConstants.AUDIT_4G_RADIO_FIRMWARE_VERIFICATION);
				commandList.add(XmlCommandsConstants.AUDIT_4G_GROWPREFIXCHECK );
				commandList.add(XmlCommandsConstants.AUDIT_4G_OCNS_TEST_CELL_NUM);
				commandList.add(XmlCommandsConstants.AUDIT_4G_SDLC_STATE);
				commandList.add(XmlCommandsConstants.AUDIT_4G_ACTIVE_RET_ALARM);
				commandList.add(XmlCommandsConstants.AUDIT_4G_CBRSCHECKS);
				commandList.add(XmlCommandsConstants.AUDIT_4G_CBRSMODEANDUSERID);
				commandList.add(XmlCommandsConstants.AUDIT_4G_CBRSCALLSIGNANDFCCID);
				commandList.add(XmlCommandsConstants.AUDIT_4G_ENB_PREFERREDEARFCN);
				commandList.add(XmlCommandsConstants.AUDIT_4G_ENB_BANDWIDTH);
				commandList.add(XmlCommandsConstants.AUDIT_4G_ENB_CBSDSTATE);
				commandList.add(XmlCommandsConstants.AUDIT_4G_ENB_CBSDANDGRANTSTATE);
				commandList.add(XmlCommandsConstants.AUDIT_4G_ENB_PCIALLOCSTATUS);				
				commandList.add(XmlCommandsConstants.AUDIT_4G_CARRIER_RSSI);
				commandList.add(XmlCommandsConstants.AUDIT_4G_GROWPREFIX);
				commandList.add(XmlCommandsConstants.AUDIT_4G_RET_CHECKS);
				commandList.add(XmlCommandsConstants.AUDIT_4G_RET_AUDIT);
				commandList.add(XmlCommandsConstants.AUDIT_4G_PTP_CHECKS);
				commandList.add(XmlCommandsConstants.AUDIT_4G_SERIAL_NUMBER);
				commandList.add(XmlCommandsConstants.AUDIT_4G_FCC_RETRIEVE_RADIO_UNIT_INVENTORY);
				
				//rssi
				commandList.add(XmlCommandsConstants.RSSI_USE_CASE);
				

				ArrayList<Entry<String, String>> seqCommandList = new ArrayList<>();
				for (String comm : commandList) {
					for (Entry<String, String> scriptFileDetails : scriptFilesDetails.entrySet()) {
						scriptFilePath = scriptFileDetails.getKey();
						String command = FilenameUtils.removeExtension(FilenameUtils.getName(scriptFilePath));
						if (comm.equals(command)) {
							seqCommandList.add(scriptFileDetails);
						}
					}
				}
				int count4g = 0;
				for (Entry<String, String> scriptFileDetails : seqCommandList) {
					scriptFilePath = scriptFileDetails.getKey();
					String command = FilenameUtils.removeExtension(FilenameUtils.getName(scriptFilePath));
					if (command.equals(XmlCommandsConstants.AUDIT_4G_REQUEST)) {
						count4g++;
					}
					prompt = scriptFileDetails.getValue().replace("enbname", enbName).replace("enbId", enbId);
					createHtml(scriptFilePath, cmdOccurances, runTestResultEntityList, elementrulesMap, type,
							createHtmlMapBoo, htmlContent, fullOutputLog, prompt, enbId, dbcollectionFileName,
							endcOutputlog, count4g, programName, networkConfigEntity, runTestEntity);
				}

			}else if (programName.contains("5G-MM")) {
				if (runTestResultEntityList != null && !runTestResultEntityList.isEmpty()
						&& programName.contains("5G-MM")) {
					runTestEntity = runTestResultEntityList.get(0).getRunTestEntity();

				}
				ArrayList<String> commandList = new ArrayList<>();
				commandList.add(XmlCommandsConstants.ACPF_A1_21D_CHECKS);
				commandList.add(XmlCommandsConstants.ACPF_A2_21D_CHECKS);
				commandList.add(XmlCommandsConstants.ACPF_A3_21D_CHECKS);
				commandList.add(XmlCommandsConstants.ACPF_E1_F1_X2_21D_CHECKS);
				commandList.add(XmlCommandsConstants.ACPF_SON_ANR_CHECKS);
				commandList.add(XmlCommandsConstants.AU_TWAMP_F1C_LINK);
				commandList.add(XmlCommandsConstants.AU_20C_PROCESSOR_ENTRIES);
				commandList.add(XmlCommandsConstants.AU_21D_SFP_INVENTORY);
				commandList.add(XmlCommandsConstants.AU_21D_PARAM_CHECK);
				commandList.add(XmlCommandsConstants.AU_DSCP_PARAM_CHECK);
				commandList.add(XmlCommandsConstants.IAU_TWAMP_F1C_LINK);
				commandList.add(XmlCommandsConstants.IAU_21D_PROCESSOR_ENTRIES);
				commandList.add(XmlCommandsConstants.IAU_21D_SFP_INVENTORY);
				commandList.add(XmlCommandsConstants.IAU_21D_PARAM_CHECK);
				commandList.add(XmlCommandsConstants.IAU_DSCP_PARAM_CHECK);
				commandList.add(XmlCommandsConstants.ENB_20A0SWVERSION);
				commandList.add(XmlCommandsConstants.ENB_20B0SWVERSION);

				ArrayList<Entry<String, String>> seqCommandList = new ArrayList<>();
				for (String comm : commandList) {
					for (Entry<String, String> scriptFileDetails : scriptFilesDetails.entrySet()) {
						scriptFilePath = scriptFileDetails.getKey();
						String command = FilenameUtils.removeExtension(FilenameUtils.getName(scriptFilePath));
						if (comm.equals(command)) {
							seqCommandList.add(scriptFileDetails);
						}
					}
				}
				
				for (Entry<String, String> scriptFileDetails : seqCommandList) {
					scriptFilePath = scriptFileDetails.getKey();
					String command = FilenameUtils.removeExtension(FilenameUtils.getName(scriptFilePath));

					prompt = scriptFileDetails.getValue().replace("enbname", enbName).replace("enbId", enbId);
					createHtml(scriptFilePath, cmdOccurances, runTestResultEntityList, elementrulesMap, type,
							createHtmlMapBoo, htmlContent, fullOutputLog, prompt, enbId, dbcollectionFileName,
							endcOutputlog, 0, programName, networkConfigEntity, runTestEntity);
				}

			} else {
				
				if (runTestResultEntityList != null && !runTestResultEntityList.isEmpty()
						&& programName.contains("5G-CBAND")) {
					runTestEntity = runTestResultEntityList.get(0).getRunTestEntity();
					if(!migrationSubType.equalsIgnoreCase("PREAUDIT")) {
					audit5GCBandIssueService.createAudit5GCBandIssueEntity(enbId.replaceAll("^0+(?!$)", ""),
							runTestEntity);
					}
				} else if (runTestResultEntityList != null && !runTestResultEntityList.isEmpty()
						&& programName.contains("5G-DSS")) {
					runTestEntity = runTestResultEntityList.get(0).getRunTestEntity();
					if(!migrationSubType.equalsIgnoreCase("PREAUDIT")) {
					audit5GDSSIssueService.createAudit5GDSSIssueEntity(enbId.replaceAll("^0+(?!$)", ""), runTestEntity);
					}
				} else if (runTestResultEntityList != null && !runTestResultEntityList.isEmpty()
						&& programName.contains("4G-FSU")) {
					runTestEntity = runTestResultEntityList.get(0).getRunTestEntity();
					if(!migrationSubType.equalsIgnoreCase("PREAUDIT")) {
					audit4GFsuIssueService.createAudit4GFsuIssueEntity(enbId.replaceAll("^0+(?!$)", ""), runTestEntity);
					}
				}
				
				for (Entry<String, String> scriptFileDetails : scriptFilesDetails.entrySet()) {
					scriptFilePath = scriptFileDetails.getKey();
					prompt = scriptFileDetails.getValue().replace("enbname", enbName).replace("enbId", enbId);

					/*** Testing Code Starts ***/
					/*
					 * prompt = "[eNB_712832]"; if (type == "xml") { prompt =
					 * "vsmuser@116_00_00_LMD1_0"; }
					 */
					/*** Testing Code End ***/
					if(programName.contains("5G-DSS")) {
					String command = FilenameUtils.removeExtension(FilenameUtils.getName(scriptFilePath));
					if (command.equals(XmlCommandsConstants.DSS_VDU_ORUTABLE) 
							|| command.equals(XmlCommandsConstants.DSS_VDU_ORUPOSTTABLE)
							|| command.equals(XmlCommandsConstants.DSS_FSU_VRUENTRIES)
							|| command.equals(XmlCommandsConstants.DSS_VDU_ORUPLUMBING)) {
						continue;
					}
					}
					createHtml(scriptFilePath, cmdOccurances, runTestResultEntityList, elementrulesMap, type,
							createHtmlMapBoo, htmlContent, fullOutputLog, prompt, enbId, dbcollectionFileName,
							endcOutputlog, 0, programName, networkConfigEntity, runTestEntity);

				}
			}

			try (Writer writer = new BufferedWriter(
					new OutputStreamWriter(new FileOutputStream(htmlOutputFilPath), "utf-8"))) {
				writer.write(htmlContent.toString());
			}

			// AuditHtml taking from basepath+customer location
			String auditHtmlHardcodePth = LoadPropertyFiles.getInstance().getProperty("BASE_PATH") + Constants.CUSTOMER
					+ Constants.SEPARATOR + Constants.AUDIT_HTML_FILE;
			File originalfile = new File(auditHtmlHardcodePth);

			// FileUtils.copyFile(originalfile, new File(htmlOutputFilPath));

		} catch (Exception e) {
			logger.error(
					"Exception RunTestServiceImpl in createAuditHtmlFile() " + ExceptionUtils.getFullStackTrace(e));
		}

	}

	private void createHtml(String scriptFilePath, Map<String, Integer> cmdOccurances,
			List<RunTestResultEntity> runTestResultEntityList,
			LinkedHashMap<String, Set<XmlElementEntity>> elementrulesMap, String type,
			Map<String, Boolean> createHtmlMapBoo, StringBuilder htmlContent, String fullOutputLog, String prompt,
			String enbId, String dbcollectionFileName, String endcOutputlog, int count4g, String programName,
			NetworkConfigEntity networkConfigEntity, RunTestEntity runTestEntity) throws Exception {
		String command = FilenameUtils.removeExtension(FilenameUtils.getName(scriptFilePath));
		String resultNode = "";
		if (StringUtils.isNotEmpty(command) && command.contains(";")) {
			command = command.substring(0, command.indexOf(";") + 1);
		}
		if (StringUtils.isNotEmpty(command) && command.contains(":")) {
			resultNode = StringUtils.substringAfterLast(command, ":");
			resultNode = resultNode.trim();
			command = StringUtils.substringBeforeLast(command, ":");
		}

		List<JSONObject> cmdExecResultWithSeq = new ArrayList<>();
		UseCaseBuilderEntity useCaseBuilderEntity = null;
		String cmdName = command;
		int currentCmdSeq = -1;
		int commandRuleSequence = -1;
		if (cmdOccurances.isEmpty() || !cmdOccurances.containsKey(cmdName)) {
			currentCmdSeq = 1;
			cmdOccurances.put(cmdName, currentCmdSeq);
		} else if (cmdOccurances.containsKey(cmdName)) {
			currentCmdSeq = cmdOccurances.get(cmdName) + 1;
			cmdOccurances.put(cmdName, currentCmdSeq);
		}

		int count = 0;
		for (RunTestResultEntity entity : runTestResultEntityList) {
			count++;
			String cmdCompareTo = "";
			if (CommonUtil.isValidObject(entity.getCmdRuleBuilderEntity())) {

				cmdCompareTo = entity.getCmdRuleBuilderEntity().getCmdName();
			} else if (CommonUtil.isValidObject(entity.getXmlRuleBuilderEntity())) {

				cmdCompareTo = entity.getXmlRuleBuilderEntity().getCmdName();
			}

			if (StringUtils.isNotEmpty(entity.getRuleResultJson())
					&& ("FAIL".equalsIgnoreCase(entity.getCurrentResult())
							|| "WARN".equalsIgnoreCase(entity.getCurrentResult()))) {
				commandRuleSequence = -1;
				if (cmdCompareTo.equalsIgnoreCase(command)) {
					/*
					 * useCaseBuilderEntity = useCaseBuilderService
					 * .getUseCaseBuilderEntity(entity.getUseCaseID());
					 */

					useCaseBuilderEntity = entity.getUseCaseBuilderEntity();

					if (CommonUtil.isValidObject(useCaseBuilderEntity.getUseCaseBuilderParamEntity())
							&& useCaseBuilderEntity.getUseCaseBuilderParamEntity().size() > 0) {
						for (UseCaseBuilderParamEntity useCaseBuilderParamEntity : useCaseBuilderEntity
								.getUseCaseBuilderParamEntity()) {
							Set<UseCaseCmdRuleEntity> useCaseCmdRuleEntitySet = useCaseBuilderParamEntity
									.getUseCaseCmdRuleEntitySet();
							Set<UseCaseXmlRuleEntity> useCaseXmlRuleEntitySet = useCaseBuilderParamEntity
									.getUseCaseXmlRuleEntitySet();
							for (UseCaseCmdRuleEntity useCaseCmdRuleEntity : useCaseCmdRuleEntitySet) {
								if (useCaseCmdRuleEntity.getCmdRuleBuilderEntity().getId() == entity
										.getCmdRuleBuilderEntity().getId()) {
									commandRuleSequence = useCaseCmdRuleEntity.getCommandRuleSequence();
									JSONObject cmdFinalResult = new JSONObject();
									cmdFinalResult.put("commandRuleSequence", commandRuleSequence);
									cmdFinalResult.put("result", entity.getCurrentResult());
									cmdFinalResult.put("resultJsons", entity.getRuleResultJson());
									cmdExecResultWithSeq.add(cmdFinalResult);

								}
							}

							for (UseCaseXmlRuleEntity useCaseXmlRuleEntity : useCaseXmlRuleEntitySet) {
								if (useCaseXmlRuleEntity.getXmlRuleBuilderEntity().getId() == entity
										.getXmlRuleBuilderEntity().getId()) {
									commandRuleSequence = useCaseXmlRuleEntity.getXmlRuleSequence();
									JSONObject cmdFinalResult = new JSONObject();
									cmdFinalResult.put("commandRuleSequence", commandRuleSequence);
									cmdFinalResult.put("result", entity.getCurrentResult());
									cmdFinalResult.put("resultJsons", entity.getRuleResultJson());
									cmdExecResultWithSeq.add(cmdFinalResult);

								}
							}
						}
					}
				}
			}
		}
		if (type == "xml") {
			LinkedHashMap<String, XmlElementEntity> ruleMapDetails = new LinkedHashMap<>();
			if (!ObjectUtils.isEmpty(elementrulesMap) && elementrulesMap.containsKey(command)) {
				Set<XmlElementEntity> elementDetails = elementrulesMap.get(command);

				if (!ObjectUtils.isEmpty(elementDetails)) {
					for (XmlElementEntity xmlrule : elementDetails) {
						ruleMapDetails.put(xmlrule.getElementName(), xmlrule);
					}
				}

			}
			if (createHtmlMapBoo.containsKey(command) && createHtmlMapBoo.get(command)) {
				htmlContent.append(getXmlHtmlContent5GAudit(fullOutputLog, command, resultNode, prompt,
						cmdExecResultWithSeq, commandRuleSequence, currentCmdSeq, enbId, dbcollectionFileName,
						ruleMapDetails, endcOutputlog, count4g, networkConfigEntity, runTestEntity));
			} else if (createHtmlMapBoo.containsKey(command) && !createHtmlMapBoo.get(command)) {
				htmlContent.append(auditXmlRulesServiceUtil.getHtmlErrorOutput(fullOutputLog, command, programName,
						runTestEntity, enbId, dbcollectionFileName));
			} else if (programName.contains("4G-USM-LIVE") && !createHtmlMapBoo.containsKey(command)) {
				htmlContent.append(getXmlHtmlContent5GAudit("", command, resultNode, prompt, cmdExecResultWithSeq,
						commandRuleSequence, currentCmdSeq, enbId, dbcollectionFileName, ruleMapDetails, endcOutputlog,
						count4g, networkConfigEntity, runTestEntity));
			}

		} else {
			htmlContent.append(getCliHtmlContent(fullOutputLog, command, prompt, cmdExecResultWithSeq,
					commandRuleSequence, currentCmdSeq));
		}

		htmlContent.append("</table>\n");
	}

	@SuppressWarnings("unchecked")
	private StringBuilder getXmlHtmlContent5GAudit(String fullOutputLog, String command, String resultNode,
			String prompt, List<JSONObject> cmdExecResultWithSeq, int commandRuleSequence, int currentCmdSeq,
			String enbId, String dbcollectionFileName, LinkedHashMap<String, XmlElementEntity> ruleMapDetails,
			String endcOutput, int count, NetworkConfigEntity networkConfigEntity, RunTestEntity runTestEntity) {
		StringBuilder htmlContent = new StringBuilder();
		String outputLog = "";
		try {
			if (XmlCommandsConstants.ACPFE1F1X2CHECKS.equalsIgnoreCase(command)) {
				htmlContent = auditXmlRulesServiceUtil.getACPFX2E1F1checks(fullOutputLog, command, enbId,
						dbcollectionFileName);
			} else if (XmlCommandsConstants.AUPF_GETCSL_SERVER_SETTINGS.equalsIgnoreCase(command)) {
				htmlContent = auditXmlRulesServiceUtil.getAUPFCslServerSettings(fullOutputLog, command, enbId,
						dbcollectionFileName, ruleMapDetails);
			} else if (XmlCommandsConstants.ACPF_GETCSL_SERVER_SETTINGS.equalsIgnoreCase(command)) {
				htmlContent = auditXmlRulesServiceUtil.getACPFCslServerSettings(fullOutputLog, command, enbId,
						dbcollectionFileName, ruleMapDetails);
			} else if (XmlCommandsConstants.AU_ADDTNL_PARAM_CHECKS.equalsIgnoreCase(command)) {
				htmlContent = auditXmlRulesServiceUtil.getAuAddtnlParamChecks(fullOutputLog, command, enbId,
						dbcollectionFileName, ruleMapDetails);
			} else if (XmlCommandsConstants.ACPFA1A2A3_INCL_NR_UL_CHECKS.equalsIgnoreCase(command)) {
				htmlContent = auditXmlRulesServiceUtil.getACPFA1A2A3Checks(fullOutputLog, command, enbId,
						dbcollectionFileName);
			} else if (XmlCommandsConstants.AU_20A_PARAMCHECK.equalsIgnoreCase(command)) {
				htmlContent = auditXmlRulesServiceUtil.getAU20AParamCheckHtml(fullOutputLog, command, enbId,
						dbcollectionFileName);
			} else if (XmlCommandsConstants.ENB_20A0SWVERSION.equalsIgnoreCase(command)) {
				htmlContent = auditXmlRulesServiceUtil.getEndc20A0SwVersion(endcOutput, command, enbId,
						dbcollectionFileName);
			} else if (XmlCommandsConstants.ENB_20B0SWVERSION.equalsIgnoreCase(command)) {
				htmlContent = auditXmlRulesServiceUtil.getEndc20B0SwVersion(endcOutput, command, enbId,
						dbcollectionFileName);
			}/* else if (XmlCommandsConstants.DSS_ACPFA1A2A3.equalsIgnoreCase(command)) {
				htmlContent = auditXmlRulesServiceUtil.getACPFA1A2A3ChecksDSS(fullOutputLog, command, enbId,
						dbcollectionFileName);
			} else if (XmlCommandsConstants.DSS_ACPF_AUDIT.equalsIgnoreCase(command)) {
				htmlContent = auditXmlRulesServiceUtil.getAcpfAuditInputResponse(fullOutputLog, command, enbId,
						dbcollectionFileName);
			} else if (XmlCommandsConstants.DSS_AUPF_AUDIT.equalsIgnoreCase(command)) {
				htmlContent = auditXmlRulesServiceUtil.getAupfAuditInputResponse(fullOutputLog, command, enbId,
						dbcollectionFileName);
			} else if (XmlCommandsConstants.DSS_ENB_ENDC_AUDIT.equalsIgnoreCase(command)) {
				htmlContent = auditXmlRulesServiceUtil.getEnbEndcAudit(fullOutputLog, command, enbId,
						dbcollectionFileName);
			} else if (XmlCommandsConstants.DSS_FSU_AUDIT.equalsIgnoreCase(command)) {
				htmlContent = auditXmlRulesServiceUtil.getFSUAudit(fullOutputLog, command, enbId, dbcollectionFileName);
			} else if (XmlCommandsConstants.DSS_VDU_AUDIT.equalsIgnoreCase(command)) {
				htmlContent = auditXmlRulesServiceUtil.getvDUAudit(fullOutputLog, command, enbId, dbcollectionFileName);
			}*/ else if (XmlCommandsConstants.ACPF_20AP3_CHECK.equalsIgnoreCase(command)) {
				htmlContent = auditXmlRulesServiceUtil.getACPFAP3Check(fullOutputLog, command, enbId,
						dbcollectionFileName);
			} else if (XmlCommandsConstants.ACPF_20C_AUDIT.equalsIgnoreCase(command)) {
				htmlContent = auditXmlRulesServiceUtil.get20CACPF(fullOutputLog, command, enbId, dbcollectionFileName);
			} else if (XmlCommandsConstants.AU_20C_PARAMCHECK.equalsIgnoreCase(command)) {
				htmlContent = auditXmlRulesServiceUtil.get20CAUParamCheck(fullOutputLog, command, enbId,
						dbcollectionFileName, networkConfigEntity);
			} else if (XmlCommandsConstants.AU_21B_PARAMCHECK.equalsIgnoreCase(command)) {
				htmlContent = auditXmlRulesServiceUtil.get21BAUParamCheck(fullOutputLog, command, enbId,
						dbcollectionFileName, networkConfigEntity);
			} else if (XmlCommandsConstants.ACPFE1F1X2_20C.equalsIgnoreCase(command)) {
				htmlContent = auditXmlRulesServiceUtil.getACPFX2E1F120Cchecks(fullOutputLog, command, enbId,
						dbcollectionFileName);
			} else if (XmlCommandsConstants.ACPFA1A2A3_20C_CHECKS.equalsIgnoreCase(command)) {
				htmlContent = auditXmlRulesServiceUtil.getACPFA1A2A320CChecks(fullOutputLog, command, enbId,
						dbcollectionFileName);
			} else if (XmlCommandsConstants.ENB_20C0SWVERSION.equalsIgnoreCase(command)) {
				htmlContent = auditXmlRulesServiceUtil.getEndc20C0SwVersion(endcOutput, command, enbId,
						dbcollectionFileName);
			} else if (XmlCommandsConstants.AU_20C_PROCESSOR_ENTRIES.equalsIgnoreCase(command)) {
				htmlContent = auditXmlRulesServiceUtil.getAUProcessorInventory(fullOutputLog, command, enbId,
						dbcollectionFileName);
			} else if (XmlCommandsConstants.AUDIT_4G_REQUEST.equalsIgnoreCase(command)) {
				htmlContent = auditXmlRulesServiceUtil.get4GHtml(fullOutputLog, command, enbId, dbcollectionFileName,
						count, runTestEntity);
			} else if (XmlCommandsConstants.AUDIT_4G_NTP_STATUS_REQUEST.equalsIgnoreCase(command)
					|| XmlCommandsConstants.AUDIT_4G_PACKAGE_INVENTORY.equalsIgnoreCase(command)
					|| XmlCommandsConstants.AUDIT_4G_UCR_INVENTORY.equalsIgnoreCase(command)
					|| XmlCommandsConstants.AUDIT_4G_PROCESSOR_FIRMWARE_INVENTORY.equalsIgnoreCase(command)
					|| XmlCommandsConstants.AUDIT_4G_RADIO_UNIT_INVENTORY_MMU.equalsIgnoreCase(command)
					|| XmlCommandsConstants.AUDIT_4G_RADIO_UNIT_INVENTORY_RRH.equalsIgnoreCase(command)
					|| XmlCommandsConstants.AUDIT_4G_TTLNA_INFO.equalsIgnoreCase(command)
					|| XmlCommandsConstants.AUDIT_4G_SFP_INVENTORY.equalsIgnoreCase(command)
					|| XmlCommandsConstants.AUDIT_4G_RADIO_UNIT_SFP_INVENTORY.equalsIgnoreCase(command)
					|| XmlCommandsConstants.AUDIT_4G_ACTIVE_SOFTWARE.equalsIgnoreCase(command)) {
				htmlContent = auditXmlRulesServiceUtil.get4GrequestretrieveHtml(fullOutputLog, command, enbId,
						dbcollectionFileName, runTestEntity);
			} else if (XmlCommandsConstants.AUDIT_4G_CELL_THROUGHPUT.equalsIgnoreCase(command)) {
				htmlContent = auditXmlRulesServiceUtil.get4GrequestretrieveHtml(fullOutputLog, command, enbId,
						dbcollectionFileName, runTestEntity);
			} else if (XmlCommandsConstants.IAU_PARAMCHECK.equalsIgnoreCase(command)) {
				htmlContent = auditXmlRulesServiceUtil.getIAUParamCheck(fullOutputLog, command, enbId,
						dbcollectionFileName, networkConfigEntity);
			} /*else if (XmlCommandsConstants.DSS_FSU_AUDIT2.equalsIgnoreCase(command)) {
				htmlContent = auditXmlRulesServiceUtil.getFSUAuditDSS(fullOutputLog, command, enbId,
						dbcollectionFileName);
			} else if (XmlCommandsConstants.DSS_VDU_AUDIT2.equalsIgnoreCase(command)) {
				htmlContent = auditXmlRulesServiceUtil.getvDUAuditDSS(fullOutputLog, command, enbId,
						dbcollectionFileName);
			} else if (XmlCommandsConstants.DSS_FSU_CONFIG_AUDIT.equalsIgnoreCase(command)) {
				htmlContent = auditXmlRulesServiceUtil.getFSUConfigAuditDSS(fullOutputLog, command, enbId,
						dbcollectionFileName);
			} else if (XmlCommandsConstants.DSS_VDU_CONFIG_AUDIT.equalsIgnoreCase(command)) {
				htmlContent = auditXmlRulesServiceUtil.getvDUConfigAuditDSS(fullOutputLog, command, enbId,
						dbcollectionFileName);
			} else if (XmlCommandsConstants.DSS_ENB_AUDIT.equalsIgnoreCase(command)) {
				htmlContent = auditXmlRulesServiceUtil.getENBAuditDSS(fullOutputLog, command, enbId,
						dbcollectionFileName);
			}*/ else if (XmlCommandsConstants.AUDIT_4G_TRUECALL_TRACEJOB.equalsIgnoreCase(command)) {
				htmlContent = auditXmlRulesServiceUtil.get4GAuditTrueCallTrace(fullOutputLog, command, enbId,
						dbcollectionFileName, networkConfigEntity,runTestEntity);
			} else if (XmlCommandsConstants.AU_TWAMP_F1C_LINK.equalsIgnoreCase(command)) {
				htmlContent = auditXmlRulesServiceUtil.get5GTwampoutput(fullOutputLog, command, enbId,
						dbcollectionFileName, networkConfigEntity);
			} else if (XmlCommandsConstants.IAU_TWAMP_F1C_LINK.equalsIgnoreCase(command)) {
				htmlContent = auditXmlRulesServiceUtil.get5GTwampoutputIAU(fullOutputLog, command, enbId,
						dbcollectionFileName, networkConfigEntity);
			} else if (XmlCommandsConstants.AUDIT_4G_ENB_STATE_CHECK.equalsIgnoreCase(command)) {
				htmlContent = auditXmlRulesServiceUtil.get4GenbState(fullOutputLog, command, enbId,
						dbcollectionFileName, runTestEntity);
			} else if (XmlCommandsConstants.AUDIT_4G_OPTICDISTANCECHECK.equalsIgnoreCase(command)) {
				htmlContent = auditXmlRulesServiceUtil.get4GOpticDistance(fullOutputLog, command, enbId,
						dbcollectionFileName, runTestEntity);
			} else if (XmlCommandsConstants.AUDIT_4G_TERMPOINTENB.equalsIgnoreCase(command)) {
				htmlContent = auditXmlRulesServiceUtil.get4GTermPointToEnb(fullOutputLog, command, enbId,
						dbcollectionFileName, runTestEntity);
			} else if (XmlCommandsConstants.CBAND_VDU_AUDIT.equalsIgnoreCase(command)) {
				htmlContent = auditXmlRulesServiceUtil.getvDUAuditCBand(fullOutputLog, command, enbId,
						dbcollectionFileName, runTestEntity,networkConfigEntity);
			} else if (XmlCommandsConstants.AUDIT_4G_OCNS_TEST_CELL_NUM.equalsIgnoreCase(command)) {
				htmlContent = auditXmlRulesServiceUtil.get4GOcnsTest(fullOutputLog, command, enbId,
						dbcollectionFileName, networkConfigEntity, runTestEntity);
			} else if (XmlCommandsConstants.CBAND_F1U_SOURCEIP.equalsIgnoreCase(command)) {
				htmlContent = auditXmlRulesServiceUtil.get5GCbandTwampTest(fullOutputLog, command, enbId,
						dbcollectionFileName, networkConfigEntity, runTestEntity);
			} else if (XmlCommandsConstants.CBAND_VDU_POSTAUDIT.equalsIgnoreCase(command)) {
				htmlContent = auditXmlRulesServiceUtil.getvDUAuditCBandPostAudit(fullOutputLog, command, enbId,
						dbcollectionFileName, runTestEntity,networkConfigEntity);
			} else if (XmlCommandsConstants.CBAND_VDU_PACKAGEINVENTORY.equalsIgnoreCase(command)) {
				htmlContent = auditXmlRulesServiceUtil.get5GCBandpackageinventory(fullOutputLog, command, enbId,
						dbcollectionFileName, runTestEntity);
			} else if (XmlCommandsConstants.CBAND_ACPF_E1F1X2.equalsIgnoreCase(command)) {
				htmlContent = auditXmlRulesServiceUtil.get5GCBandACPFX2E1F1(fullOutputLog, command, enbId,
						dbcollectionFileName, runTestEntity);
			} else if (XmlCommandsConstants.CBAND_ACPF_ALARMENTRIES.equalsIgnoreCase(command)) {
				htmlContent = auditXmlRulesServiceUtil.get5GCBandACPFaactivealarmentries(fullOutputLog, command, enbId,
						dbcollectionFileName, runTestEntity);
			} else if (XmlCommandsConstants.CBAND_AUPF_ALARMENTRIES.equalsIgnoreCase(command)) {
				htmlContent = auditXmlRulesServiceUtil.get5GCBandAUPFaactivealarmentries(fullOutputLog, command, enbId,
						dbcollectionFileName, runTestEntity);
			} else if (XmlCommandsConstants.CBAND_ENB_ALARMENTRIES.equalsIgnoreCase(command)) {
				htmlContent = auditXmlRulesServiceUtil.get5GCBandeNBaactivealarmentries(fullOutputLog, command, enbId,
						dbcollectionFileName, runTestEntity);
			} else if (XmlCommandsConstants.DSS_VDU_PREAUDIT.equalsIgnoreCase(command)) {
				htmlContent = auditXmlRulesServiceUtil5GDSS.getvDUAuditDSS(fullOutputLog, command, enbId,
						dbcollectionFileName, runTestEntity, networkConfigEntity);
			} else if (XmlCommandsConstants.DSS_F1U_SOURCEIP.equalsIgnoreCase(command)) {
				htmlContent = auditXmlRulesServiceUtil5GDSS.get5GCbandTwampTest(fullOutputLog, command, enbId,
						dbcollectionFileName, networkConfigEntity, runTestEntity);
			} else if (XmlCommandsConstants.DSS_ENB_PREAUDIT.equalsIgnoreCase(command)) {
				htmlContent = auditXmlRulesServiceUtil5GDSS.getENBAuditDSSPreAudit(fullOutputLog, command, enbId,
						dbcollectionFileName, runTestEntity);
			} else if (XmlCommandsConstants.DSS_ACPF_E1F1X2.equalsIgnoreCase(command)) {
				htmlContent = auditXmlRulesServiceUtil5GDSS.get5GDSSACPFX2E1F1(fullOutputLog, command, enbId,
						dbcollectionFileName, runTestEntity);
			} else if (XmlCommandsConstants.DSS_VDU_POSTAUDIT.equalsIgnoreCase(command)) {
				htmlContent = auditXmlRulesServiceUtil5GDSS.getvDUAuditDSSPostAudit(fullOutputLog, command, enbId,
						dbcollectionFileName, runTestEntity,networkConfigEntity);
			} else if (XmlCommandsConstants.DSS_ACPF_POSTAUDIT.equalsIgnoreCase(command)) {
				htmlContent = auditXmlRulesServiceUtil5GDSS.get5GDSSACPFaactivealarmentries(fullOutputLog, command,
						enbId, dbcollectionFileName, runTestEntity);
			} else if (XmlCommandsConstants.DSS_AUPF_POSTAUDIT.equalsIgnoreCase(command)) {
				htmlContent = auditXmlRulesServiceUtil5GDSS.get5GDSSAUPFaactivealarmentries(fullOutputLog, command,
						enbId, dbcollectionFileName, runTestEntity);
			} else if (XmlCommandsConstants.DSS_ENB_POSTAUDIT.equalsIgnoreCase(command)) {
				htmlContent = auditXmlRulesServiceUtil5GDSS.getENBAuditDSSPostAudit(fullOutputLog, command, enbId,
						dbcollectionFileName, runTestEntity);
			} else if (XmlCommandsConstants.DSS_FSU_POSTAUDIT.equalsIgnoreCase(command)) {
				htmlContent = auditXmlRulesServiceUtil5GDSS.getFSUAuditDSSPostAudit(fullOutputLog, command, enbId,
						dbcollectionFileName, runTestEntity,networkConfigEntity);
			} else if (XmlCommandsConstants.AUDIT_4G_SDLC_STATE.equalsIgnoreCase(command)) {
				htmlContent = auditXmlRulesServiceUtil.get4GAuditSdlcState(fullOutputLog, command, enbId,
						dbcollectionFileName, runTestEntity);
			} else if (XmlCommandsConstants.AUDIT_4G_ACTIVE_RET_ALARM.equalsIgnoreCase(command)) {
				htmlContent = auditXmlRulesServiceUtil.get4GAuditRetAlarm(fullOutputLog, command, enbId,
						dbcollectionFileName, runTestEntity);
			} else if (XmlCommandsConstants.CBAND_ENB_PACKAGEINVENTORY.equalsIgnoreCase(command)) {
				htmlContent = auditXmlRulesServiceUtil.get5GCBandeNBpackageinventory(fullOutputLog, command, enbId,
						dbcollectionFileName, runTestEntity);
			} else if (XmlCommandsConstants.DSS_ENB_SOFTWAREVERSION.equalsIgnoreCase(command)) {
				htmlContent = auditXmlRulesServiceUtil5GDSS.getENBAuditDSSSoftwareVersion(fullOutputLog, command, enbId,
						dbcollectionFileName, runTestEntity);
			} else if (XmlCommandsConstants.DSS_FSU_SOFTWAREVERSION.equalsIgnoreCase(command)) {
				htmlContent = auditXmlRulesServiceUtil5GDSS.getFSUAuditDSSSoftwareVersion(fullOutputLog, command, enbId,
						dbcollectionFileName, runTestEntity);
			} else if (XmlCommandsConstants.DSS_VDU_STATICROUTE.equalsIgnoreCase(command)) {
				htmlContent = auditXmlRulesServiceUtil5GDSS.getvDUAuditDSSstaticRoute(fullOutputLog, command, enbId,
						dbcollectionFileName, runTestEntity);
			} else if (XmlCommandsConstants.CBAND_VDU_CELLSTATUS.equalsIgnoreCase(command)) {
				htmlContent = auditXmlRulesServiceUtil.getvDUAuditCBandCellStatus(fullOutputLog, command, enbId,
						dbcollectionFileName, runTestEntity);
			} else if (XmlCommandsConstants.ACPFA2_CHECKS.equalsIgnoreCase(command)) {
				htmlContent = auditXmlRulesServiceUtil.getACPFA2Checks(fullOutputLog, command, enbId,
						dbcollectionFileName);
			} else if (XmlCommandsConstants.ACPFA3_CHECKS.equalsIgnoreCase(command)) {
				htmlContent = auditXmlRulesServiceUtil.getACPFA3Checks(fullOutputLog, command, enbId,
						dbcollectionFileName);
			} else if (XmlCommandsConstants.CBAND_VDU_MMUSERIALNUM.equalsIgnoreCase(command)) {
				htmlContent = auditXmlRulesServiceUtil.get5GCBandvDUMMUSerialNum(fullOutputLog, command, enbId,
						dbcollectionFileName, runTestEntity);
			} else if (XmlCommandsConstants.CBAND_VDU_VDUSTATUS.equalsIgnoreCase(command)) {
				htmlContent = auditXmlRulesServiceUtil.getvDUAuditCBandvDuStatus(fullOutputLog, command, enbId,
						dbcollectionFileName, runTestEntity);
			} else if (XmlCommandsConstants.CBAND_VDU_SFPMMUCHECK.equalsIgnoreCase(command)) {
				htmlContent = auditXmlRulesServiceUtil.getvDUAuditCBandPortTranscieverData(fullOutputLog, command,
						enbId, dbcollectionFileName, runTestEntity);
			} else if (XmlCommandsConstants.DSS_VDU_GUTRANDUCELL.equalsIgnoreCase(command)) {
				htmlContent = auditXmlRulesServiceUtil5GDSS.getvDUAuditDSSGutranDuCell(fullOutputLog, command, enbId,
						dbcollectionFileName, runTestEntity);
			} else if (XmlCommandsConstants.DSS_VDU_NRFREQUENCY.equalsIgnoreCase(command)) {
				htmlContent = auditXmlRulesServiceUtil5GDSS.getvDUAuditDSSNRFrequency(fullOutputLog, command, enbId,
						dbcollectionFileName, runTestEntity);
			} else if (XmlCommandsConstants.DSS_VDU_PRACHCONFIG.equalsIgnoreCase(command)) {
				htmlContent = auditXmlRulesServiceUtil5GDSS.getvDUAuditPrachConfig(fullOutputLog, command, enbId,
						dbcollectionFileName, runTestEntity);
			} else if (XmlCommandsConstants.DSS_VDU_PODSTATUS.equalsIgnoreCase(command)) {
				htmlContent = auditXmlRulesServiceUtil5GDSS.getvDUAuditPodStatus(fullOutputLog, command, enbId,
						dbcollectionFileName, runTestEntity);
			} else if (XmlCommandsConstants.DSS_VDU_PTPSYNC.equalsIgnoreCase(command)) {
				htmlContent = auditXmlRulesServiceUtil5GDSS.getvDUAuditptpsync(fullOutputLog, command, enbId,
						dbcollectionFileName, runTestEntity);
			} else if (XmlCommandsConstants.DSS_VDU_ENDPOINTDSS.equalsIgnoreCase(command)) {
				htmlContent = auditXmlRulesServiceUtil5GDSS.getvDUAuditendpointdss(fullOutputLog, command, enbId,
						dbcollectionFileName, runTestEntity);
			} else if (XmlCommandsConstants.DSS_VDU_VIRTUALPORTCHECK.equalsIgnoreCase(command)) {
				htmlContent = auditXmlRulesServiceUtil5GDSS.getvDUAuditvirtualportcheck(fullOutputLog, command, enbId,
						dbcollectionFileName, runTestEntity);
			} else if (XmlCommandsConstants.DSS_VDU_EXTERNALINTERFACE.equalsIgnoreCase(command)) {
				htmlContent = auditXmlRulesServiceUtil5GDSS.getvDUAuditexternalinterface(fullOutputLog, command, enbId,
						dbcollectionFileName, runTestEntity);
			} else if (XmlCommandsConstants.DSS_VDU_FLAVORANDSV.equalsIgnoreCase(command)) {
				htmlContent = auditXmlRulesServiceUtil5GDSS.getvDUAuditflavorsf(fullOutputLog, command, enbId,
						dbcollectionFileName, runTestEntity);
			} else if (XmlCommandsConstants.DSS_VDU_MMUSERIALNUMBER.equalsIgnoreCase(command)) {
				htmlContent = auditXmlRulesServiceUtil5GDSS.getvDUAuditMmuSerialNum(fullOutputLog, command, enbId,
						dbcollectionFileName, runTestEntity);
			} else if (XmlCommandsConstants.DSS_VDU_FSUMPLANEIP.equalsIgnoreCase(command)) {
				htmlContent = auditXmlRulesServiceUtil5GDSS.getvDUAuditFsuMplainIp(fullOutputLog, command, enbId,
						dbcollectionFileName, runTestEntity);
			} else if (XmlCommandsConstants.AUDIT_4G_CBRSMODEANDUSERID.equalsIgnoreCase(command)) {
				htmlContent = auditXmlRulesServiceUtil.get4GAuditcbrsid(fullOutputLog, command, enbId,
						dbcollectionFileName, runTestEntity);
			} else if (XmlCommandsConstants.AUDIT_4G_CBRSCALLSIGNANDFCCID.equalsIgnoreCase(command)) {
				htmlContent = auditXmlRulesServiceUtil.get4GAuditfccid(fullOutputLog, command, enbId,
						dbcollectionFileName, runTestEntity);
			} else if (XmlCommandsConstants.AUDIT_4G_ENB_BANDWIDTH.equalsIgnoreCase(command)) {
				htmlContent = auditXmlRulesServiceUtil.get4Genbbandwidth(fullOutputLog, command, enbId,
						dbcollectionFileName, runTestEntity);
			} else if (XmlCommandsConstants.AUDIT_4G_ENB_CBSDSTATE.equalsIgnoreCase(command)) {
				htmlContent = auditXmlRulesServiceUtil.get4GAuditEnbCbsdState(fullOutputLog, command, enbId,
						dbcollectionFileName, runTestEntity);
			} else if (XmlCommandsConstants.AUDIT_4G_ENB_CBSDANDGRANTSTATE.equalsIgnoreCase(command)) {
				htmlContent = auditXmlRulesServiceUtil.get4GAuditEnbCbsdAndGrantState(fullOutputLog, command, enbId,
						dbcollectionFileName, runTestEntity);
			} else if (XmlCommandsConstants.AUDIT_4G_ENB_PCIALLOCSTATUS.equalsIgnoreCase(command)) {
				htmlContent = auditXmlRulesServiceUtil.get4GAuditPciAllocState(fullOutputLog, command, enbId,
						dbcollectionFileName, runTestEntity);
			} else if (XmlCommandsConstants.AUDIT_4G_ENB_PREFERREDEARFCN.equalsIgnoreCase(command)) {
				htmlContent = auditXmlRulesServiceUtil.get4GAuditpreferredearfcn(fullOutputLog, command, enbId,
						dbcollectionFileName, runTestEntity);
			} else if (XmlCommandsConstants.AUDIT4G_FSU_BACKUPDB.equalsIgnoreCase(command)) {
				htmlContent = auditXmlRulesServiceUtil5GDSS.fsuaudit(fullOutputLog, command, enbId,
						dbcollectionFileName, runTestEntity);
			} else if (XmlCommandsConstants.AUDIT4G_FSU_POSTCHECKS.equalsIgnoreCase(command)) {
				htmlContent = auditXmlRulesServiceUtil5GDSS.getFsuPostChecks(fullOutputLog, command, enbId,
						dbcollectionFileName, runTestEntity);
			}else if (XmlCommandsConstants.AUDIT4G_ENB_SERIALNUMBER.equalsIgnoreCase(command)) {
				htmlContent = auditXmlRulesServiceUtil5GDSS.getFsuserialnumbers(fullOutputLog, command, enbId,
						dbcollectionFileName, runTestEntity);
			} else if (XmlCommandsConstants.AUDIT4G_ENB_TXRFPOWER.equalsIgnoreCase(command)) {
				htmlContent = auditXmlRulesServiceUtil5GDSS.getFsuTXRxPower(fullOutputLog, command, enbId,
						dbcollectionFileName, runTestEntity);
			} else if (XmlCommandsConstants.DSS_FSU_FSUTYPE.equalsIgnoreCase(command)) {
				htmlContent = auditXmlRulesServiceUtil5GDSS.getFsutypeaudit(fullOutputLog, command, enbId,
						dbcollectionFileName, runTestEntity);
			} else if (XmlCommandsConstants.DSS_VDU_TXRXPOWER.equalsIgnoreCase(command)) {
				htmlContent = auditXmlRulesServiceUtil5GDSS.getDSSTxRxPower(fullOutputLog, command, enbId,
						dbcollectionFileName, runTestEntity);
			} else if (XmlCommandsConstants.DSS_FSU_VRUENTRIES.equalsIgnoreCase(command)) {
				htmlContent = auditXmlRulesServiceUtil5GDSS.getFSUVRU(fullOutputLog, command, enbId,
						dbcollectionFileName, runTestEntity);
			} else if (XmlCommandsConstants.DSS_FSU_PREAUDIT.equalsIgnoreCase(command)) {
				htmlContent = auditXmlRulesServiceUtil5GDSS.getFsuPreAudit(fullOutputLog, command, enbId,
						dbcollectionFileName, runTestEntity);
			} else if (XmlCommandsConstants.AUDIT_4G_CARRIER_RSSI.equalsIgnoreCase(command)) {
				htmlContent = auditXmlRulesServiceUtil5GDSS.getCrrierRssioutput(fullOutputLog, command, enbId,
						dbcollectionFileName, runTestEntity);
			} else if (XmlCommandsConstants.CBAND_VDU_MMUAUDIT.equalsIgnoreCase(command)) {		//mmu audit CBand
				htmlContent = auditXmlRulesServiceUtil.getCBandMMUAudit(fullOutputLog, command, enbId,
						dbcollectionFileName, runTestEntity);
			} else if (XmlCommandsConstants.RSSI_USE_CASE.equalsIgnoreCase(command)) {		//rssi
				//command = "RSSI_Imbalance_Test";
				htmlContent = rSSIAuditXmlRulesServiceUtil.getRSSIImbalance(fullOutputLog, command, enbId,
						dbcollectionFileName, runTestEntity);
			} else if (XmlCommandsConstants.AUDIT_4G_DU_OPTIC_LEVEL.equalsIgnoreCase(command)) {
				htmlContent = auditXmlRulesServiceUtil5GDSS.getDuOpticLevel(fullOutputLog, command, enbId,
						dbcollectionFileName, runTestEntity);
			} else if (XmlCommandsConstants.AUDIT_4G_RU_OPTIC_LEVEL.equalsIgnoreCase(command)) {
				htmlContent = auditXmlRulesServiceUtil5GDSS.getRuOpticLevel(fullOutputLog, command, enbId,
						dbcollectionFileName, runTestEntity);
			}else if (XmlCommandsConstants.AUDIT4G_FSU_GROWPREFIX.equalsIgnoreCase(command)) {
				htmlContent = auditXmlRulesServiceUtil5GDSS.getGrowPrefixRemovalHtml(fullOutputLog, command, enbId,
						dbcollectionFileName, runTestEntity);
			}else if (XmlCommandsConstants.DSS_VDU_GROWPREFIX.equalsIgnoreCase(command)) {
				htmlContent = auditXmlRulesServiceUtil5GDSS.getGrowPrefixRemovalDSS(fullOutputLog, command, enbId,
						dbcollectionFileName, runTestEntity);
			}else if (XmlCommandsConstants.CBAND_VDU_GROWPREFIX.equalsIgnoreCase(command)) {
				htmlContent = auditXmlRulesServiceUtil5GDSS.getGrowPrefixRemovalCband(fullOutputLog, command, enbId,
						dbcollectionFileName, runTestEntity);
			}else if (XmlCommandsConstants.AUDIT_4G_GROWPREFIX.equalsIgnoreCase(command)) {
				htmlContent = auditXmlRulesServiceUtil5GDSS.getGrowPrefixRemoval4GUSM(fullOutputLog, command, enbId,
						dbcollectionFileName, runTestEntity);
			}else if (XmlCommandsConstants.AUDIT_4G_CBRSCHECKS.equalsIgnoreCase(command)) {
				htmlContent = auditXmlRulesServiceUtil5GDSS.getHtmlTableCbrsChecks(fullOutputLog, command, enbId,
						dbcollectionFileName, runTestEntity);
			}else if (XmlCommandsConstants.DSS_ACPF_PREAUDIT.equalsIgnoreCase(command)) {
				htmlContent = auditXmlRulesServiceUtil5GDSS.getHtmlTableDSSACPFPreAudit(fullOutputLog, command, enbId,
						dbcollectionFileName, runTestEntity);
			}else if (XmlCommandsConstants.CBAND_VDU_SOFTWARESLOT.equalsIgnoreCase(command)) {
				htmlContent = auditXmlRulesServiceUtil5GDSS.getHtmlTablesoftwareslot(fullOutputLog, command, enbId,
						dbcollectionFileName, runTestEntity);
			}else if (XmlCommandsConstants.AUDIT_4G_FW_AUTO_FUSING.equalsIgnoreCase(command)) {
				htmlContent = auditXmlRulesServiceUtil5GDSS.getHtmlTablefwautofusing(fullOutputLog, command, enbId,
						dbcollectionFileName, runTestEntity);
			}else if (XmlCommandsConstants.AUDIT_4G_RADIO_FIRMWARE_VERIFICATION.equalsIgnoreCase(command)) {
				htmlContent = auditXmlRulesServiceUtil5GDSS.getHtmlTableradiofirmware(fullOutputLog, command, enbId,
						dbcollectionFileName, runTestEntity);
			}else if (XmlCommandsConstants.AUDIT_4G_GROWPREFIXCHECK.equalsIgnoreCase(command)) {
				htmlContent = auditXmlRulesServiceUtil5GDSS.getHtmlTablesgrowcheck(fullOutputLog, command, enbId,
						dbcollectionFileName, runTestEntity);
			}else if (XmlCommandsConstants.AUDIT_4G_RET_CHECKS.equalsIgnoreCase(command)) {
				htmlContent = auditXmlRulesServiceUtil5GDSS.get4GAuditRet1(fullOutputLog, command, enbId,
						dbcollectionFileName, runTestEntity);
			}else if (XmlCommandsConstants.AUDIT_4G_RET_AUDIT.equalsIgnoreCase(command)) {
				htmlContent = auditXmlRulesServiceUtil5GDSS.get4GAuditRet2(fullOutputLog, command, enbId,
						dbcollectionFileName, runTestEntity);
			}else if (XmlCommandsConstants.DSS_ENB_IMPACT_AUDIT.equalsIgnoreCase(command) 
					|| XmlCommandsConstants.CBAND_ENB_IMPACT_AUDIT.equalsIgnoreCase(command)) {
				htmlContent = auditXmlRulesServiceUtil5GDSS.getENBAuditDSSMIGAUDIT(fullOutputLog, command, enbId,
						dbcollectionFileName, runTestEntity);
			}else if (XmlCommandsConstants.DSS_ENB_POST_IMPACT_AUDIT.equalsIgnoreCase(command)
					||XmlCommandsConstants.CBAND_ENB_POST_IMPACT_AUDIT.equalsIgnoreCase(command)) {
				htmlContent = auditXmlRulesServiceUtil5GDSS.getENBAuditDSSMIGAUDITDIFFHTML(fullOutputLog, command, enbId,
						dbcollectionFileName, runTestEntity);
			}else if (XmlCommandsConstants.DSS_FSU_IMPACT_AUDIT.equalsIgnoreCase(command)) {
				htmlContent = auditXmlRulesServiceUtil5GDSS.getAuditAuditDSSPostMIGAUDIT(fullOutputLog, command, enbId,
						dbcollectionFileName, runTestEntity);
			}else if (XmlCommandsConstants.DSS_FSU_POST_IMPACT_AUDIT.equalsIgnoreCase(command)) {
				htmlContent = auditXmlRulesServiceUtil5GDSS.getAuditAuditDSSMIGAUDIT(fullOutputLog, command, enbId,
						dbcollectionFileName, runTestEntity);
			}else if (XmlCommandsConstants.AU_21D_SFP_INVENTORY.equalsIgnoreCase(command)) {
				htmlContent = auditXmlRulesServiceUtil5GMM.get5GMMAuditSfpHtml(fullOutputLog, command, enbId,
						dbcollectionFileName, runTestEntity,networkConfigEntity);
			}else if (XmlCommandsConstants.ACPF_A1_21D_CHECKS.equalsIgnoreCase(command)) {
				htmlContent = auditXmlRulesServiceUtil5GMM.getAudit5GMMA1Checks(fullOutputLog, command, enbId,
						dbcollectionFileName, runTestEntity,networkConfigEntity);
			}else if (XmlCommandsConstants.ACPF_A2_21D_CHECKS.equalsIgnoreCase(command)) {
				htmlContent = auditXmlRulesServiceUtil5GMM.getAudit5GMMA2Checks(fullOutputLog, command, enbId,
						dbcollectionFileName, runTestEntity,networkConfigEntity);
			}else if (XmlCommandsConstants.ACPF_A3_21D_CHECKS.equalsIgnoreCase(command)) {
				htmlContent = auditXmlRulesServiceUtil5GMM.getAudit5GMMA3Checks(fullOutputLog, command, enbId,
						dbcollectionFileName, runTestEntity,networkConfigEntity);
			}else if (XmlCommandsConstants.ACPF_E1_F1_X2_21D_CHECKS.equalsIgnoreCase(command)) {
				htmlContent = auditXmlRulesServiceUtil5GMM.getAudit5GMME1F1X2Checks(fullOutputLog, command, enbId,
						dbcollectionFileName, runTestEntity,networkConfigEntity);
			}else if (XmlCommandsConstants.AU_21D_PARAM_CHECK.equalsIgnoreCase(command)) {
				htmlContent = auditXmlRulesServiceUtil5GMM.getAudit5GMMHTMlParamChecks(fullOutputLog, command, enbId,
						dbcollectionFileName, runTestEntity,networkConfigEntity);
			}else if (XmlCommandsConstants.ACPF_SON_ANR_CHECKS.equalsIgnoreCase(command)) {
				htmlContent = auditXmlRulesServiceUtil5GMM.getAudit5GMMSonANRChecks(fullOutputLog, command, enbId,
						dbcollectionFileName, runTestEntity);
			}else if (XmlCommandsConstants.DSS_ENB_ENDC_AUDIT.equalsIgnoreCase(command)) {
				htmlContent = auditXmlRulesServiceUtil5GDSS.getAuditEndc(fullOutputLog, command, enbId,
						dbcollectionFileName, runTestEntity);
			}else if (XmlCommandsConstants.IAU_21D_PARAM_CHECK.equalsIgnoreCase(command)) {
				htmlContent = auditXmlRulesServiceUtil5GMM.getAudit5GMMIAUParamChecks(fullOutputLog, command, enbId,
						dbcollectionFileName, runTestEntity,networkConfigEntity);
			}else if (XmlCommandsConstants.IAU_21D_PROCESSOR_ENTRIES.equalsIgnoreCase(command)) {
				htmlContent = auditXmlRulesServiceUtil5GMM.getAuditHTML5GMMPROCESSORENTRIES(fullOutputLog, command, enbId,
						dbcollectionFileName, runTestEntity,networkConfigEntity);
			}else if (XmlCommandsConstants.IAU_21D_SFP_INVENTORY.equalsIgnoreCase(command)) {
				htmlContent = auditXmlRulesServiceUtil5GMM.getAuditHTML5GMMSFPInventory(fullOutputLog, command, enbId,
						dbcollectionFileName, runTestEntity,networkConfigEntity);
			}else if (XmlCommandsConstants.AU_DSCP_PARAM_CHECK.equalsIgnoreCase(command)) {
				htmlContent = auditXmlRulesServiceUtil5GMM.getAuditHTML5GMMAuDscp(fullOutputLog, command, enbId,
						dbcollectionFileName, runTestEntity);
			}else if (XmlCommandsConstants.IAU_DSCP_PARAM_CHECK.equalsIgnoreCase(command)) {
				htmlContent = auditXmlRulesServiceUtil5GMM.getAuditHTML5GMMIAUDscp(fullOutputLog, command, enbId,
						dbcollectionFileName, runTestEntity);
			}else if (XmlCommandsConstants.CBAND_VDU_MH1IPFETCH.equalsIgnoreCase(command) 
					|| XmlCommandsConstants.DSS_VDU_MH1IPFETCH.equalsIgnoreCase(command)) {
				htmlContent = auditXmlRulesServiceUtil5GDSS.getAuditmh1Ip(fullOutputLog, command, enbId,
						dbcollectionFileName, runTestEntity);
			}else if (XmlCommandsConstants.AUDIT4G_ENB_RETRIEVE_CELL_THROUGHPUT.equalsIgnoreCase(command)) {
				htmlContent = auditXmlRulesServiceUtil5GMM.getFSUThoughtputAuditHtmlContent(fullOutputLog, command, enbId,
						dbcollectionFileName, runTestEntity);
			}else if (XmlCommandsConstants.CBAND_VDU_MMUREPORTINGTOOL.equalsIgnoreCase(command)) {
				htmlContent = auditXmlRulesServiceUtil5GMM.getCBandMMUReportingAudit(fullOutputLog, command, enbId,
						dbcollectionFileName, runTestEntity);
			}else if (XmlCommandsConstants.CBAND_VDU_SERIALNUMMMU.equalsIgnoreCase(command)) {
				htmlContent = auditXmlRulesServiceUtil5GMM.getCBandMMUSerialNumberAudit(fullOutputLog, command, enbId,
						dbcollectionFileName, runTestEntity);
			}else if (XmlCommandsConstants.AUDIT_4G_PTP_CHECKS.equalsIgnoreCase(command)) {
				htmlContent = auditXmlRulesServiceUtil5GMM.getUsmPTPAuditHTML(fullOutputLog, command, enbId,
						dbcollectionFileName, runTestEntity);
			}else if (XmlCommandsConstants.AUDIT_4G_SERIAL_NUMBER.equalsIgnoreCase(command)) {
				htmlContent = auditXmlRulesServiceUtil5GMM.getUSMMMUSerialNumberAudit(fullOutputLog, command, enbId,
						dbcollectionFileName, runTestEntity);
			}else if (XmlCommandsConstants.CBAND_VDU_E_TILT.equalsIgnoreCase(command)) {
				htmlContent = auditXmlRulesServiceUtil5GMM.getCbandAudit(fullOutputLog, command, enbId,
						dbcollectionFileName, runTestEntity);
			}else if (XmlCommandsConstants.AUDIT4G_FSU_SFP_INVENTORY.equalsIgnoreCase(command)) {
				htmlContent = auditXmlRulesServiceUtil5GMM.get4GFsuAudit(fullOutputLog, command, enbId,
						dbcollectionFileName, runTestEntity);
			}else if (XmlCommandsConstants.DSS_VDU_POWERAUDIT.equalsIgnoreCase(command)) {
				htmlContent = auditXmlRulesServiceUtil5GMM.getDssPowerAudit(fullOutputLog, command, enbId,
						dbcollectionFileName, runTestEntity);
			}else if (XmlCommandsConstants.AUDIT_4G_FCC_RETRIEVE_RADIO_UNIT_INVENTORY.equalsIgnoreCase(command)) {
				htmlContent = auditXmlRulesServiceUtil5GMM.getUsmHarwaareTable(fullOutputLog, command, enbId,
						dbcollectionFileName, runTestEntity);
			}else {
				
				currentCmdSeq = commandRuleSequence;
				htmlContent.append(
						"<br><br><table cellspacing=0 cellpadding=5 border=1 bordercolor=#000000 style=\"min-width: 100%;table-layout: fixed;white-space: pre;\">\n");
				/*
				 * for (int logSeq = 1; logSeq <= currentCmdSeq; logSeq++) {
				 * logger.info("RunTestServiceImpl getXmlHtmlContent() logSeq: " + logSeq +
				 * ", currentCmdSeq: " + currentCmdSeq); fullOutputLog =
				 * StringUtils.substringAfter(fullOutputLog, command);
				 * 
				 * outputLog = StringUtils.substringBefore(fullOutputLog,
				 * XmlCommandsConstants.ENDTEXT5G); if (logSeq == currentCmdSeq) { break; } }
				 */
				fullOutputLog = StringUtils.substringAfter(fullOutputLog, command);
				outputLog = StringUtils.substringBefore(fullOutputLog, XmlCommandsConstants.ENDTEXT5G);
				outputLog = StringUtils.substringAfter(outputLog, "<");
				outputLog = "<" + outputLog;
				int rowIndex = 0;
				boolean tableHeaderFound = false;
				String tableHeader = "";
				String tableData = "";
				int colSpanCount = 0;
				DocumentBuilderFactory factory = DocumentBuilderFactory.newInstance();
				DocumentBuilder builder = factory.newDocumentBuilder();
				outputLog = "<parent>" + outputLog + "</parent>";
				Document document = builder.parse(new InputSource(new StringReader(outputLog)));

				if (!StringUtils.isNotEmpty(resultNode)) {
					Element elements = document.getDocumentElement();
					int level = 1;
					NodeList childNodeList = elements.getChildNodes();
					depthOfXML = 0;
					resultNode = getResultNode(childNodeList, level);
				}

				String firstColumnName = null;
				if (resultNode.contains(",")) {
					String[] resultNodeArray = resultNode.split(",");
					firstColumnName = resultNodeArray[0];
					resultNode = resultNodeArray[1];
				}

				NodeList nodeList = document.getElementsByTagName(resultNode);

				List<Map<String, JSONObject>> dataList = new ArrayList<Map<String, JSONObject>>();
				List<String> headList = new ArrayList<String>();
				Map<Integer, Map<String, String>> rowColors = new HashMap<>();
				for (int k = 0; k < nodeList.getLength(); k++) {
					Node childNode = nodeList.item(k);
					if (Node.ELEMENT_NODE == childNode.getNodeType()) {
						NodeList childNodeList = childNode.getChildNodes();
						Map<String, String> columnColors = new HashMap<>();
						JSONArray columnIndexes = null;
						List<JSONObject> columnIndexesResultList = new ArrayList<JSONObject>();
						JSONObject columnIndexesResult = new JSONObject();
						int colIndex = 0;
						int columnCount = 0;
						String tempThString = "";
						List<String> tempHeadList = new ArrayList<String>();
						Map<String, JSONObject> data = new HashMap<>();

						if (!tableHeaderFound) {
							tableHeader = tableHeader + "<tr>\n";
						}
						if (CommonUtil.isValidObject(cmdExecResultWithSeq) && cmdExecResultWithSeq.size() > 0) {
							for (JSONObject cmdExecResult : cmdExecResultWithSeq) {
								if (currentCmdSeq != -1
										&& Integer.parseInt(cmdExecResult.get("commandRuleSequence").toString()) != -1
										&& currentCmdSeq == Integer
												.parseInt(cmdExecResult.get("commandRuleSequence").toString())
										&& ("FAIL".equalsIgnoreCase(cmdExecResult.get("result").toString())
												|| "WARN".equalsIgnoreCase(cmdExecResult.get("result").toString()))) {

									String cmdRuleResultJson = cmdExecResult.get("resultJsons").toString();
									JSONObject json = CommonUtil.parseDataToJSON(cmdRuleResultJson);
									JSONArray rows = (JSONArray) json.get("rows");
									if (rows != null && rows.size() > 0) {
										for (int i = 0; i < rows.size(); i++) {
											JSONObject row = (JSONObject) rows.get(i);
											String matchRowIndex = row.get("index").toString();
											if (StringUtils.isNotEmpty(matchRowIndex)
													&& rowIndex == Integer.parseInt(matchRowIndex)) {
												columnIndexes = (JSONArray) row.get("columnIndexes");
												columnIndexesResult = new JSONObject();
												columnIndexesResult.put("result", cmdExecResult.get("result"));
												columnIndexesResult.put("columnIndexes", row.get("columnNames"));
												columnIndexesResultList.add(columnIndexesResult);

												// break;
											}

										}
									}
								}
							}
						}

						if (StringUtils.isNotEmpty(firstColumnName)) {
							columnCount++;
							tempHeadList.add(firstColumnName);
							tempThString = tempThString + "<th align=center>" + firstColumnName + "</th>\n";
						}

						for (int j = 0; j < childNodeList.getLength(); j++) {
							Node inChildNode = childNodeList.item(j);
							if (Node.ELEMENT_NODE == inChildNode.getNodeType()) {
								columnCount++;
								tempHeadList.add(inChildNode.getNodeName().trim());

								tempThString = tempThString + "<th align=center>" + inChildNode.getNodeName()
										+ "</th>\n";

							}
						}

						if (columnCount > colSpanCount) {
							colSpanCount = columnCount;
							tableHeader = tempThString;
							headList = tempHeadList;
						}

						String tdBgColor = "";
						for (JSONObject result : columnIndexesResultList) {

							columnIndexes = (JSONArray) result.get("columnIndexes");
							if (columnIndexes != null && columnIndexes.size() > 0) {
								for (int j = 0; j < columnIndexes.size(); j++) {
									if ("FAIL".equalsIgnoreCase(result.get("result").toString())) {
										tdBgColor = "#FF0000";
									} else if ("WARN".equalsIgnoreCase(result.get("result").toString())) {
										tdBgColor = "#FFFF00";
									} else {
										tdBgColor = "";
									}

									columnColors.put(columnIndexes.get(j).toString(), tdBgColor);
								}
							}

						}
						rowColors.put(rowIndex, columnColors);
						rowIndex++;
						colIndex = 0;

						for (int j = 0; j < childNodeList.getLength(); j++) {
							Node inChildNode = childNodeList.item(j);
							if (Node.ELEMENT_NODE == inChildNode.getNodeType()) {

								if (StringUtils.isNotEmpty(firstColumnName)) {
									Element eElement = (Element) inChildNode.getParentNode().getParentNode()
											.getParentNode();

									JSONObject jsonObject = new JSONObject();
									String color = "";
									if (StringUtils.isNotEmpty(columnColors.get(firstColumnName))) {
										color = columnColors.get(firstColumnName);
									}
									jsonObject.put("color", color);
									jsonObject.put("text",
											eElement.getElementsByTagName(firstColumnName).item(0).getTextContent());
									data.put(firstColumnName, jsonObject);
								}

								JSONObject jsonObject = new JSONObject();
								String color = "";
								if (StringUtils.isNotEmpty(columnColors.get(inChildNode.getNodeName()))) {
									color = columnColors.get(inChildNode.getNodeName());
								}
								jsonObject.put("color", color);
								jsonObject.put("text", inChildNode.getTextContent());
								data.put(inChildNode.getNodeName(), jsonObject);
								colIndex++;
							}
						}
						dataList.add(data);
						if (!tableHeaderFound) {
							tableHeader = tableHeader + "</tr>\n";
						}
						tableHeaderFound = true;
					}
				}
				htmlContent.append(
						"<tr><td colspan=" + (colSpanCount) + " bgcolor=#EEEEEE><b>" + command + "</b></td></tr>\n");
				htmlContent.append(tableHeader);
				rowIndex = 0;
				for (Map<String, JSONObject> map : dataList) {
					tableData = tableData + "<tr>\n";
					Map<String, String> rowcolor = rowColors.get(rowIndex);
					for (int j = 0; j < headList.size(); j++) {
						String value = "";
						String color = rowcolor.get(headList.get(j));

						if (map.containsKey(headList.get(j))) {
							value = map.get(headList.get(j)).get("text").toString().trim();
							// color = map.get(headList.get(j)).get("color").toString();
						}
						if (StringUtils.isNotEmpty(value) && value.contains("--More--")) {
							value = value.replaceAll("--More--", "");
						}

						if (StringUtils.isNotEmpty(color)) {
							tableData = tableData + "<td align=center bgcolor =" + color + " >" + value + "</td>\n";
						} else {
							tableData = tableData + "<td align=center>" + value + "</td>\n";
						}
					}
					tableData = tableData + "</tr>\n";
					rowIndex++;
				}
				if (StringUtils.isNotEmpty(tableData) && tableData.length() > 0 && headList.size() > 0) {
					htmlContent.append(tableData);
				} else {
					htmlContent.append("<tr>\n<td align=center bgcolor=FFFF00>NO DATA</td></tr>\n");
				}
				htmlContent.append("</table>");
			}
		} catch (Exception e) {
			logger.error("Exception RunTestServiceImpl in getXmlHtmlContent() " + ExceptionUtils.getFullStackTrace(e));
			e.printStackTrace();
			htmlContent.setLength(0);
			htmlContent.append(
					"<br><br><table cellspacing=0 cellpadding=5 border=1 bordercolor=#000000 style=\"min-width: 100%;table-layout: fixed;white-space: pre;\">\n");
			htmlContent.append("<tr><td  bgcolor=#EEEEEE><b>" + command + "</b></td></tr>\n");
			htmlContent.append("<tr>\n<td align=center bgcolor=FFFF00>NO DATA</td></tr>\n");
			htmlContent.append("</table>");

		}
		return htmlContent;
	}

	@Override
	public String generateScript5GAudit(JSONObject runTestParams) throws RctException {

		Map run = (Map) runTestParams.get("runTestFormDetails");
		List<Map> scriptSeqDetails = (List<Map>) run.get("scripts");
		List<Map> neList = (List<Map>) run.get("neDetails");
		List<LinkedHashMap> useCaseList = (List) run.get("useCase");
		int programId = (int) runTestParams.get("programId");
		int lsmId = (int) run.get("lsmId");
		boolean useCurrPassword = (boolean) run.get("currentPassword");
		String sanePassword = run.get("password").toString();
		String migType = runTestParams.get("migrationType").toString();
		String migSubType = runTestParams.get("migrationSubType").toString();
		String userName = runTestParams.get("userName").toString();
		String ciqFileName = run.get("ciqName").toString();
		String sProgramId = runTestParams.get("programId").toString();
		String lsmVersion = run.get("lsmVersion").toString();
		String lsmName = run.get("lsmName").toString();

		try {

			Map<Integer, Integer> usecaseIdAndSeqmap = new HashMap<>();
			Map<Integer, String> usecaseIdAndNamemap = new HashMap<>();

			ExecutorService executorservice = Executors.newFixedThreadPool(neList.size());

			for (Map neid : neList) {

				executorservice.submit(() -> {

					String migrationType = null;
					String migrationSubType = null;

					if (migType.equalsIgnoreCase(Constants.MIGRATION)) {
						migrationType = "Migration";
					} else if (migType.equalsIgnoreCase(Constants.POST_MIGRATION)) {
						migrationType = "PostMigration";
					}

					if ("precheck".equalsIgnoreCase(migSubType)) {
						migrationSubType = "PreCheck";
					} else if ("commission".equalsIgnoreCase(migSubType)) {
						migrationSubType = "Commission";
					} else if ("postcheck".equalsIgnoreCase(migSubType)) {
						migrationSubType = "PostCheck";
					} else if ("AUDIT".equalsIgnoreCase(migSubType)) {
						migrationSubType = "Audit";
					} else if ("RANATP".equalsIgnoreCase(migSubType)) {
						migrationSubType = "RanATP";
					}

					try {

						int useCaseBuilderId = 0;
						for (Map usecase : useCaseList) {
							useCaseBuilderId = Integer.valueOf(usecase.get("useCaseId").toString());
							Integer useCaseExeSeq = Integer.valueOf(usecase.get("executionSequence").toString());
							String uCName = (String) usecase.get("useCaseName");
							usecaseIdAndSeqmap.put(useCaseBuilderId, useCaseExeSeq);
							usecaseIdAndNamemap.put(useCaseBuilderId, uCName);
						}
						Map<Integer, Integer> usecaseSortedByExeSeqMap = usecaseIdAndSeqmap.entrySet().stream()
								.sorted(Map.Entry.comparingByValue()).collect(Collectors.toMap(Map.Entry::getKey,
										Map.Entry::getValue, (e1, e2) -> e1, LinkedHashMap::new));

						String neId = neid.get("neId").toString();
						String neName = neid.get("neName").toString();
						mainloop: for (Entry<Integer, Integer> h : usecaseSortedByExeSeqMap.entrySet()) {
							int useCaseId = h.getKey();
							String useCaseName = usecaseIdAndNamemap.get(useCaseId);
							String sLsmName = lsmName;
							// get script details by passin the usecse id
							List<UseCaseBuilderParamEntity> scriptDetails = runTestRepository
									.getScriptDetails(useCaseId);
							Map<Integer, Integer> scriptIdAndSeqmap = new HashMap<>();
							Map<Integer, Integer> useCaseScriptIdAnduploadedscriptIdmap = new HashMap<>();
							ArrayList scriptFinalLst = new ArrayList<ArrayList>();

							for (UseCaseBuilderParamEntity scriptInfo : scriptDetails) {
								List scriptLst = new ArrayList<>();
								Integer scriptId = scriptInfo.getScriptsDetails().getId();

								int scriptUiExeSeq = getScriptExeSeq(scriptSeqDetails, scriptId);

								Integer scriptExeSeq = scriptUiExeSeq;

								Integer uploadedscriptId = scriptInfo.getId();
								if (scriptExeSeq != 0) {

									scriptLst.add(scriptId);
									scriptLst.add(scriptExeSeq);
									scriptLst.add(uploadedscriptId);
									scriptFinalLst.add(scriptLst);
									scriptIdAndSeqmap.put(scriptId, scriptExeSeq);

								}

								useCaseScriptIdAnduploadedscriptIdmap.put(uploadedscriptId, scriptId);
							}

							Map<Integer, Integer> scriptSortedByExeSeqMap = scriptIdAndSeqmap.entrySet().stream()
									.sorted(Map.Entry.comparingByValue()).collect(Collectors.toMap(Map.Entry::getKey,
											Map.Entry::getValue, (e1, e2) -> e1, LinkedHashMap::new));

							for (Entry<Integer, Integer> i : scriptSortedByExeSeqMap.entrySet()) {
								String scriptName = null;
								String text;
								String scriptPath = null;
								useCaseName = usecaseIdAndNamemap.get(useCaseId);
								Integer scriptId = i.getKey();
								int scriptExeSeq = scriptSortedByExeSeqMap.get(scriptId);
								// get script path by passing the script id
								UploadFileEntity scriptEntity = runTestRepository.getScriptInfo(i.getKey());

								String dbcollectionFileName = CommonUtil
										.createMongoDbFileName(String.valueOf(programId), ciqFileName);
								String vznEnbIP = fileUploadRepository.getEnBDataByPath(dbcollectionFileName,
										Constants.VZ_GROW_IPPLAN, neId,
										Constants.ORAN_SPRINT_COMM_SCRIPT_eNB_OAM_IP_eNB_S_B_IP);
								String eNB_OAM_IP = fileUploadRepository.getEnBDataByPath(dbcollectionFileName,
										Constants.SPT_GROW_SHEET_FDD_TDD, neId,
										Constants.ORAN_SPRINT_COMM_SCRIPT_8_CHG_IP_ADDR);
								String enbIP = "127.0.0.1";

								String CSR_OAM_IP = fileUploadRepository.getEnBDataByPath(dbcollectionFileName,
										Constants.SPT_GROW_SHEET_FDD_TDD, neId,
										Constants.ORAN_SPRINT_COMM_SCRIPT_9_CSR_OAM_IP);

								NeMappingModel neMappingModel = new NeMappingModel();
								CustomerDetailsEntity programDetailsEntity = new CustomerDetailsEntity();
								programDetailsEntity.setId(programId);
								neMappingModel.setProgramDetailsEntity(programDetailsEntity);
								neMappingModel.setEnbId(neId);
								List<NeMappingEntity> neMappingEntities = neMappingService.getNeMapping(neMappingModel);

								String neType = "ENB";
								if (scriptEntity.getFileName().contains(Constants.PRECHECK_CSR_FILE_NAME)
										|| scriptEntity.getFileName().contains(Constants.POSTCHECK_CSR_FILE_NAME)) {
									enbIP = CommonUtil.getLeftSubStringWithLen(CSR_OAM_IP, 3);
									neType = "CSR";
								} else if (scriptEntity.getFileName().contains(Constants.PRECHECK_BSM_FILE_NAME)
										|| scriptEntity.getFileName().contains(Constants.POSTCHECK_BSM_FILE_NAME)) {
									enbIP = neMappingEntities.get(0).getBsmIp();
								}

								if (StringUtils.isNotEmpty(vznEnbIP)) {
									enbIP = vznEnbIP;
								} else if (StringUtils.isNotEmpty(eNB_OAM_IP)) {
									String sprintEnbIP = CommonUtil.getLeftSubStringWithLen(eNB_OAM_IP, 3);
									if (StringUtils.isNotEmpty(sprintEnbIP)) {
										enbIP = sprintEnbIP;
									} else {
										enbIP = eNB_OAM_IP;
									}
								}

								StringBuilder sourcePath = new StringBuilder();
								StringBuilder destPath = new StringBuilder();

								sourcePath = sourcePath
										.append(LoadPropertyFiles.getInstance().getProperty("BASE_PATH"));
								destPath = destPath.append(LoadPropertyFiles.getInstance().getProperty("BASE_PATH"));
								scriptName = scriptEntity.getFileName();
								scriptPath = scriptEntity.getFilePath();

								sourcePath.append(scriptPath).append(File.separator)
										.append(useCaseName.trim().replaceAll(" ", "_")).append(File.separator)
										.append(scriptName);

								destPath.append(Constants.CUSTOMER)
										.append(Constants.GENERATE_SCRIPT.replace("programId", sProgramId)
												.replace("migrationType", migrationType).replace("neId", neId)
												.replace("subType", migrationSubType));

								File folder = new File(destPath.toString());

								if (!folder.exists()) {
									FileUtil.createDirectory(destPath.toString());
								}

								String[] fileName = scriptName.split("\\.");
								String[] exactFileName = scriptName.split("\\.");
								String scriptAbsFileName = "";
								if (useCaseName.contains(Constants.COMMISION_USECASE)
										|| useCaseName.contains(Constants.RF_USECASE)) {
									scriptAbsFileName = LoadPropertyFiles.getInstance().getProperty("BASE_PATH")
											+ Constants.CUSTOMER + "/"
											+ Constants.UPLOAD_FILE_PATH_WITHOUT_VERSION
													.replace("programId", String.valueOf(programId))
													.replace("migrationType", migrationType)
													.replace("subType", scriptEntity.getSubType())
											+ (usecaseIdAndNamemap.get(useCaseId)).trim().replaceAll(" ", "_") + "/"
											+ scriptEntity.getFileName();
								} else {
									scriptAbsFileName = LoadPropertyFiles.getInstance().getProperty("BASE_PATH")
											+ scriptEntity.getFilePath() + "/" + useCaseName.trim().replaceAll(" ", "_")
											+ "/" + scriptEntity.getFileName();
								}

								String timeStamp = new SimpleDateFormat("MMddyyyy_HH_mm_ss")
										.format(new Timestamp(System.currentTimeMillis()));

								String convertFileName = LoadPropertyFiles.getInstance().getProperty("BASE_PATH")
										+ scriptEntity.getFilePath() + "/" + useCaseName.trim().replaceAll(" ", "_")
										+ "/" + StringUtils.substringBeforeLast(scriptEntity.getFileName(), ".") + "_"
										+ timeStamp + ".sh";

								ProgramTemplateEntity programTemplateEntity = fileUploadService
										.getProgramTemplate(programId, Constants.SCRIPT_STORE_TEMPLATE);

								if ("BatchFile".equalsIgnoreCase(scriptEntity.getScriptType()) && scriptEntity
										.getConnectionTerminal().equalsIgnoreCase(Constants.CLI_TERMINAL)) {

									String relVersion = runTestRepository.getNeRelVer(programId, lsmVersion);

									CommonUtil.createCliFromBatch(scriptAbsFileName, convertFileName, lsmVersion,
											relVersion, programTemplateEntity, ciqFileName, neId, neName);
									text = readFile(convertFileName);

								} else if ("BatchFile".equalsIgnoreCase(scriptEntity.getScriptType()) && scriptEntity
										.getConnectionTerminal().equalsIgnoreCase(Constants.CMD_SYS_TERMINAL)) {

									CommonUtil.createCmdSysFromBatch(scriptAbsFileName, convertFileName,
											programTemplateEntity, ciqFileName, neId, neName);

									text = readFile(convertFileName);

								} else if ("BatchFile".equalsIgnoreCase(scriptEntity.getScriptType()) && scriptEntity
										.getConnectionTerminal().equalsIgnoreCase(Constants.CONFDCLI_TERMINAL)) {

									CommonUtil.createConfdCliFromBatch(scriptAbsFileName, convertFileName,
											programTemplateEntity, ciqFileName, neId, neName);

									text = readFile(convertFileName);

								} else if ("VbsFile".equalsIgnoreCase(scriptEntity.getScriptType()) && scriptEntity
										.getConnectionTerminal().equalsIgnoreCase(Constants.BASH_TERMINAL)) {

									CommonUtil.createBashFromVbs(scriptAbsFileName, convertFileName,
											programTemplateEntity, ciqFileName, neId, neName);

									text = readFile(convertFileName);

								} else if ("VbsFile".equalsIgnoreCase(scriptEntity.getScriptType()) && scriptEntity
										.getConnectionTerminal().equalsIgnoreCase(Constants.CLI_TERMINAL)) {
									String relVersion = runTestRepository.getNeRelVer(programId, lsmVersion);
									CommonUtil.createCliFromVbs(scriptAbsFileName, convertFileName, lsmVersion,
											relVersion, programTemplateEntity, ciqFileName, neId, neName);

									text = readFile(convertFileName);

								} else if ("XML".equalsIgnoreCase(scriptEntity.getScriptType()) && (scriptEntity
										.getConnectionTerminal().equalsIgnoreCase(Constants.BASH_TERMINAL)
										|| scriptEntity.getConnectionTerminal()
												.equalsIgnoreCase(Constants.CURL_TERMINAL))) {

									String mcmip = "";
									NeMappingEntity neMappingEntity = neMappingEntities.get(0);

									if (CommonUtil.isValidObject(neMappingEntity.getNetworkConfigEntity())
											&& CommonUtil.isValidObject(
													neMappingEntity.getNetworkConfigEntity().getNeTypeEntity())
											&& neMappingEntity.getNetworkConfigEntity().getNeTypeEntity()
													.getId() == Constants.NW_CONFIG_VLSM_ID
											&& CommonUtil.isValidObject(
													neMappingEntity.getNetworkConfigEntity().getNeDetails())) {
										for (NetworkConfigDetailsEntity detailsEntity : neMappingEntity
												.getNetworkConfigEntity().getNeDetails()) {
											if (CommonUtil.isValidObject(detailsEntity.getServerTypeEntity())) {
												if (detailsEntity.getServerTypeEntity()
														.getId() == Constants.NW_CONFIG_VLSM_MCMA_ID
														&& CommonUtil.isValidObject(detailsEntity.getServerIp())
														&& detailsEntity.getServerIp().length() > 0) {
													mcmip = detailsEntity.getServerIp();
													break;
												}
											}
										}
									}
									if (CommonUtil.isValidObject(neMappingEntity.getNetworkConfigEntity())
											&& CommonUtil.isValidObject(
													neMappingEntity.getNetworkConfigEntity().getNeTypeEntity())
											&& neMappingEntity.getNetworkConfigEntity().getNeTypeEntity()
													.getId() == Constants.NW_CONFIG_USM_ID) {
										mcmip = neMappingEntity.getNetworkConfigEntity().getNeIp();
									}

									/*
									 * CommonUtil.createBashFromXml(scriptAbsFileName, convertFileName, mcmip,
									 * neId);
									 * 
									 * text = readFile(convertFileName);
									 */

									String endName = "";
									if (StringUtils.isNotEmpty(scriptEntity.getFileName())) {
										endName = scriptEntity.getFileName().substring(0,
												scriptEntity.getFileName().indexOf('_'));
									}
									if ("ACPF".equalsIgnoreCase(endName) || "AUPF".equalsIgnoreCase(endName)
											|| "AU".equalsIgnoreCase(endName) || "DU".equalsIgnoreCase(endName)
											|| "DSS".equalsIgnoreCase(endName) || "CBand".equalsIgnoreCase(endName)) {
										dbcollectionFileName = CommonUtil.createMongoDbFileName(sProgramId,
												ciqFileName);
										List<CIQDetailsModel> listCIQDetailsModel = getCIQDetailsModelList(neId,
												dbcollectionFileName);
										String gnbId = "";
										if (!ObjectUtils.isEmpty(listCIQDetailsModel))

										{
											CIQDetailsModel ciqDetailsModel = listCIQDetailsModel.get(0);

											LinkedHashMap<String, CiqMapValuesModel> objMapDetails = ciqDetailsModel
													.getCiqMap();

											if ("ACPF".equalsIgnoreCase(endName) && !ObjectUtils.isEmpty(objMapDetails)
													&& objMapDetails.containsKey("NE_ID ACPF")) {

												gnbId = objMapDetails.get("NE_ID ACPF").getHeaderValue();

												if (StringUtils.isNotEmpty(gnbId) && gnbId.length() >= 4) {
													gnbId = gnbId.trim();
													gnbId = gnbId.substring(gnbId.length() - 4);
													gnbId = gnbId.replaceAll("^0+(?!$)", "");

												}

											} else if ("AUPF".equalsIgnoreCase(endName)
													&& !ObjectUtils.isEmpty(objMapDetails)
													&& objMapDetails.containsKey("NE_ID_AUPF")) {

												gnbId = objMapDetails.get("NE_ID_AUPF").getHeaderValue();

												if (StringUtils.isNotEmpty(gnbId) && gnbId.length() >= 4) {
													gnbId = gnbId.trim();
													gnbId = gnbId.substring(gnbId.length() - 4);
													gnbId = gnbId.replaceAll("^0+(?!$)", "");

												}

											} else if (("AU".equalsIgnoreCase(endName)
													|| "DU".equalsIgnoreCase(endName))
													&& !ObjectUtils.isEmpty(objMapDetails)
													&& objMapDetails.containsKey("NE ID AU")) {

												endName = "DU";
												gnbId = objMapDetails.get("NE ID AU").getHeaderValue();
												if (StringUtils.isNotEmpty(gnbId)) {
													gnbId = gnbId.trim();
													gnbId = gnbId.replaceAll("^0+(?!$)", "");
												}

											} else if ("DSS".equalsIgnoreCase(endName)
													&& !ObjectUtils.isEmpty(objMapDetails)) {

												if (scriptEntity.getFileName().contains("ACPF")
														&& objMapDetails.containsKey("gNBID")) {
													endName = "ACPF";
													gnbId = objMapDetails.get("gNBID").getHeaderValue();
													if (StringUtils.isNotEmpty(gnbId) && gnbId.length() >= 4) {
														gnbId = gnbId.trim();
														gnbId = gnbId.substring(gnbId.length() - 4);
														gnbId = gnbId.replaceAll("^0+(?!$)", "");

													}
												} else if (scriptEntity.getFileName().contains("AUPF")
														&& objMapDetails.containsKey("gNBID")) {
													endName = "AUPF";
													gnbId = objMapDetails.get("gNBID").getHeaderValue();
													if (StringUtils.isNotEmpty(gnbId) && gnbId.length() >= 4) {
														gnbId = gnbId.trim();
														gnbId = gnbId.substring(gnbId.length() - 4);
														gnbId = gnbId.replaceAll("^0+(?!$)", "");

													}
												} else if (scriptEntity.getFileName().contains("vDU")
														&& objMapDetails.containsKey("NEID")) {
													endName = "ADPF";
													gnbId = objMapDetails.get("NEID").getHeaderValue()
															.replaceAll("^0+(?!$)", "");
												} else if (scriptEntity.getFileName().contains("eNB")
														&& objMapDetails.containsKey("4GeNB")) {
													endName = "eNB";
													gnbId = objMapDetails.get("4GeNB").getHeaderValue()
															.replaceAll("^0+(?!$)", "");
												} else if (scriptEntity.getFileName().contains("FSU")
														&& objMapDetails.containsKey("NEID")) {
													endName = "FSU";
													List<CIQDetailsModel> listCIQsheetDetailsModel = fileUploadRepository
															.getEnbTableSheetDetailss(ciqFileName,
																	"DSS_MOP_Parameters-1",
																	objMapDetails.get("NEID").getHeaderValue(),
																	dbcollectionFileName);
													if (!ObjectUtils.isEmpty(listCIQsheetDetailsModel)) {
														CIQDetailsModel ciqsheetDetailsModel = listCIQsheetDetailsModel
																.get(0);
														if (ciqsheetDetailsModel.getCiqMap().containsKey("FSUID")) {
															gnbId = ciqsheetDetailsModel.getCiqMap().get("FSUID")
																	.getHeaderValue().replaceAll("^0+(?!$)", "");
														}
													}
												}

											} else if ("CBand".equalsIgnoreCase(endName)
													&& !ObjectUtils.isEmpty(objMapDetails)) {
												if (scriptEntity.getFileName().contains("vDU")
														&& objMapDetails.containsKey("NEID")) {
													endName = "ADPF";
													gnbId = objMapDetails.get("NEID").getHeaderValue()
															.replaceAll("^0+(?!$)", "");
												}
											}

										}
										CommonUtil.createBashFromXml5GAudit(scriptAbsFileName, convertFileName, mcmip,
												gnbId, endName);

									} else if ("eNB".equalsIgnoreCase(endName)) {
										dbcollectionFileName = CommonUtil.createMongoDbFileName(sProgramId,
												ciqFileName);
										LinkedHashSet<String> siteIds = getEnbsiteIds(neId, ciqFileName,
												dbcollectionFileName);
										NetworkConfigEntity networkConfigEntity = runTestRepository.getNeType(lsmId);
										StringBuilder endSb = buildConnectionEndScript(networkConfigEntity,
												scriptEntity, programId, neType, useCaseName);
										String expectPrompt = getPromtbetweenCurlCommans(endSb);
										CommonUtil.createBashFromXml5GAuditEnbSites(scriptAbsFileName, convertFileName,
												mcmip, neId, endName, siteIds, expectPrompt);

									}
									text = readFile(convertFileName);

								} else if ("py".equalsIgnoreCase(fileName[1]) || "perl".equalsIgnoreCase(fileName[1])
										|| "pl".equalsIgnoreCase(fileName[1])) {

									text = readFile(scriptAbsFileName);
								} else if (useCaseName.contains(Constants.COMMISION_USECASE)
										|| useCaseName.contains(Constants.RF_USECASE)
										|| useCaseName.contains(Constants.GROWCELLUSECASE)
										|| useCaseName.contains(Constants.GROWENBUSECASE)
										|| useCaseName.contains(Constants.PNPUSECASE)
										|| useCaseName.contains("AUCaCell") || useCaseName.contains("AU20B")
										|| useCaseName.contains("AU20A") || useCaseName.contains("pnp20BUsecase")
										|| useCaseName.contains("pnp20AUsecase") || useCaseName.contains("AU20C")
										|| useCaseName.contains("pnp20CUsecase")) {
									text = readFile(scriptAbsFileName);
								} else {
									CommonUtil.createExpect(scriptAbsFileName, convertFileName, scriptEntity, neId,
											neName);
									text = readFile(convertFileName);

								}

								if (sLsmName.contains("_")) {
									sLsmName = charRemoveAt(sLsmName);
								}

								if (useCaseName.contains("_")) {
									useCaseName = charRemoveAt(useCaseName);
								}

								if (fileName[0].contains("_")) {
									fileName[0] = charRemoveAt(fileName[0]);
								}

								sLsmName = sLsmName.replaceAll("\\s", "");
								useCaseName = useCaseName.replaceAll("\\s", "");
								fileName[0] = fileName[0].replaceAll("\\s", "_");

								String descFileName = scriptExeSeq + "_" + sLsmName + "_" + useCaseName + "_"
										+ useCaseId + "_" + fileName[0] + "_" + scriptId + "." + fileName[1];
								String descFinalPath = destPath.toString() + "/" + descFileName;

								if ("py".equalsIgnoreCase(fileName[1]) || "perl".equalsIgnoreCase(fileName[1])) {

									File file = new File(descFinalPath);
									if (!file.exists()) {
										file.createNewFile();
									}
									FileWriter fw = new FileWriter(descFinalPath);
									fw.write(text);
									fw.close();

								} else {

									descFileName = scriptExeSeq + "_" + sLsmName + "_" + useCaseName + "_" + useCaseId
											+ "_" + fileName[0] + "_" + scriptId + "." + "sh";
									descFinalPath = destPath.toString() + "/" + descFileName;
									String descFileNames = scriptExeSeq + "_" + sLsmName + "_" + useCaseName + "_"
											+ useCaseId + "_" + exactFileName[0] + "_" + scriptId + "." + "xml";
									String descFinalPaths = destPath.toString() + "/" + descFileNames;

									writefile(text, lsmId, useCurrPassword, enbIP, descFinalPath, sanePassword,
											userName, scriptEntity, useCaseName, neId, programId, neName, neType,
											descFinalPaths, false);

									String endName = "";
									if (StringUtils.isNotEmpty(scriptEntity.getFileName())) {
										endName = scriptEntity.getFileName().substring(0,
												scriptEntity.getFileName().indexOf('_'));
									}

									if ("eNB".equalsIgnoreCase(endName)) {
										try {
											dbcollectionFileName = CommonUtil.createMongoDbFileName(sProgramId,
													ciqFileName);
											LinkedHashSet<String> siteIds = getEnbsiteIds(neId, ciqFileName,
													dbcollectionFileName);
											String dataDetails = readFile(descFinalPath);
											char ch = '"';
											if (!ObjectUtils.isEmpty(siteIds) && StringUtils.isNotEmpty(dataDetails)
													&& dataDetails.contains("send " + ch + "curl")) {
												List<String> curlComandsInput = getAllCurlCommands(dataDetails);

												String startConnection = dataDetails.substring(0,
														dataDetails.indexOf("send " + ch + "curl"));
												NetworkConfigEntity networkConfigEntity = runTestRepository
														.getNeType(lsmId);
												StringBuilder endSb = buildConnectionEndScript(networkConfigEntity,
														scriptEntity, programId, neType, useCaseName);
												StringBuilder endConnection = buildConnectionEndScript(
														networkConfigEntity, scriptEntity, programId, neType,
														useCaseName);
												StringBuilder shellOutput5g = new StringBuilder();

												for (String siteId : siteIds) {

													String curlCommand = getCurlCommandWithSiteId(siteId,
															curlComandsInput);

													StringBuilder shCommand = new StringBuilder();
													shCommand.append(startConnection);
													shCommand.append("\n\n");
													shCommand.append(curlCommand);
													shCommand.append("\n\n");
													shCommand.append(endConnection);

													String enbSpecificFile = descFinalPath.replaceAll(descFileName, "");
													enbSpecificFile = enbSpecificFile + Constants.SEPARATOR
															+ "EnbSites";

													File enbFolder = new File(enbSpecificFile.toString());

													if (!enbFolder.exists()) {
														FileUtil.createDirectory(enbSpecificFile.toString());
													}

													String enbSite = "eNB_" + siteId + "_" + descFileName;
													enbSpecificFile = enbSpecificFile + Constants.SEPARATOR + enbSite;

													File fileWithNameExist = new File(enbSpecificFile);

													if (fileWithNameExist.exists()) {
														fileWithNameExist.delete();
													}
													writeEnbFilles(enbSpecificFile, shCommand.toString());

												}

											}

										} catch (Exception e) {
											e.printStackTrace();
										}

									}

								}
							}
						}

					} catch (Exception e) {
						logger.error("Exception RunTestServiceImpl in generateScript() "
								+ ExceptionUtils.getFullStackTrace(e));
					}
					logger.error("Completed the Thread at " + LocalTime.now());
					return Constants.SUCCESS;

				});
			}
			executorservice.shutdown();
		} catch (Exception e) {
			logger.error(
					"Exception RunTestServiceImpl in getRuntestExecResult() " + ExceptionUtils.getFullStackTrace(e));

			return e.getMessage();
		}
		return Constants.SUCCESS;
	}

	public String getPromtbetweenCurlCommans(StringBuilder dataDetails) {
		String expectPrompt = "";
		try {
			String[] lines = dataDetails.toString().split("\\n");
			for (String prompt : lines) {

				if (StringUtils.isNotEmpty(prompt) && prompt.contains("expect")) {
					expectPrompt = prompt;
					break;
				}
			}

		} catch (Exception e) {
			logger.error("Exception RunTestServiceImpl in getPromtbetweenCurlCommans() "
					+ ExceptionUtils.getFullStackTrace(e));
		}

		return expectPrompt;

	}

	private void writeEnbFilles(String exeFileName, String data) {

		try {
			File file = new File(exeFileName);
			if (!file.exists()) {
				file.createNewFile();

			}

			OutputStream os = new FileOutputStream(file);

			os.write(data.getBytes(), 0, data.length());

			Runtime.getRuntime().exec("chmod -R 777 " + exeFileName);

			os.close();
		} catch (Exception e) {
			logger.error("Exception RunTestServiceImpl in writeEnbFilles() " + ExceptionUtils.getFullStackTrace(e));
		}

	}

	public String xmlParsing5GAudit(XmlRuleBuilderEntity xmlRule, String data1, int xmlRuleOccurence, String neName,
			String enbId, String dbcollectionFileName) {

		String rootName = xmlRule.getRootName();
		String subRootName = xmlRule.getSubRootName();
		String loopType = xmlRule.getLoopType();
		String cmdResult = xmlRule.getStatus();

		String result = NO_DATA;
		String finalResult = "NO";
		String outputResult = NO_DATA;

		JSONObject noRuleResultJson = new JSONObject();
		JSONObject yesRuleResultJson = new JSONObject();
		JSONObject resultJson = new JSONObject();
		JSONObject jsonResult = new JSONObject();

		Set<XmlRootEntity> xmlRootEntityset = xmlRule.getXmlRootEntitySet();

		Set<XmlElementEntity> xmlElementEntityset = xmlRule.getXmlElementEntitySet();

		try {
			LinkedHashMap<String, String> noStatusMap = new LinkedHashMap<>();
			String data = "";

			/*
			 * data1 = new
			 * String(Files.readAllBytes(Paths.get("/home/bala/Desktop/audit5GResponse")));
			 */

			data = data1;
			String finalOutput = requiredXmlOutput5GAudit(xmlRule, data, xmlRuleOccurence, neName, enbId);

			List<String> rootArray = new ArrayList<>();

			while (finalOutput.length() > 0) {
				int stIndex = finalOutput.indexOf("<" + rootName + "");
				// Swetha added below condition
				if (rootName.contains(" ")) {
					rootName = StringUtils.substringBefore(rootName, " ");
					rootName = rootName.trim();
				}
				int endIndex = finalOutput.indexOf("</" + rootName + ">");
				if (stIndex != -1) {
					String subdata = finalOutput.substring(stIndex, endIndex + rootName.length() + 3);
					finalOutput = finalOutput.substring(endIndex + rootName.length() + 3);
					rootArray.add(subdata);

				} else {
					break;
				}
			}

			int yesCount = 0;
			int loyesCount = 0;
			List noRowLst = new ArrayList<>();
			List yesRowLst = new ArrayList<>();
			List<String> subRootDetailsArray = null;

			mainloop: for (int row = 0; row < rootArray.size(); row++) {

				Map noCol = null;
				Map yesCol = null;

				String rootData = rootArray.get(row);

				String subdata = rootData;
				List<String> subRootArray = new ArrayList<>();
				subRootDetailsArray = new ArrayList<>();

				if (!subRootName.isEmpty()) {
					while (subdata.length() > 0) {
						int stIndex = subdata.indexOf("<" + subRootName + ">");
						int endIndex = subdata.indexOf("</" + subRootName + ">");
						if (stIndex != -1) {
							String rootDetailData = subdata.substring(stIndex, endIndex + subRootName.length() + 3);
							subdata = subdata.substring(endIndex + subRootName.length() + 3);
							subRootArray.add(rootDetailData);

						} else {
							break;
						}
					}

					for (String subRootData : subRootArray) {

						int noOfCOndition = 0;
						for (XmlRootEntity xmlRootEntity : xmlRootEntityset) {

							String rootKeyValue = xmlRootEntity.getRootKey() + "=" + "\"" + xmlRootEntity.getRootValue()
									+ "\"";

							if (subRootData.contains(rootKeyValue)) {

								noOfCOndition++;

								if (xmlRootEntityset.size() == noOfCOndition) {

									subRootDetailsArray.add(subRootData);

								}
							}
						}
					}

					if (!xmlRootEntityset.isEmpty() && subRootDetailsArray.isEmpty()) {
						finalResult = NO_DATA;
						break mainloop;
					}

					if (subRootDetailsArray.isEmpty()) {
						subRootDetailsArray = subRootArray;

					}

					for (int lorow = 0; lorow < subRootDetailsArray.size(); lorow++) {

						Map lonoCol = null;
						Map loyesCol = null;
						String elementData = subRootDetailsArray.get(lorow);

						for (XmlElementEntity xmlElementEntity : xmlElementEntityset) {

							lonoCol = new HashMap<>();
							loyesCol = new HashMap<>();

							List yesColIndex = new ArrayList<>();
							List noColIndex = new ArrayList<>();

							String elementName = xmlElementEntity.getElementName();
							String elementValue = xmlElementEntity.getElementValue();
							String operator = xmlElementEntity.getOperator();

							String[] lines = elementData.split("\\r?\\n");
							int noOfCol = lines.length;
							for (int col = 0; col < lines.length; col++) {
								String colLine = lines[col];

								if (colLine.contains(elementName) || ("curl".equalsIgnoreCase(elementName) && "CONTAINS"
										.equalsIgnoreCase(operator))/* && colLine.contains(elementValue) */) {

									noOfCol--;
									switch (operator) {

									case "==":
										result = checkXmlEquals(elementName, Integer.valueOf(elementValue), colLine);
										if ("NO".equals(result)) {

											noColIndex.add(elementName);
											lonoCol.put("index", lorow);
											lonoCol.put("columnNames", noColIndex);

										} else if ("YES".equals(result)) {
											yesColIndex.add(elementName);
											loyesCol.put("index", lorow);
											loyesCol.put("columnNames", yesColIndex);
										}
										break;

									case "!=":
										result = checkXmlNotEquals(elementName, Integer.valueOf(elementValue), colLine);
										if ("NO".equals(result)) {

											noColIndex.add(elementName);
											lonoCol.put("index", lorow);
											lonoCol.put("columnNames", noColIndex);

										} else if ("YES".equals(result)) {
											yesColIndex.add(elementName);
											loyesCol.put("index", lorow);
											loyesCol.put("columnNames", yesColIndex);
										}
										break;

									case "<":
										result = checkXmlLessThan(elementName, Integer.valueOf(elementValue), colLine);
										if ("NO".equals(result)) {

											noColIndex.add(elementName);
											lonoCol.put("index", lorow);
											lonoCol.put("columnNames", noColIndex);

										} else if ("YES".equals(result)) {
											yesColIndex.add(elementName);
											loyesCol.put("index", lorow);
											loyesCol.put("columnNames", yesColIndex);
										}
										break;

									case "<=":
										result = checkXmlLessThanEql(elementName, Integer.valueOf(elementValue),
												colLine);
										if ("NO".equals(result)) {

											noColIndex.add(elementName);
											lonoCol.put("index", lorow);
											lonoCol.put("columnNames", noColIndex);

										} else if ("YES".equals(result)) {
											yesColIndex.add(elementName);
											loyesCol.put("index", lorow);
											loyesCol.put("columnNames", yesColIndex);
										}
										break;

									case ">":
										result = checkXmlGreaterThan(elementName, Integer.valueOf(elementValue),
												colLine);
										if ("NO".equals(result)) {

											noColIndex.add(elementName);
											lonoCol.put("index", lorow);
											lonoCol.put("columnNames", noColIndex);

										} else if ("YES".equals(result)) {
											yesColIndex.add(elementName);
											loyesCol.put("index", lorow);
											loyesCol.put("columnNames", yesColIndex);
										}
										break;

									case ">=":
										result = checkXmlGreaterThanEql(elementName, Integer.valueOf(elementValue),
												colLine);
										if ("NO".equals(result)) {

											noColIndex.add(elementName);
											lonoCol.put("index", lorow);
											lonoCol.put("columnNames", noColIndex);

										} else if ("YES".equals(result)) {
											yesColIndex.add(elementName);
											loyesCol.put("index", lorow);
											loyesCol.put("columnNames", yesColIndex);
										}
										break;

									case "CONTAINS":
										if ("curl".equalsIgnoreCase(elementName)) {
											result = checkCurlXmlContains(elementName, elementValue, colLine);
										} else {
											result = checkXmlContains(elementName, elementValue, colLine);
										}

										if ("NO".equals(result)) {

											noColIndex.add(elementName);
											lonoCol.put("index", lorow);
											lonoCol.put("columnNames", noColIndex);
											noStatusMap.put(elementName, result);

										} else if ("YES".equals(result)) {
											yesColIndex.add(elementName);
											loyesCol.put("index", lorow);
											loyesCol.put("columnNames", yesColIndex);
										}
										break;

									case "ANY":
										result = checkXmlAny(elementName, elementValue, colLine);
										if ("NO".equals(result)) {

											noColIndex.add(elementName);
											lonoCol.put("index", lorow);
											lonoCol.put("columnNames", noColIndex);

										} else if ("YES".equals(result)) {
											yesColIndex.add(elementName);
											loyesCol.put("index", lorow);
											loyesCol.put("columnNames", yesColIndex);
										}
										break;

									case "TEMPLATE":
										result = checkDependentRule(elementName, elementValue, colLine,
												dbcollectionFileName, enbId);
										if ("NO".equals(result)) {

											noColIndex.add(elementName);
											lonoCol.put("index", lorow);
											lonoCol.put("columnNames", noColIndex);

										} else if ("YES".equals(result)) {
											yesColIndex.add(elementName);
											loyesCol.put("index", lorow);
											loyesCol.put("columnNames", yesColIndex);
										}
										break;
									}

								}

								if ((elementName.isEmpty() || elementName.contains(" "))
										&& colLine.contains(elementValue)) {
									result = "YES";
								}
							}
							if (noOfCol == lines.length) {

								noColIndex.add(elementName);
								lonoCol.put("index", lorow);
								lonoCol.put("columnNames", noColIndex);
							}
							if (!lonoCol.isEmpty()) {
								noRowLst.add(lonoCol);
								noRuleResultJson.put("rows", noRowLst);
							}
							if (!loyesCol.isEmpty()) {
								yesRowLst.add(loyesCol);
								yesRuleResultJson.put("rows", yesRowLst);
							}
						}

						if ("YES".equalsIgnoreCase(result)) {
							loyesCount++;
						}

						if ("YES".equalsIgnoreCase(result) && "atleastone".equalsIgnoreCase(loopType)) {
							finalResult = "YES";
							if (lonoCol != null && !lonoCol.isEmpty()) {
								noRowLst.add(lonoCol);
								noRuleResultJson.put("rows", noRowLst);
							}

							if (loyesCol != null && !loyesCol.isEmpty()) {
								yesRowLst.add(loyesCol);
								yesRuleResultJson.put("rows", yesRowLst);
							}
							break mainloop;
						}
						if ("all".equalsIgnoreCase(loopType) && "NO".equalsIgnoreCase(result)) {
							finalResult = "NO";
						}

					}
				} else {

					String elementData = subdata;

					for (XmlElementEntity xmlElementEntity : xmlElementEntityset) {

						noCol = new HashMap<>();
						yesCol = new HashMap<>();

						List yesColIndex = new ArrayList<>();
						List noColIndex = new ArrayList<>();

						String elementName = xmlElementEntity.getElementName();
						String elementValue = xmlElementEntity.getElementValue();
						String operator = xmlElementEntity.getOperator();

						String[] lines = elementData.replaceAll("\\t", "").split("\\r?\\n");

						int noOfCol = lines.length;
						for (int col = 0; col < lines.length; col++) {
							String colLine = lines[col];
							if (colLine.contains(elementName) || ("curl".equalsIgnoreCase(elementName)
									&& "CONTAINS".equalsIgnoreCase(operator))/* && colLine.contains(elementValue) */) {

								switch (operator) {

								case "==":
									result = checkXmlEquals(elementName, Integer.valueOf(elementValue), colLine);
									if ("NO".equals(result)) {

										noColIndex.add(elementName);
										noCol.put("index", row);
										noCol.put("columnNames", noColIndex);

									} else if ("YES".equals(result)) {
										yesColIndex.add(elementName);
										yesCol.put("index", row);
										yesCol.put("columnNames", yesColIndex);
									}
									break;

								case "!=":
									result = checkXmlNotEquals(elementName, Integer.valueOf(elementValue), colLine);
									if ("NO".equals(result)) {

										noColIndex.add(elementName);
										noCol.put("index", row);
										noCol.put("columnNames", noColIndex);

									} else if ("YES".equals(result)) {
										yesColIndex.add(elementName);
										yesCol.put("index", row);
										yesCol.put("columnNames", yesColIndex);
									}
									break;

								case "<":
									result = checkXmlLessThan(elementName, Integer.valueOf(elementValue), colLine);
									if ("NO".equals(result)) {

										noColIndex.add(elementName);
										noCol.put("index", row);
										noCol.put("columnNames", noColIndex);

									} else if ("YES".equals(result)) {
										yesColIndex.add(elementName);
										yesCol.put("index", row);
										yesCol.put("columnNames", yesColIndex);
									}
									break;

								case "<=":
									result = checkXmlLessThanEql(elementName, Integer.valueOf(elementValue), colLine);
									if ("NO".equals(result)) {

										noColIndex.add(elementName);
										noCol.put("index", row);
										noCol.put("columnNames", noColIndex);

									} else if ("YES".equals(result)) {
										yesColIndex.add(elementName);
										yesCol.put("index", row);
										yesCol.put("columnNames", yesColIndex);
									}
									break;

								case ">":
									result = checkXmlGreaterThan(elementName, Integer.valueOf(elementValue), colLine);
									if ("NO".equals(result)) {

										noColIndex.add(elementName);
										noCol.put("index", row);
										noCol.put("columnNames", noColIndex);

									} else if ("YES".equals(result)) {
										yesColIndex.add(elementName);
										yesCol.put("index", row);
										yesCol.put("columnNames", yesColIndex);
									}
									break;

								case ">=":
									result = checkXmlGreaterThanEql(elementName, Integer.valueOf(elementValue),
											colLine);
									if ("NO".equals(result)) {

										noColIndex.add(elementName);
										noCol.put("index", row);
										noCol.put("columnNames", noColIndex);

									} else if ("YES".equals(result)) {
										yesColIndex.add(elementName);
										yesCol.put("index", row);
										yesCol.put("columnNames", yesColIndex);
									}

									break;

								case "CONTAINS":

									if ("curl".equalsIgnoreCase(elementName)) {
										result = checkCurlXmlContains(elementName, elementValue, colLine);
									} else {
										result = checkXmlContains(elementName, elementValue, colLine);
									}

									if ("NO".equals(result)) {

										noColIndex.add(elementName);
										noCol.put("index", row);
										noCol.put("columnNames", noColIndex);
										noStatusMap.put(elementName, result);

									} else if ("YES".equals(result)) {
										yesColIndex.add(elementName);
										yesCol.put("index", row);
										yesCol.put("columnNames", yesColIndex);
										// Swetha added below condition
										if ("atleastone".equalsIgnoreCase(loopType)) {
											break;
										}
									}

									break;

								case "ANY":
									result = checkXmlAny(elementName, elementValue, colLine);
									if ("NO".equals(result)) {

										noColIndex.add(elementName);
										noCol.put("index", row);
										noCol.put("columnNames", noColIndex);
										noStatusMap.put(elementName, result);

									} else if ("YES".equals(result)) {
										yesColIndex.add(elementName);
										yesCol.put("index", row);
										yesCol.put("columnNames", yesColIndex);
										// Swetha added below condition
										if ("atleastone".equalsIgnoreCase(loopType)) {
											break;
										}

									}
									break;
								case "TEMPLATE":
									result = checkDependentRule(elementName, elementValue, colLine,
											dbcollectionFileName, enbId);
									if ("NO".equals(result)) {

										noColIndex.add(elementName);
										noCol.put("index", row);
										noCol.put("columnNames", noColIndex);

									} else if ("YES".equals(result)) {
										yesColIndex.add(elementName);
										yesCol.put("index", row);
										yesCol.put("columnNames", yesColIndex);
										// bala added below condition
										if ("atleastone".equalsIgnoreCase(loopType)) {
											break;
										}
									}
									break;
								}

							}
							// Swetha added below condition
							if ("YES".equals(result) && "atleastone".equalsIgnoreCase(loopType)) {
								break;
							}

							if ((elementName.isEmpty() || elementName.contains(" "))
									&& colLine.contains(elementValue)) {
								result = "YES";
							}
						}
						if (noOfCol == lines.length) {

							noColIndex.add(elementName);
							noCol.put("index", row);
							noCol.put("columnNames", noColIndex);
						}

						if (!noCol.isEmpty()) {
							noRowLst.add(noCol);
							noRuleResultJson.put("rows", noRowLst);
						}
						if (!yesCol.isEmpty()) {
							yesRowLst.add(yesCol);
							yesRuleResultJson.put("rows", yesRowLst);
						}
					}

				}

				if (subRootDetailsArray.isEmpty()) {
					if ("YES".equalsIgnoreCase(result)) {
						yesCount++;
					}

					if ("YES".equalsIgnoreCase(result) && "atleastone".equalsIgnoreCase(loopType)) {
						finalResult = "YES";
						if (noCol != null && !noCol.isEmpty()) {
							noRowLst.add(noCol);
							noRuleResultJson.put("rows", noRowLst);
						}

						if (yesCol != null && !yesCol.isEmpty()) {
							yesRowLst.add(yesCol);
							yesRuleResultJson.put("rows", yesRowLst);
						}
						break mainloop;
					}
					if ("all".equalsIgnoreCase(loopType) && "NO".equalsIgnoreCase(result)) {
						finalResult = "NO";
					}

				}
			}

			if (subRootDetailsArray == null) {
				finalResult = NO_DATA;
			} else {
				if (subRootDetailsArray.isEmpty()) {
					if (rootArray.size() == yesCount) {
						finalResult = "YES";
					}
				} else if (!subRootDetailsArray.isEmpty()) {
					if (subRootDetailsArray.size() == loyesCount) {
						finalResult = "YES";
					}
				}
			}
			if (noStatusMap.size() > 0 && "all".equalsIgnoreCase(loopType)) {
				finalResult = "NO";
			}
			outputResult = getPassFail(cmdResult, finalResult);

			resultJson = getResultJson(cmdResult, outputResult, noRuleResultJson, yesRuleResultJson);
			jsonResult.put("outputResult", outputResult);
			jsonResult.put("ruleResultJson", resultJson);

		} catch (Exception e) {
			logger.error("Exception xmlParsing() in RunTestServiceImpl :" + ExceptionUtils.getFullStackTrace(e));
		}

		return jsonResult.toString();
	}

	private String requiredXmlOutput5GAudit(XmlRuleBuilderEntity xmlRule, String output, int cmdSequence, String neName,
			String enbId) {
		String finalOutput = "";
		try {
			StringBuilder objBuilder = new StringBuilder();
			if (StringUtils.isNotEmpty(output) && output.contains(xmlRule.getCmdName())
					&& output.contains(XmlCommandsConstants.ENDTEXT5G)) {
				String outputLog = StringUtils.substringAfter(output, xmlRule.getCmdName());
				outputLog = StringUtils.substringBefore(outputLog, XmlCommandsConstants.ENDTEXT5G);
				objBuilder.append(outputLog);
			}

			finalOutput = objBuilder.toString();

		} catch (Exception e) {
			logger.info("Exception in requiredXmlOutput() in RunTestServiceImpl" + ExceptionUtils.getFullStackTrace(e));
		}
		return finalOutput;
	}

	@Override
	public List getMessageInfo(List<RunTestResultEntity> runTestResultEntityList) {
		List fileRuleList = new ArrayList<>();
		try {

			for (RunTestResultEntity entity : runTestResultEntityList) {
				Map scripInfo = new HashMap<>();
				String scName = null;
				String currentOutputLoc = null;
				StringBuilder sb = new StringBuilder();
				StringBuilder shellOutputBefore = new StringBuilder();
				String shellOutputAfter = null;
				String shellOutput = null;
				String shellOutputBef = null;
				String scriptName = null;
				if (entity.getUploadFileEntity().getFileName().contains(".")) {
					String[] name = entity.getUploadFileEntity().getFileName().split("\\.");
					scriptName = name[0];
				}
				currentOutputLoc = LoadPropertyFiles.getInstance().getProperty("BASE_PATH")
						+ entity.getCurrentScriptOutput();
				scName = charRemoveAt(scriptName);
				File file = new File(currentOutputLoc);
				File[] listOfFiles = file.listFiles();
				for (int i = 0; i < listOfFiles.length; i++) {
					String ch = listOfFiles[i].toString();
					if (ch.contains(scName)) {
						BufferedReader bf = new BufferedReader(new FileReader(ch));
						String line = "";
						while ((line = bf.readLine()) != null) {
							sb.append(line).append("\n");
						}
					}
				}
				shellOutput = sb.toString();
				if (shellOutput.contains("Message from SRCT : SSH Timeout")) {
					scripInfo.put("scriptName", scriptName);
					scripInfo.put("scriptOutput",
							"Please check the running logs / Download Logs.\nPlease Rerun if required.");
					scripInfo.put("saneIssue", "SSH Timeout Occured (" + Constants.SSH_TIMEOUT / 60 + " minute)");
				} else if (shellOutput.contains("DUO ERROR:")) {
					if (shellOutput.contains("spawn id exp")) {
						scripInfo.put("scriptName", scriptName);
						scripInfo.put("scriptOutput", shellOutput);
						scripInfo.put("saneIssue", "Check the Sane server User and Password");
					} else if (shellOutput.contains("Unknown Host Ip")) {
						scripInfo.put("scriptName", scriptName);
						scripInfo.put("scriptOutput", shellOutput);
						scripInfo.put("saneIssue", "Check the Sane server IP");
					} else {
						scripInfo.put("scriptName", scriptName);
						scripInfo.put("scriptOutput", shellOutput);
						scripInfo.put("saneIssue", "");
					}

				} else if (shellOutput.contains("<rpc-") && shellOutput.contains("</rpc-reply>")) {
					shellOutputAfter = StringUtils.substringAfter(shellOutput, "<rpc-");
					shellOutputBef = StringUtils.substringBefore(shellOutputAfter, "</rpc-reply>");
					shellOutputBefore = shellOutputBefore.append("Response").append("\n").append("<rpc-")
							.append(shellOutputBef).append(" ").append("</rpc-reply>");
					if (!shellOutputBef.contains("ok") && shellOutputBef.contains("</rpc-reply>")) {
						scripInfo.put("scriptName", scriptName);
						scripInfo.put("scriptOutput", shellOutputBefore);
						scripInfo.put("saneIssue", "");
					} else if (shellOutput.contains("spawn id exp") && !shellOutputBef.contains("ok")) {
						scripInfo.put("scriptName", scriptName);
						String rerunLog = StringUtils.substringAfter(sb.toString(), "(sane)");
						scripInfo.put("scriptOutput", rerunLog);
						scripInfo.put("saneIssue",
								"Check the Sane server Password and Please retry the script in Result window");

					} else if (shellOutput.contains("New") && !shellOutputBef.contains("ok")
							&& !shellOutputBef.contains("</rpc-reply>")) {
						scripInfo.put("scriptName", scriptName);
						scripInfo.put("scriptOutput", shellOutputBefore);
						// scripInfo.put("saneIssue","Sane server password is expired, configure new
						// Password and execut the scripts again");
						// Temporary Fix
						scripInfo.put("saneIssue", "Check the error");
					} else if (!shellOutputBef.contains("ok") && !shellOutputBef.contains("</rpc-reply>")) {
						scripInfo.put("scriptName", scriptName);
						scripInfo.put("scriptOutput", shellOutputBefore);
						scripInfo.put("saneIssue", "Check the error");
					}
				} else {
					scripInfo.put("scriptName", scriptName);
					scripInfo.put("scriptOutput", shellOutput);
					scripInfo.put("saneIssue", "");
				}
				fileRuleList.add(scripInfo);
			}
		} catch (Exception e) {
			logger.info("Exception in requiredXmlOutput() in RunTestServiceImpl" + ExceptionUtils.getFullStackTrace(e));
		}
		return fileRuleList;
	}

	public UploadFileEntity getUploadFileEntity(UseCaseBuilderEntity useCaseBuilderEntity, int scriptId) {
		UploadFileEntity uploadFileEntity = null;
		try {
			if (useCaseBuilderEntity != null && !(useCaseBuilderEntity.getUseCaseBuilderParamEntity().isEmpty())) {
				// scriptId==x.getId().intValue()
				for (UseCaseBuilderParamEntity useCaseBuilderParamEntity : useCaseBuilderEntity
						.getUseCaseBuilderParamEntity()) {

					if (useCaseBuilderParamEntity.getScriptsDetails() != null
							&& scriptId == useCaseBuilderParamEntity.getScriptsDetails().getId().intValue())

					{
						uploadFileEntity = useCaseBuilderParamEntity.getScriptsDetails();
						break;
					}

				}

			}
		} catch (Exception e) {
			logger.info(
					"Exception in getUploadFileEntity() in RunTestServiceImpl" + ExceptionUtils.getFullStackTrace(e));
		}

		return uploadFileEntity;
	}

	public UseCaseBuilderParamEntity getUseCaseBuilderParamEntity(UseCaseBuilderEntity useCaseBuilderEntity,
			int scriptId) {
		UseCaseBuilderParamEntity useCaseBuilderParamEntity = null;

		try {
			if (useCaseBuilderEntity != null && !(useCaseBuilderEntity.getUseCaseBuilderParamEntity().isEmpty())) {
				useCaseBuilderParamEntity = useCaseBuilderEntity.getUseCaseBuilderParamEntity().stream()
						.filter(X -> scriptId == X.getId().intValue()).findFirst().orElse(null);
			}
		} catch (Exception e) {
			logger.info("Exception in getUseCaseBuilderParamEntity() in RunTestServiceImpl"
					+ ExceptionUtils.getFullStackTrace(e));
		}
		return useCaseBuilderParamEntity;
	}

	@Override
	public String getRunTestEnbProgressStatus(RunTestEntity runtestEntity) {
		try {

			String neName = runtestEntity.getNeName();
			boolean inProgressStatus = runTestRepository.getRuntestEnbProgressStatus(neName);

			if (inProgressStatus) {
				return GlobalInitializerListener.faultCodeMap.get(FaultCodes.CANNOT_INITIATE_EXECUTION);
			}
		} catch (Exception e) {
			logger.error("Exception RunTestServiceImpl in getRuntestEnbProgressStatus() "
					+ ExceptionUtils.getFullStackTrace(e));
		}
		return Constants.SUCCESS;
	}

	@Override
	public List<Map> getPostMigrationUseCaseList(int programId, String migrationType, String subType,
			List<String> enbId) {

		List<Map> ucList = null;
		try {

			ucList = runTestRepository.getUseCaseListPostMig(programId, migrationType, subType, enbId);

		} catch (Exception e) {
			logger.error(" getPostMigrationUseCaseList service : " + ExceptionUtils.getFullStackTrace(e));
		}
		return ucList;

	}
	private String duoSessionAU(String user, String outputFileName, String scriptName, JSONObject duoData,
			String command, String neId, String sProgramId) throws Exception {
		String result = "";
		StringBuffer output = new StringBuffer();
		boolean useCurrPassword = true;
		String serverIp = null;
		String password = null;
		String path = null;
		String userPrompt = null;
		String superUserPrompt = null;

		try {
			serverIp = duoData.get("serverIp").toString();
			if (duoData.containsKey("password")) {
				useCurrPassword = false;
				password = duoData.get("password").toString();
			}
			path = duoData.get("path").toString();
			userPrompt = duoData.get("userPrompt").toString();
			superUserPrompt = duoData.get("superUserPrompt").toString();
			UserDetailsEntity userDetailsEntity = userActionRepositoryImpl.getUserDetailsBasedName(user);
			String exeFileString = "\nExecuting " + scriptName + "\n";
			output.append(exeFileString);
			OutputStream os = new FileOutputStream(outputFileName, true);
			os.write(exeFileString.getBytes());
			
			String userName_NeId = userDetailsEntity.getVpnUserName() + "_" + neId;
			
			if (!GlobalStatusMap.socketSessionInCreation.containsKey(userName_NeId)) {
				GlobalStatusMap.socketSessionInCreation.put(userName_NeId, false);
			}
			
			while (GlobalStatusMap.socketSessionInCreation.get(userName_NeId)) {
				Thread.sleep(5000);
			}
			if (GlobalStatusMap.socketSessionUser.containsKey(userName_NeId)) {
				SocketSession ses = GlobalStatusMap.socketSessionUser.get(userName_NeId);
				if (ses.isConnectedSession()) {

					while (ses.getIsSessionInUse()) {
						Thread.sleep(5000);
					}
					ses.setIsSessionInUse(true);
					result = ses.runCommand(command);

					ses.setIsSessionInUse(false);
				} else {
					ses.disconnectSession();
					result = connectDuoServerAU(userDetailsEntity, serverIp, password, useCurrPassword, path,
							userPrompt, superUserPrompt, command, neId, sProgramId);
				}
			} else {
				result = connectDuoServerAU(userDetailsEntity, serverIp, password, useCurrPassword, path, userPrompt,
						superUserPrompt, command, neId, sProgramId);
			}
			String resultString = result.replaceAll("\\[\\dm", "").replaceAll("\\[[\\d;]*m", "")
					.replaceAll("\\u0007", "").replaceAll("\\u001B", "").replaceAll("\\]\\d;", "")
					.replaceAll("[*\\[]K", "").replaceAll("[*\\[]A", "").replaceAll("[*\\[]C1", "")
					.replaceAll("[*\\[]C", "");
			os.write(resultString.getBytes());
			output.append(resultString);
		} catch (Exception e) {
			logger.error("Exception RunTestServiceImpl in duoSession() " + ExceptionUtils.getFullStackTrace(e));
		}
		return output.toString();

	}
	private String connectDuoServerAU(UserDetailsEntity userDetailsEntity, String serverIp, String sanepassword,
			boolean useCurrPassword, String path, String userPrompt, String superUserPrompt, String command,
			String neId, String sProgramId) {
		String result = "";
		String userName_NeId = userDetailsEntity.getVpnUserName() + "_" + neId;
		try {
			LocalDateTime lsh1 = LocalDateTime.now();
			logger.error("DB LOGS connectDuoServer Start Time :"+neId);
			logger.error("DB LOGS Active Session : "+GlobalStatusMap.loginUsersDetails.size());
			for (Entry<String, Boolean> entry : GlobalStatusMap.socketSessionInCreation.entrySet()) {
				String key = entry.getKey().toString();
				Boolean value=entry.getValue();
				//System.out.println("IN_Creation"+"-----"+key+"----"+value);
				
				if (key.contains(userDetailsEntity.getVpnUserName()) && !key.contains(userName_NeId)) {
					while (GlobalStatusMap.socketSessionInCreation.get(key)) {
						Thread.sleep(5000);
					}
					
				}
			}
			
			if (GlobalStatusMap.socketSessionInCreation.containsKey(userName_NeId)) {
				GlobalStatusMap.socketSessionInCreation.replace(userName_NeId, true);
			} else {
				GlobalStatusMap.socketSessionInCreation.put(userName_NeId, true);
			}
			LocalDateTime l1 = LocalDateTime.now();
			System.out.println("IMPORTANT"+l1);
			// System.out.println("Enter Ip : ");
			// String ip = "10.20.120.82";
			String user = userDetailsEntity.getVpnUserName();
			String password = null;
			if (useCurrPassword) {
				password = PasswordCrypt.decrypt(userDetailsEntity.getVpnPassword());
			} else {
				password = sanepassword;
			}
			// System.out.println("USER : " + user);
			// System.out.println("PASSWORD : " + password);
			// System.out.println("IP : " + serverIp);
			SocketSession sockets = new SocketSession(user, password, serverIp);
			JSONObject sessionResult = sockets.connectSession(path, userPrompt, superUserPrompt);
			if (sessionResult.get("status").toString().equals(Constants.SUCCESS)) {
				if (sockets.isConnectedSession()) {
					String sessionOutput = "";
					if (sessionResult.containsKey("expectOutput")) {
						sessionOutput = sessionResult.get("expectOutput").toString();
					}
					String resultOutput = sockets.runCommand(command);
					result = sessionOutput + "\n" + resultOutput;
					// System.out.println("----------------Output--------------");
					// System.out.println(result);
					// System.out.println("####################################");
					GlobalStatusMap.socketSessionUser.put(userName_NeId, sockets);
				}
				GlobalStatusMap.socketSessionInCreation.replace(userName_NeId, false);
			} else {
				if (sessionResult.get("reason").toString().equals(Constants.DUO_AUTHENTICATION_FAILURE)) {
					result = "DUO ERROR: " + "\n" + "Permission denied, please try again \n spawn id exp";
				} else if (sessionResult.get("reason").toString().equals(Constants.DUO_UNKNOWN_HOST)) {
					result = "DUO ERROR: " + "\n" + "Unknown Host Ip, Please Check Sane Server IP";
				} else {
					result = "DUO ERROR: " + "\n" + sessionResult.get("reason").toString();
				}
				if (sessionResult.containsKey("expectOutput")) {
					result = sessionResult.get("expectOutput").toString() + "\n" + result;
				}
				GlobalStatusMap.socketSessionInCreation.replace(userName_NeId, false);
			}
			logger.error("DB LOGS connectDuoServer End Time :"+neId);
			
			
		} catch (Exception e) {
			logger.error("Exception RunTestServiceImpl in connectDuoServer() " + ExceptionUtils.getFullStackTrace(e));
			GlobalStatusMap.socketSessionInCreation.replace(userName_NeId, false);
		}
		return result;
	}
	private String duoSessionNeId(String user, String outputFileName, String scriptName, JSONObject duoData,
			String command, String neId, String sProgramId) throws Exception {
		String result = "";
		StringBuffer output = new StringBuffer();
		boolean useCurrPassword = true;
		String serverIp = null;
		String password = null;
		String path = null;
		String userPrompt = null;
		String superUserPrompt = null;

		try {
			serverIp = duoData.get("serverIp").toString();
			if (duoData.containsKey("password")) {
				useCurrPassword = false;
				password = duoData.get("password").toString();
			}
			path = duoData.get("path").toString();
			userPrompt = duoData.get("userPrompt").toString();
			superUserPrompt = duoData.get("superUserPrompt").toString();
			UserDetailsEntity userDetailsEntity = userActionRepositoryImpl.getUserDetailsBasedName(user);
			String exeFileString = "\nExecuting " + scriptName + "\n";
			output.append(exeFileString);
			OutputStream os = new FileOutputStream(outputFileName, true);
			os.write(exeFileString.getBytes());
			String userName_NeId = userDetailsEntity.getVpnUserName() + "_" + neId;
			if (!GlobalStatusMap.socketSessionInCreation.containsKey(userName_NeId)) {
				GlobalStatusMap.socketSessionInCreation.put(userName_NeId, false);
			}
			
			while (GlobalStatusMap.socketSessionInCreation.get(userName_NeId)) {
				Thread.sleep(5000);
			}
			if (GlobalStatusMap.socketSessionUser.containsKey(userName_NeId)) {
				SocketSession ses = GlobalStatusMap.socketSessionUser.get(userName_NeId);
				if (ses.isConnectedSession()) {

					while (ses.getIsSessionInUse()) {
						Thread.sleep(5000);
					}
					ses.setIsSessionInUse(true);
					result = ses.runCommand(command);

					ses.setIsSessionInUse(false);
				} else {
					ses.disconnectSession();
					result = connectDuoServerNeId(userDetailsEntity, serverIp, password, useCurrPassword, path,
							userPrompt, superUserPrompt, command, neId, sProgramId);
				}
			} else {
				result = connectDuoServerNeId(userDetailsEntity, serverIp, password, useCurrPassword, path, userPrompt,
						superUserPrompt, command, neId, sProgramId);
			}
			String resultString = result.replaceAll("\\[\\dm", "").replaceAll("\\[[\\d;]*m", "")
					.replaceAll("\\u0007", "").replaceAll("\\u001B", "").replaceAll("\\]\\d;", "")
					.replaceAll("[*\\[]K", "").replaceAll("[*\\[]A", "").replaceAll("[*\\[]C1", "")
					.replaceAll("[*\\[]C", "");
			os.write(resultString.getBytes());
			output.append(resultString);
		} catch (Exception e) {
			logger.error("Exception RunTestServiceImpl in duoSession() " + ExceptionUtils.getFullStackTrace(e));
		}
		return output.toString();

	}
	private String connectDuoServerNeId(UserDetailsEntity userDetailsEntity, String serverIp, String sanepassword,
			boolean useCurrPassword, String path, String userPrompt, String superUserPrompt, String command,
			String neId, String sProgramId) {
		String result = "";
		String userName_NeId = userDetailsEntity.getVpnUserName() + "_" + neId;
		try {
			
			logger.error("DB LOGS connectDuoServer Start Time neId :"+neId);
			logger.error("DB LOGS Active Session : "+GlobalStatusMap.loginUsersDetails.size());
			Thread.sleep(10000);
			if (GlobalStatusMap.socketSessionInCreation.containsKey(userName_NeId)) {
				GlobalStatusMap.socketSessionInCreation.replace(userName_NeId, true);
			} else {
				GlobalStatusMap.socketSessionInCreation.put(userName_NeId, true);
			}
			// System.out.println("Enter Ip : ");
			// String ip = "10.20.120.82";
			String user = userDetailsEntity.getVpnUserName();
			String password = null;
			if (useCurrPassword) {
				password = PasswordCrypt.decrypt(userDetailsEntity.getVpnPassword());
			} else {
				password = sanepassword;
			}
			// System.out.println("USER : " + user);
			// System.out.println("PASSWORD : " + password);
			// System.out.println("IP : " + serverIp);
			SocketSession sockets = new SocketSession(user, password, serverIp);
			JSONObject sessionResult = sockets.connectSession(path, userPrompt, superUserPrompt);
			if (sessionResult.get("status").toString().equals(Constants.SUCCESS)) {
				if (sockets.isConnectedSession()) {
					String sessionOutput = "";
					if (sessionResult.containsKey("expectOutput")) {
						sessionOutput = sessionResult.get("expectOutput").toString();
					}
					String resultOutput = sockets.runCommand(command);
					result = sessionOutput + "\n" + resultOutput;
					// System.out.println("----------------Output--------------");
					// System.out.println(result);
					// System.out.println("####################################");
					GlobalStatusMap.socketSessionUser.put(userName_NeId, sockets);
				}
				GlobalStatusMap.socketSessionInCreation.replace(userName_NeId, false);
			} else {
				if (sessionResult.get("reason").toString().equals(Constants.DUO_AUTHENTICATION_FAILURE)) {
					result = "DUO ERROR: " + "\n" + "Permission denied, please try again \n spawn id exp";
				} else if (sessionResult.get("reason").toString().equals(Constants.DUO_UNKNOWN_HOST)) {
					result = "DUO ERROR: " + "\n" + "Unknown Host Ip, Please Check Sane Server IP";
				} else {
					result = "DUO ERROR: " + "\n" + sessionResult.get("reason").toString();
				}
				if (sessionResult.containsKey("expectOutput")) {
					result = sessionResult.get("expectOutput").toString() + "\n" + result;
				}
				GlobalStatusMap.socketSessionInCreation.replace(userName_NeId, false);
			}
			logger.error("DB LOGS connectDuoServer End Time neId : "+neId);
		} catch (Exception e) {
			logger.error("Exception RunTestServiceImpl in connectDuoServer() " + ExceptionUtils.getFullStackTrace(e));
			GlobalStatusMap.socketSessionInCreation.replace(userName_NeId, false);
		}
		return result;
	}
	private String duoSession(String user, String outputFileName, String scriptName, JSONObject duoData, String command)
			throws Exception {
		String result = "";
		StringBuilder output = new StringBuilder();
		boolean useCurrPassword = true;
		String serverIp = null;
		String password = null;
		String path = null;
		String userPrompt = null;
		String superUserPrompt = null;

		try {
			serverIp = duoData.get("serverIp").toString();
			if (duoData.containsKey("password")) {
				useCurrPassword = false;
				password = duoData.get("password").toString();
			}
			path = duoData.get("path").toString();
			userPrompt = duoData.get("userPrompt").toString();
			superUserPrompt = duoData.get("superUserPrompt").toString();
			UserDetailsEntity userDetailsEntity = userActionRepositoryImpl.getUserDetailsBasedName(user);
			String exeFileString = "\nExecuting " + scriptName + "\n";
			output.append(exeFileString);
			OutputStream os = new FileOutputStream(outputFileName, true);
			os.write(exeFileString.getBytes());
			// Thread.sleep(1000);

			// System.out.println("------------------Session IN Creation : " +
			// GlobalStatusMap.socketSessionInCreation.get(userDetailsEntity.getVpnUserName()));
			if (!GlobalStatusMap.socketSessionInCreation.containsKey(userDetailsEntity.getVpnUserName())) {
				GlobalStatusMap.socketSessionInCreation.put(userDetailsEntity.getVpnUserName(), false);
			}
			while (GlobalStatusMap.socketSessionInCreation.get(userDetailsEntity.getVpnUserName())) {
				Thread.sleep(5000);
			}
			if (GlobalStatusMap.socketSessionUser.containsKey(userDetailsEntity.getVpnUserName())) {
				SocketSession ses = GlobalStatusMap.socketSessionUser.get(userDetailsEntity.getVpnUserName());
				if (ses.isConnectedSession()) {
					// System.out.println("------------------Session IN USE : " +
					// ses.getIsSessionInUse());
					while (ses.getIsSessionInUse()) {
						Thread.sleep(5000);
					}
					ses.setIsSessionInUse(true);
					result = ses.runCommand(command);
					// System.out.println("----------------Output--------------");
					// System.out.println(result);
					// System.out.println("####################################");
					ses.setIsSessionInUse(false);
				} else {
					ses.disconnectSession();
					result = connectDuoServer(userDetailsEntity, serverIp, password, useCurrPassword, path, userPrompt,
							superUserPrompt, command);
				}
			} else {
				result = connectDuoServer(userDetailsEntity, serverIp, password, useCurrPassword, path, userPrompt,
						superUserPrompt, command);
			}
			String resultString = result.replaceAll("\\[\\dm", "").replaceAll("\\[[\\d;]*m", "")
					.replaceAll("\\u0007", "").replaceAll("\\u001B", "").replaceAll("\\]\\d;", "")
					.replaceAll("[*\\[]K", "").replaceAll("[*\\[]A", "").replaceAll("[*\\[]C1", "")
					.replaceAll("[*\\[]C", "");
			os.write(resultString.getBytes());
			output.append(resultString);
		} catch (Exception e) {
			logger.error("Exception RunTestServiceImpl in duoSession() " + ExceptionUtils.getFullStackTrace(e));
		}
		return output.toString();

	}

	private String connectDuoServer(UserDetailsEntity userDetailsEntity, String serverIp, String sanepassword,
			boolean useCurrPassword, String path, String userPrompt, String superUserPrompt, String command) {
		String result = "";
		try {
			LocalDateTime lsh1 = LocalDateTime.now();
			//logger.error("DB LOGS connectDuoServer ");
			//logger.error("DB LOGS Active Session : "+GlobalStatusMap.loginUsersDetails.size());
			if (GlobalStatusMap.socketSessionInCreation.containsKey(userDetailsEntity.getVpnUserName())) {
				GlobalStatusMap.socketSessionInCreation.replace(userDetailsEntity.getVpnUserName(), true);
			} else {
				GlobalStatusMap.socketSessionInCreation.put(userDetailsEntity.getVpnUserName(), true);
			}
			// System.out.println("Enter Ip : ");
			// String ip = "10.20.120.82";
			String user = userDetailsEntity.getVpnUserName();
			String password = null;
			if (useCurrPassword) {
				password = PasswordCrypt.decrypt(userDetailsEntity.getVpnPassword());
			} else {
				password = sanepassword;
			}
			// System.out.println("USER : " + user);
			// System.out.println("PASSWORD : " + password);
			// System.out.println("IP : " + serverIp);
			SocketSession sockets = new SocketSession(user, password, serverIp);
			JSONObject sessionResult = sockets.connectSession(path, userPrompt, superUserPrompt);
			if (sessionResult.get("status").toString().equals(Constants.SUCCESS)) {
				if (sockets.isConnectedSession()) {
					String sessionOutput = "";
					if (sessionResult.containsKey("expectOutput")) {
						sessionOutput = sessionResult.get("expectOutput").toString();
					}
					String resultOutput = sockets.runCommand(command);
					result = sessionOutput + "\n" + resultOutput;
					// System.out.println("----------------Output--------------");
					// System.out.println(result);
					// System.out.println("####################################");
					GlobalStatusMap.socketSessionUser.put(userDetailsEntity.getVpnUserName(), sockets);
				}
				GlobalStatusMap.socketSessionInCreation.replace(userDetailsEntity.getVpnUserName(), false);
			} else {
				if (sessionResult.get("reason").toString().equals(Constants.DUO_AUTHENTICATION_FAILURE)) {
					result = "DUO ERROR: " + "\n" + "Permission denied, please try again \n spawn id exp";
				} else if (sessionResult.get("reason").toString().equals(Constants.DUO_UNKNOWN_HOST)) {
					result = "DUO ERROR: " + "\n" + "Unknown Host Ip, Please Check Sane Server IP";
				} else {
					result = "DUO ERROR: " + "\n" + sessionResult.get("reason").toString();
				}
				if (sessionResult.containsKey("expectOutput")) {
					result = sessionResult.get("expectOutput").toString() + "\n" + result;
				}
				GlobalStatusMap.socketSessionInCreation.replace(userDetailsEntity.getVpnUserName(), false);
			}
			//logger.error("connectDuoServer End Time :");
		} catch (Exception e) {
			logger.error("Exception RunTestServiceImpl in connectDuoServer() " + ExceptionUtils.getFullStackTrace(e));
			GlobalStatusMap.socketSessionInCreation.replace(userDetailsEntity.getVpnUserName(), false);
		}
		return result;
	}

	private JSONObject isDuoApplicable(UploadFileEntity scriptEntity, NetworkConfigEntity networkConfigEntity,
			boolean useCurrPassword, String sanePassword) {
		JSONObject result = new JSONObject();
		result.put("status", Constants.FAIL);
		try {
			List<ProgramTemplateModel> duoGeneralConfigList = duoGeneralConfigService.getDuoGeneralConfigList();
			if (duoGeneralConfigList != null && !duoGeneralConfigList.isEmpty()
					&& duoGeneralConfigList.get(0).getValue().equalsIgnoreCase("ON")) {
				List<NetworkConfigDetailsEntity> neDetailsList = networkConfigEntity.getNeDetails();
				if (neDetailsList != null && neDetailsList.size() == 1) {
					NetworkConfigDetailsEntity neDetails = neDetailsList.get(0);
					if ("SANE".equalsIgnoreCase(neDetails.getServerTypeEntity().getServerType())) {
						if (neDetails.getPath() == null || neDetails.getPath().isEmpty()) {
							result.put("status", Constants.FAIL);
							result.put("reason",
									"DUO ERROR: " + "\n" + "Path is not specified for Network Config Entity");
							return result;
						}
						if (neDetails.getSuperUserPrompt() == null || neDetails.getSuperUserPrompt().isEmpty()) {
							result.put("status", Constants.FAIL);
							result.put("reason", "DUO ERROR: " + "\n"
									+ "SuperUserPrompt is not specified for Network Config Entity");
							return result;
						}
						if (neDetails.getUserPrompt() == null || neDetails.getUserPrompt().isEmpty()) {
							result.put("status", Constants.FAIL);
							result.put("reason",
									"DUO ERROR: " + "\n" + "UserPrompt is not specified for Network Config Entity");
							return result;
						}
						result.put("serverIp", neDetails.getServerIp());
						result.put("path", neDetails.getPath());
						result.put("superUserPrompt", neDetails.getSuperUserPrompt());
						result.put("userPrompt", neDetails.getUserPrompt());
						if (useCurrPassword == false) {
							result.put("password", sanePassword);
						}
						result.put("status", Constants.SUCCESS);
					}
				}
			}
		} catch (Exception e) {
			logger.error("Exception RunTestServiceImpl in isDuoApplicable() " + ExceptionUtils.getFullStackTrace(e));
			result.put("status", Constants.FAIL);
		}
		return result;

	}

	private JSONObject getCurlCommandAudit(String neId, String sProgramId, String migrationType,
			UploadFileEntity scriptEntity, NetworkConfigEntity neEntity, String useCaseName, String ciqFileName) {
		JSONObject result = new JSONObject();
		String command = "";
		String endName = "";
		String mcmip = "";
		try {
			int programId = Integer.parseInt(sProgramId);
			String scriptAbsFileName = "";
			if (useCaseName.contains(Constants.COMMISION_USECASE) || useCaseName.contains(Constants.RF_USECASE)) {
				scriptAbsFileName = LoadPropertyFiles.getInstance().getProperty("BASE_PATH") + Constants.CUSTOMER + "/"
						+ Constants.UPLOAD_FILE_PATH_WITHOUT_VERSION.replace("programId", String.valueOf(programId))
								.replace("migrationType", migrationType).replace("subType", scriptEntity.getSubType())
						+ useCaseName.trim().replaceAll(" ", "_") + "/" + scriptEntity.getFileName();
			} else {
				scriptAbsFileName = LoadPropertyFiles.getInstance().getProperty("BASE_PATH")
						+ scriptEntity.getFilePath() + "/" + useCaseName.trim().replaceAll(" ", "_") + "/"
						+ scriptEntity.getFileName();
			}
			if (CommonUtil.isValidObject(neEntity) && CommonUtil.isValidObject(neEntity.getNeTypeEntity())
					&& neEntity.getNeTypeEntity().getId() == Constants.NW_CONFIG_VLSM_ID
					&& CommonUtil.isValidObject(neEntity.getNeDetails())) {
				for (NetworkConfigDetailsEntity detailsEntity : neEntity.getNeDetails()) {
					if (CommonUtil.isValidObject(detailsEntity.getServerTypeEntity())) {
						if (detailsEntity.getServerTypeEntity().getId() == Constants.NW_CONFIG_VLSM_MCMA_ID
								&& CommonUtil.isValidObject(detailsEntity.getServerIp())
								&& detailsEntity.getServerIp().length() > 0) {
							mcmip = detailsEntity.getServerIp();
							break;
						}
					}
				}
			}
			if (CommonUtil.isValidObject(neEntity) && CommonUtil.isValidObject(neEntity.getNeTypeEntity())
					&& neEntity.getNeTypeEntity().getId() == Constants.NW_CONFIG_USM_ID) {
				mcmip = neEntity.getNeIp();
			}
			if (StringUtils.isNotEmpty(scriptEntity.getFileName())) {
				endName = scriptEntity.getFileName().substring(0, scriptEntity.getFileName().indexOf('_'));
			}
			if ("ACPF".equalsIgnoreCase(endName) || "AUPF".equalsIgnoreCase(endName) || "AU".equalsIgnoreCase(endName)
					|| "DU".equalsIgnoreCase(endName) || "DSS".equalsIgnoreCase(endName)
					|| "4GAudit".equalsIgnoreCase(endName) || "IAU".equalsIgnoreCase(endName)
					|| "CBand".equalsIgnoreCase(endName) || "Audit4G".equalsIgnoreCase(endName)) {
				String dbcollectionFileName = CommonUtil.createMongoDbFileName(sProgramId, ciqFileName);
				List<CIQDetailsModel> listCIQDetailsModel = getCIQDetailsModelList(neId, dbcollectionFileName);
				String gnbId = "";
				if (!ObjectUtils.isEmpty(listCIQDetailsModel))

				{
					CIQDetailsModel ciqDetailsModel = listCIQDetailsModel.get(0);

					LinkedHashMap<String, CiqMapValuesModel> objMapDetails = ciqDetailsModel.getCiqMap();

					if ("ACPF".equalsIgnoreCase(endName) && !ObjectUtils.isEmpty(objMapDetails)
							&& objMapDetails.containsKey("NE_ID ACPF")) {
						String acpfName = "";
						if (objMapDetails.containsKey("NE_ID_ACPF Name")) {
							acpfName = objMapDetails.get("NE_ID_ACPF Name").getHeaderValue();
						}
						gnbId = objMapDetails.get("NE_ID ACPF").getHeaderValue();
						gnbId = gnbId.trim();
						gnbId = gnbId.replaceAll("^0+(?!$)", "");
						/*
						 * if(acpfName.contains("ACPFP")) { gnbId = gnbId.trim(); gnbId =
						 * gnbId.replaceAll("^0+(?!$)", ""); } else if (StringUtils.isNotEmpty(gnbId) &&
						 * gnbId.length() >= 4) { gnbId = gnbId.trim(); gnbId =
						 * gnbId.substring(gnbId.length() - 4); gnbId = gnbId.replaceAll("^0+(?!$)",
						 * "");
						 * 
						 * }
						 */

					} else if ("AUPF".equalsIgnoreCase(endName) && !ObjectUtils.isEmpty(objMapDetails)
							&& objMapDetails.containsKey("NE_ID_AUPF")) {
						String aupfName = "";
						if (objMapDetails.containsKey("NE_ID_AUPF Name")) {
							aupfName = objMapDetails.get("NE_ID_AUPF Name").getHeaderValue();
						}
						gnbId = objMapDetails.get("NE_ID_AUPF").getHeaderValue();
						gnbId = gnbId.trim();
						gnbId = gnbId.replaceAll("^0+(?!$)", "");

						/*
						 * if(aupfName.contains("AUPFP")) { gnbId = gnbId.trim(); gnbId =
						 * gnbId.replaceAll("^0+(?!$)", ""); } else if (StringUtils.isNotEmpty(gnbId) &&
						 * gnbId.length() >= 4) { gnbId = gnbId.trim(); gnbId =
						 * gnbId.substring(gnbId.length() - 4); gnbId = gnbId.replaceAll("^0+(?!$)",
						 * "");
						 * 
						 * }
						 */

					} else if (("AU".equalsIgnoreCase(endName) || "DU".equalsIgnoreCase(endName)
							|| "IAU".equalsIgnoreCase(endName)) && !ObjectUtils.isEmpty(objMapDetails)
							&& objMapDetails.containsKey("NE ID AU")) {

						endName = "DU";
						gnbId = objMapDetails.get("NE ID AU").getHeaderValue();
						if (StringUtils.isNotEmpty(gnbId)) {
							gnbId = gnbId.trim();
							gnbId = gnbId.replaceAll("^0+(?!$)", "");
						}

					} else if ("DSS".equalsIgnoreCase(endName) && !ObjectUtils.isEmpty(objMapDetails)) {
						for (CIQDetailsModel ciqDetails : listCIQDetailsModel) {
							if (ciqDetails.getSheetAliasName().equals("vDUGrowSiteLevel(Day1)CQ")) {
								ciqDetailsModel = ciqDetails;
							}
						}
						objMapDetails = ciqDetailsModel.getCiqMap();
						if (scriptEntity.getFileName().contains("ACPF")) {
							if (objMapDetails.containsKey("ACPF_ID")) {
								gnbId = objMapDetails.get("ACPF_ID").getHeaderValue();
								gnbId = gnbId.trim().replaceAll("^0+(?!$)", "");
								if (gnbId.length() > 2 && NumberUtils.isNumber(gnbId)) {
									endName = "ACPF";
								} else {
									result.put("status", Constants.FAIL);
									result.put("reason", "ACPF_ID data not correct");
									return result;
								}
								NeMappingModel neMappingModel = new NeMappingModel();
								CustomerDetailsEntity programDetailsEntity = new CustomerDetailsEntity();
								programDetailsEntity.setId(programId);
								neMappingModel.setProgramDetailsEntity(programDetailsEntity);
								neMappingModel
										.setEnbId(objMapDetails.get("ACPF_ID").getHeaderValue().replaceAll("^0+(?!$)", ""));
								List<NeMappingEntity> neMappingEntities = neMappingService.getNeMapping(neMappingModel);
								if ((CommonUtil.isValidObject(neMappingEntities) && neMappingEntities.size() > 0)
										&& (CommonUtil.isValidObject(neMappingEntities.get(0))
												&& CommonUtil.isValidObject(neMappingEntities.get(0).getSiteConfigType())
												&& (neMappingEntities.get(0).getSiteConfigType().length() > 0))) {
									mcmip = neMappingEntities.get(0).getNetworkConfigEntity().getNeIp();
								}
							} else {
								result.put("status", Constants.FAIL);
								result.put("reason", "ACPF_ID not found");
								return result;
							}

						} else if (scriptEntity.getFileName().contains("AUPF")) {
							if (objMapDetails.containsKey("AUPF_ID")) {
								gnbId = objMapDetails.get("AUPF_ID").getHeaderValue();
								gnbId = gnbId.trim().replaceAll("^0+(?!$)", "");
								if (gnbId.length() > 2 && NumberUtils.isNumber(gnbId)) {
									endName = "AUPF";
								} else {
									result.put("status", Constants.FAIL);
									result.put("reason", "AUPF_ID data not correct");
									return result;
								}
								NeMappingModel neMappingModel = new NeMappingModel();
								CustomerDetailsEntity programDetailsEntity = new CustomerDetailsEntity();
								programDetailsEntity.setId(programId);
								neMappingModel.setProgramDetailsEntity(programDetailsEntity);
								neMappingModel
										.setEnbId(objMapDetails.get("AUPF_ID").getHeaderValue().replaceAll("^0+(?!$)", ""));
								List<NeMappingEntity> neMappingEntities = neMappingService.getNeMapping(neMappingModel);
								if ((CommonUtil.isValidObject(neMappingEntities) && neMappingEntities.size() > 0)
										&& (CommonUtil.isValidObject(neMappingEntities.get(0))
												&& CommonUtil.isValidObject(neMappingEntities.get(0).getSiteConfigType())
												&& (neMappingEntities.get(0).getSiteConfigType().length() > 0))) {
									mcmip = neMappingEntities.get(0).getNetworkConfigEntity().getNeIp();
								}
							} else {
								result.put("status", Constants.FAIL);
								result.put("reason", "AUPF_ID not found");
								return result;
							}

						} else if (scriptEntity.getFileName().contains("vDU")) {
							if (objMapDetails.containsKey("NEID")) {
								endName = "ADPF";
								gnbId = objMapDetails.get("NEID").getHeaderValue().replaceAll("^0+(?!$)", "");
							} else {
								result.put("status", Constants.FAIL);
								result.put("reason", "NE_ID not found");
								return result;
							}

						} else if (scriptEntity.getFileName().contains("eNB")) {
							if (objMapDetails.containsKey("4GeNB")) {
								endName = "eNB";
								gnbId = objMapDetails.get("4GeNB").getHeaderValue().replaceAll("^0+(?!$)", "");

								NeMappingModel neMappingModel = new NeMappingModel();
								CustomerDetailsEntity programDetailsEntity = new CustomerDetailsEntity();
								//programDetailsEntity.setProgramName("VZN-4G-USM-LIVE");
								programDetailsEntity.setId(34);
								neMappingModel.setProgramDetailsEntity(programDetailsEntity);
								neMappingModel.setEnbId(
										objMapDetails.get("4GeNB").getHeaderValue().replaceAll("^0+(?!$)", ""));
								List<NeMappingEntity> neMappingEntities = neMappingService.getNeMapping(neMappingModel);
								if ((CommonUtil.isValidObject(neMappingEntities) && neMappingEntities.size() > 0)
										&& (CommonUtil.isValidObject(neMappingEntities.get(0))
												&& CommonUtil
														.isValidObject(neMappingEntities.get(0).getSiteConfigType())
												&& (neMappingEntities.get(0).getSiteConfigType().length() > 0))) {
									mcmip = neMappingEntities.get(0).getNetworkConfigEntity().getNeIp();
								}
							} else {
								result.put("status", Constants.FAIL);
								result.put("reason", "4GeNB not found");
								return result;
							}

						} else if (scriptEntity.getFileName().contains("FSU")) {
							if (objMapDetails.containsKey("NEID")) {
								List<CIQDetailsModel> listCIQsheetDetailsModel = fileUploadRepository
										.getEnbTableSheetDetailss(ciqFileName, "DSS_MOP_Parameters-1",
												objMapDetails.get("NEID").getHeaderValue(), dbcollectionFileName);
								if (!ObjectUtils.isEmpty(listCIQsheetDetailsModel)
										&& listCIQsheetDetailsModel.get(0).getCiqMap().containsKey("FSUID")) {
									endName = "FSU";
									gnbId = listCIQsheetDetailsModel.get(0).getCiqMap().get("FSUID").getHeaderValue()
											.replaceAll("^0+(?!$)", "");
									if (objMapDetails.containsKey("4GeNB")) {
										NeMappingModel neMappingModel = new NeMappingModel();
										CustomerDetailsEntity programDetailsEntity = new CustomerDetailsEntity();
										//programDetailsEntity.setProgramName("VZN-4G-USM-LIVE");
										programDetailsEntity.setId(34);
										neMappingModel.setProgramDetailsEntity(programDetailsEntity);
										neMappingModel.setEnbId(
												objMapDetails.get("4GeNB").getHeaderValue().replaceAll("^0+(?!$)", ""));
										List<NeMappingEntity> neMappingEntities = neMappingService
												.getNeMapping(neMappingModel);
										if ((CommonUtil.isValidObject(neMappingEntities)
												&& neMappingEntities.size() > 0)
												&& (CommonUtil.isValidObject(neMappingEntities.get(0))
														&& CommonUtil.isValidObject(
																neMappingEntities.get(0).getSiteConfigType())
														&& (neMappingEntities.get(0).getSiteConfigType()
																.length() > 0))) {
											mcmip = neMappingEntities.get(0).getNetworkConfigEntity().getNeIp();
										}
										NeMappingModel neMappingModel1 = new NeMappingModel();
										CustomerDetailsEntity programDetailsEntity1 = new CustomerDetailsEntity();
										
										programDetailsEntity1.setId(programId);
										neMappingModel1.setProgramDetailsEntity(programDetailsEntity1);
										neMappingModel1.setEnbId(gnbId);
										List<NeMappingEntity> neMappingEntities1 = neMappingService
												.getNeMapping(neMappingModel1);
										if ((CommonUtil.isValidObject(neMappingEntities1)
												&& neMappingEntities1.size() > 0)
												&& (CommonUtil.isValidObject(neMappingEntities1.get(0))
														&& CommonUtil.isValidObject(
																neMappingEntities1.get(0).getSiteConfigType())
														&& (neMappingEntities1.get(0).getSiteConfigType()
																.length() > 0))) {
											mcmip = neMappingEntities1.get(0).getNetworkConfigEntity().getNeIp();
										}
										
									}
								} else {
									result.put("status", Constants.FAIL);
									result.put("reason", "FSU_ID not found");
									return result;
								}
							} else {
								result.put("status", Constants.FAIL);
								result.put("reason", "FSU_ID not found");
								return result;
							}

						}

					} else if ("CBand".equalsIgnoreCase(endName) && !ObjectUtils.isEmpty(objMapDetails)) {
						if (scriptEntity.getFileName().contains("vDU") && objMapDetails.containsKey("NEID")) {
							endName = "ADPF";
							gnbId = objMapDetails.get("NEID").getHeaderValue().replaceAll("^0+(?!$)", "");
						} else if (scriptEntity.getFileName().contains("AUPF")
								&& objMapDetails.containsKey("AUPF_ID")) {
							endName = "AUPF";
							gnbId = objMapDetails.get("AUPF_ID").getHeaderValue().replaceAll("^0+(?!$)", "");
							NeMappingModel neMappingModel = new NeMappingModel();
							CustomerDetailsEntity programDetailsEntity = new CustomerDetailsEntity();
							programDetailsEntity.setId(programId);
							neMappingModel.setProgramDetailsEntity(programDetailsEntity);
							neMappingModel
									.setEnbId(objMapDetails.get("AUPF_ID").getHeaderValue().replaceAll("^0+(?!$)", ""));
							List<NeMappingEntity> neMappingEntities = neMappingService.getNeMapping(neMappingModel);
							if ((CommonUtil.isValidObject(neMappingEntities) && neMappingEntities.size() > 0)
									&& (CommonUtil.isValidObject(neMappingEntities.get(0))
											&& CommonUtil.isValidObject(neMappingEntities.get(0).getSiteConfigType())
											&& (neMappingEntities.get(0).getSiteConfigType().length() > 0))) {
								mcmip = neMappingEntities.get(0).getNetworkConfigEntity().getNeIp();
							}
						} else if (scriptEntity.getFileName().contains("ACPF")
								&& objMapDetails.containsKey("ACPF_ID")) {
							endName = "ACPF";
							gnbId = objMapDetails.get("ACPF_ID").getHeaderValue().replaceAll("^0+(?!$)", "");
							NeMappingModel neMappingModel = new NeMappingModel();
							CustomerDetailsEntity programDetailsEntity = new CustomerDetailsEntity();
							programDetailsEntity.setId(programId);
							neMappingModel.setProgramDetailsEntity(programDetailsEntity);
							neMappingModel
									.setEnbId(objMapDetails.get("AUPF_ID").getHeaderValue().replaceAll("^0+(?!$)", ""));
							List<NeMappingEntity> neMappingEntities = neMappingService.getNeMapping(neMappingModel);
							if ((CommonUtil.isValidObject(neMappingEntities) && neMappingEntities.size() > 0)
									&& (CommonUtil.isValidObject(neMappingEntities.get(0))
											&& CommonUtil.isValidObject(neMappingEntities.get(0).getSiteConfigType())
											&& (neMappingEntities.get(0).getSiteConfigType().length() > 0))) {
								mcmip = neMappingEntities.get(0).getNetworkConfigEntity().getNeIp();
							}
						} else if (scriptEntity.getFileName().contains("eNB") && objMapDetails.containsKey("ENB_ID")) {
							endName = "eNB";
							gnbId = objMapDetails.get("ENB_ID").getHeaderValue().replaceAll("^0+(?!$)", "");

							NeMappingModel neMappingModel = new NeMappingModel();
							CustomerDetailsEntity programDetailsEntity = new CustomerDetailsEntity();
							programDetailsEntity.setId(programId);
							neMappingModel.setProgramDetailsEntity(programDetailsEntity);
							neMappingModel
									.setEnbId(objMapDetails.get("ENB_ID").getHeaderValue().replaceAll("^0+(?!$)", ""));
							List<NeMappingEntity> neMappingEntities = neMappingService.getNeMapping(neMappingModel);
							if ((CommonUtil.isValidObject(neMappingEntities) && neMappingEntities.size() > 0)
									&& (CommonUtil.isValidObject(neMappingEntities.get(0))
											&& CommonUtil.isValidObject(neMappingEntities.get(0).getSiteConfigType())
											&& (neMappingEntities.get(0).getSiteConfigType().length() > 0))) {
								mcmip = neMappingEntities.get(0).getNetworkConfigEntity().getNeIp();
							}
						}
					} else if ("4GAudit".equalsIgnoreCase(endName)) {
						endName = "eNB";
						gnbId = neId.replaceAll("^0+(?!$)", "");
					} else if ("Audit4G".equalsIgnoreCase(endName) && !ObjectUtils.isEmpty(objMapDetails)) {
						if (scriptEntity.getFileName().contains("FSU")
								&& objMapDetails.containsKey("NE_ID")) {
							endName = "FSU";
							gnbId = objMapDetails.get("NE_ID").getHeaderValue().replaceAll("^0+(?!$)", "");
						}else if (scriptEntity.getFileName().contains("eNB")
								&& objMapDetails.containsKey("eNB_Name")) {
							endName = "eNB";
							gnbId = objMapDetails.get("eNB_Name").getHeaderValue().replaceAll("^0+(?!$)", "");
						}
					}

				}
				if (scriptEntity.getFileName().contains(XmlCommandsConstants.AU_TWAMP_F1C_LINK)) {
					CIQDetailsModel ciqDetailsModel = listCIQDetailsModel.get(0);
					LinkedHashMap<String, CiqMapValuesModel> objMapDetails = ciqDetailsModel.getCiqMap();
					if (objMapDetails.containsKey("Remote_IP_Address")) {
						String remoteIp = objMapDetails.get("Remote_IP_Address").getHeaderValue().trim();
						command = CommonUtil.getCurlCommandAuditTwamp(scriptAbsFileName, mcmip, gnbId, endName,
								scriptEntity.getFileName(), remoteIp);
					}
				} else if (scriptEntity.getFileName().contains(XmlCommandsConstants.IAU_TWAMP_F1C_LINK)) {
					CIQDetailsModel ciqDetailsModel = listCIQDetailsModel.get(0);
					LinkedHashMap<String, CiqMapValuesModel> objMapDetails = ciqDetailsModel.getCiqMap();
					if (objMapDetails.containsKey("Remote_IP_Address")) {
						String remoteIp = objMapDetails.get("Remote_IP_Address").getHeaderValue().trim();
						command = CommonUtil.getCurlCommandAuditTwampIAU(scriptAbsFileName, mcmip, gnbId, endName,
								scriptEntity.getFileName(), remoteIp);
					}
				} else {
					command = CommonUtil.getCurlCommandAudit(scriptAbsFileName, mcmip, gnbId, endName);
				}

				result.put("command", command);
				result.put("status", Constants.SUCCESS);

			}
		} catch (Exception e) {
			logger.error(
					"Exception RunTestServiceImpl in getCurlCommandAudit() " + ExceptionUtils.getFullStackTrace(e));
			result.put("status", Constants.FAIL);
			result.put("reason", e.getMessage());
		}
		return result;
	}

	private String getCurlCommandAuditEnb(String neId, String sProgramId, String migrationType,
			UploadFileEntity scriptEntity, NetworkConfigEntity neEntity, String useCaseName, String ciqFileName,
			String enbId) {
		String command = "";
		String endName = "";
		String mcmip = "";
		try {
			int programId = Integer.parseInt(sProgramId);
			String scriptAbsFileName = "";
			if (useCaseName.contains(Constants.COMMISION_USECASE) || useCaseName.contains(Constants.RF_USECASE)) {
				scriptAbsFileName = LoadPropertyFiles.getInstance().getProperty("BASE_PATH") + Constants.CUSTOMER + "/"
						+ Constants.UPLOAD_FILE_PATH_WITHOUT_VERSION.replace("programId", String.valueOf(programId))
								.replace("migrationType", migrationType).replace("subType", scriptEntity.getSubType())
						+ useCaseName.trim().replaceAll(" ", "_") + "/" + scriptEntity.getFileName();
			} else {
				scriptAbsFileName = LoadPropertyFiles.getInstance().getProperty("BASE_PATH")
						+ scriptEntity.getFilePath() + "/" + useCaseName.trim().replaceAll(" ", "_") + "/"
						+ scriptEntity.getFileName();
			}
			if (CommonUtil.isValidObject(neEntity) && CommonUtil.isValidObject(neEntity.getNeTypeEntity())
					&& neEntity.getNeTypeEntity().getId() == Constants.NW_CONFIG_VLSM_ID
					&& CommonUtil.isValidObject(neEntity.getNeDetails())) {
				for (NetworkConfigDetailsEntity detailsEntity : neEntity.getNeDetails()) {
					if (CommonUtil.isValidObject(detailsEntity.getServerTypeEntity())) {
						if (detailsEntity.getServerTypeEntity().getId() == Constants.NW_CONFIG_VLSM_MCMA_ID
								&& CommonUtil.isValidObject(detailsEntity.getServerIp())
								&& detailsEntity.getServerIp().length() > 0) {
							mcmip = detailsEntity.getServerIp();
							break;
						}
					}
				}
			}
			if (CommonUtil.isValidObject(neEntity) && CommonUtil.isValidObject(neEntity.getNeTypeEntity())
					&& neEntity.getNeTypeEntity().getId() == Constants.NW_CONFIG_USM_ID) {
				mcmip = neEntity.getNeIp();
			}
			if (StringUtils.isNotEmpty(scriptEntity.getFileName())) {
				endName = scriptEntity.getFileName().substring(0, scriptEntity.getFileName().indexOf('_'));
			}
			if ("eNB".equalsIgnoreCase(endName)) {
				endName = "eNB";
				String gnbId = enbId.replaceAll("^0+(?!$)", "");
				command = CommonUtil.getCurlCommandAudit(scriptAbsFileName, mcmip, gnbId, endName);
			}
		} catch (Exception e) {
			logger.error(
					"Exception RunTestServiceImpl in getCurlCommandAudit() " + ExceptionUtils.getFullStackTrace(e));
		}
		return command;
	}

	private JSONObject getCurlCommandMig(String neId, String sProgramId, String migrationType,
			UploadFileEntity scriptEntity, NetworkConfigEntity neEntity, String useCaseName, String ciqFileName) {
		JSONObject resultcommand = new JSONObject();
		String command = "";
		try {
			int programId = Integer.parseInt(sProgramId);
			String scriptAbsFileName = "";
			StringBuilder sourceCurlFilename = new StringBuilder();

			sourceCurlFilename.append(LoadPropertyFiles.getInstance().getProperty("BASE_PATH"))
					.append(Constants.CUSTOMER).append(Constants.SEPARATOR)
					.append(Constants.DUO_CURL_COMMAND_FILEPATH.replace("programId", Integer.toString(programId))
							.replace("filename", StringUtils.substringBeforeLast(ciqFileName, "."))
							.replace("enbId", neId))
					.append(Constants.SEPARATOR).append(useCaseName.trim()).append(Constants.SEPARATOR)
					.append(FilenameUtils.removeExtension(scriptEntity.getFileName())).append(".txt");
			scriptAbsFileName = sourceCurlFilename.toString();

			if (useCaseName.contains(Constants.COMMISION_USECASE) || useCaseName.contains(Constants.RF_USECASE)
					|| useCaseName.contains("ACPF_A1A2") || useCaseName.contains("CSL") || useCaseName.contains("Comm")
					|| useCaseName.contains("ENDC") || useCaseName.contains("Anchor") || useCaseName.contains("NBR")
					|| useCaseName.contains("RF_Scripts_Usecase") || useCaseName.contains("RFScriptsUsecase")
					|| useCaseName.contains("GP_Script") || useCaseName.contains("GPScript")
					|| useCaseName.contains("vDU_RF_Scripts_Usecase") || useCaseName.contains("eNB_RF_Scripts_Usecase")
					|| useCaseName.contains("ACPF_RF_Scripts_Usecase")
					|| useCaseName.contains("AUPF_RF_Scripts_Usecase") || useCaseName.contains("FSU_RF_Scripts_Usecase")
					|| useCaseName.contains("vDURFScriptsUsecase") || useCaseName.contains("eNBRFScriptsUsecase")
					|| useCaseName.contains("ACPFRFScriptsUsecase") || useCaseName.contains("AUPFRFScriptsUsecase")
					|| useCaseName.contains("FSURFScriptsUsecase") || useCaseName.contains(Constants.GROWCELLUSECASE)
					|| useCaseName.contains(Constants.GROWENBUSECASE) || useCaseName.contains(Constants.PNPUSECASE)
					|| useCaseName.contains("AUCaCell") || useCaseName.contains("AU20B")
					|| useCaseName.contains("AU20A") || useCaseName.contains("pnp20BUsecase")
					|| useCaseName.contains("pnp20AUsecase") || useCaseName.contains("Pre-Check_RF_Scripts_Usecase")
					|| useCaseName.contains("Cutover_RF_Scripts_Usecase") || useCaseName.contains("Extended_Usecase")
					|| useCaseName.contains("ExtendedUsecase") || useCaseName.contains("Rollback_RF_Scripts_Usecase")
					|| useCaseName.contains("AU20C") || useCaseName.contains("pnp20CUsecase")
					|| useCaseName.contains("AU21A") || useCaseName.contains("pnp21AUsecase")
					|| useCaseName.contains("AU21B") || useCaseName.contains("pnp21BUsecase")
					|| useCaseName.contains("AU21C") || useCaseName.contains("pnp21CUsecase")
					|| useCaseName.contains("vDUCellGrow_cband") || useCaseName.contains("vDUGrow_cband")
					|| useCaseName.contains("pnpGrow_cband") || useCaseName.contains("GrowFSU")
					|| useCaseName.contains("pnpGrow") || useCaseName.contains("vDUCellGrow")
					|| useCaseName.contains("AU21D")|| useCaseName.contains("pnp21DUsecase")
					|| useCaseName.contains("AU22A")|| useCaseName.contains("pnp22AUsecase") //22A
					|| useCaseName.contains("AU22C")|| useCaseName.contains("pnp22CUsecase") //22A
					|| useCaseName.contains("CA_Usecase") || useCaseName.contains(Constants.ENDC_USECASE) 
					||useCaseName.contains("vDUGrow")
					||useCaseName.contains("DeleteNEUsecase")
					|| useCaseName.contains("NeCreationTimeUsecase")
					||useCaseName.contains("DeleteNE21AUsecase")
					|| useCaseName.contains("NeCreationTime21AUsecase")
					||useCaseName.contains("DeleteNE21BUsecase")
					|| useCaseName.contains("NeCreationTime21BUsecase")
					||useCaseName.contains("DeleteNE21CUsecase")
					|| useCaseName.contains("NeCreationTime21CUsecase")
					||useCaseName.contains("DeleteNE21DUsecase")
					|| useCaseName.contains("NeCreationTime21DUsecase")
					||useCaseName.contains("DeleteNE22AUsecase")
					|| useCaseName.contains("NeCreationTime22AUsecase")
					||useCaseName.contains("DeleteNE22CUsecase")
					|| useCaseName.contains("NeCreationTime22CUsecase")) {//DeleteNEUsecase//DeGrow21DUsecase
				File sourceCurlFile = new File(scriptAbsFileName);
				if (sourceCurlFile.exists()) {
					command = readCurlFile(sourceCurlFile.getPath());
					if (useCaseName.contains("AUCommision")) {
						String dbcollectionFileName = CommonUtil.createMongoDbFileName(String.valueOf(programId),
								ciqFileName);
						List<CIQDetailsModel> listCIQDetailsModel = fileUploadRepository.getEnbTableDetails(ciqFileName,
								neId, "", dbcollectionFileName);
						String CC0_Offset = listCIQDetailsModel.get(0).getCiqMap().get("CC0 Cell Identity")
								.getHeaderValue();
						String CC1_Offset = listCIQDetailsModel.get(0).getCiqMap().get("CC1 Cell Identity")
								.getHeaderValue();
						String CC2_Offset = listCIQDetailsModel.get(0).getCiqMap().get("CC2 Cell Identity")
								.getHeaderValue();
						String CC3_Offset = listCIQDetailsModel.get(0).getCiqMap().get("CC3 Cell Identity")
								.getHeaderValue();
						String CC4_Offset = listCIQDetailsModel.get(0).getCiqMap().get("CC4 Cell Identity")
								.getHeaderValue();
						String CC5_Offset = listCIQDetailsModel.get(0).getCiqMap().get("CC5 Cell Identity")
								.getHeaderValue();
						String CC6_Offset = listCIQDetailsModel.get(0).getCiqMap().get("CC6 Cell Identity")
								.getHeaderValue();
						String CC7_Offset = listCIQDetailsModel.get(0).getCiqMap().get("CC7 Cell Identity")
								.getHeaderValue();
						if (useCaseName.contains("Comm")) {
							if (command.contains("${cell-num=0}"))
								command = command.replace("${cell-num=0}", CC0_Offset);
							if (command.contains("${cell-num=1}"))
								command = command.replace("${cell-num=1}", CC1_Offset);
							if (command.contains("${cell-num=2}"))
								command = command.replace("${cell-num=2}", CC2_Offset);
							if (command.contains("${cell-num=3}"))
								command = command.replace("${cell-num=3}", CC3_Offset);
							if (command.contains("${cell-num=4}"))
								command = command.replace("${cell-num=4}", CC4_Offset);
							if (command.contains("${cell-num=5}"))
								command = command.replace("${cell-num=5}", CC5_Offset);
							if (command.contains("${cell-num=6}"))
								command = command.replace("${cell-num=6}", CC6_Offset);
							if (command.contains("${cell-num=7}"))
								command = command.replace("${cell-num=7}", CC7_Offset);
						}
					}

					resultcommand.put("command", command);
				}

			}
		} catch (Exception e) {
			logger.error("Exception RunTestServiceImpl in getCurlCommandMig() " + ExceptionUtils.getFullStackTrace(e));
		}
		return resultcommand;

	}

	@Override
	public boolean getusecaseDetails(int programId, String migrationType, String subType, String useCaseName) {
		boolean isTestNamePresent = false;
		try {
			isTestNamePresent = runTestRepository.getusecaseDetails(programId, migrationType, subType, useCaseName);

		} catch (Exception e) {
			logger.error("Exception RunTestServiceImpl in getRunTestEntity() " + ExceptionUtils.getFullStackTrace(e));
		}

		return isTestNamePresent;
	}

	private JSONObject getCurlCommandAuditTwamp(String neId, String sProgramId, String migrationType,
			UploadFileEntity scriptEntity, NetworkConfigEntity neEntity, String useCaseName, String ciqFileName,
			String testId) {
		JSONObject result = new JSONObject();
		String command = "";
		String endName = "";
		String mcmip = "";
		try {
			int programId = Integer.parseInt(sProgramId);
			String scriptAbsFileName = "";
			if (useCaseName.contains(Constants.COMMISION_USECASE) || useCaseName.contains(Constants.RF_USECASE)) {
				scriptAbsFileName = LoadPropertyFiles.getInstance().getProperty("BASE_PATH") + Constants.CUSTOMER + "/"
						+ Constants.UPLOAD_FILE_PATH_WITHOUT_VERSION.replace("programId", String.valueOf(programId))
								.replace("migrationType", migrationType).replace("subType", scriptEntity.getSubType())
						+ useCaseName.trim().replaceAll(" ", "_") + "/" + XmlCommandsConstants.AU_DIAGNOSTIC + ".xml";
			} else {
				scriptAbsFileName = LoadPropertyFiles.getInstance().getProperty("BASE_PATH")
						+ scriptEntity.getFilePath() + "/" + useCaseName.trim().replaceAll(" ", "_") + "/"
						+ XmlCommandsConstants.AU_DIAGNOSTIC + ".xml";
			}
			if (CommonUtil.isValidObject(neEntity) && CommonUtil.isValidObject(neEntity.getNeTypeEntity())
					&& neEntity.getNeTypeEntity().getId() == Constants.NW_CONFIG_VLSM_ID
					&& CommonUtil.isValidObject(neEntity.getNeDetails())) {
				for (NetworkConfigDetailsEntity detailsEntity : neEntity.getNeDetails()) {
					if (CommonUtil.isValidObject(detailsEntity.getServerTypeEntity())) {
						if (detailsEntity.getServerTypeEntity().getId() == Constants.NW_CONFIG_VLSM_MCMA_ID
								&& CommonUtil.isValidObject(detailsEntity.getServerIp())
								&& detailsEntity.getServerIp().length() > 0) {
							mcmip = detailsEntity.getServerIp();
							break;
						}
					}
				}
			}
			if (CommonUtil.isValidObject(neEntity) && CommonUtil.isValidObject(neEntity.getNeTypeEntity())
					&& neEntity.getNeTypeEntity().getId() == Constants.NW_CONFIG_USM_ID) {
				mcmip = neEntity.getNeIp();
			}
			if (StringUtils.isNotEmpty(scriptEntity.getFileName())) {
				endName = scriptEntity.getFileName().substring(0, scriptEntity.getFileName().indexOf('_'));
			}
			if ("AU".equalsIgnoreCase(endName)) {
				String dbcollectionFileName = CommonUtil.createMongoDbFileName(sProgramId, ciqFileName);
				List<CIQDetailsModel> listCIQDetailsModel = getCIQDetailsModelList(neId, dbcollectionFileName);
				String gnbId = "";
				if (!ObjectUtils.isEmpty(listCIQDetailsModel))

				{
					CIQDetailsModel ciqDetailsModel = listCIQDetailsModel.get(0);

					LinkedHashMap<String, CiqMapValuesModel> objMapDetails = ciqDetailsModel.getCiqMap();

					if ("AU".equalsIgnoreCase(endName) && !ObjectUtils.isEmpty(objMapDetails)
							&& objMapDetails.containsKey("NE ID AU")) {

						endName = "DU";
						gnbId = objMapDetails.get("NE ID AU").getHeaderValue();
						if (StringUtils.isNotEmpty(gnbId)) {
							gnbId = gnbId.trim();
							gnbId = gnbId.replaceAll("^0+(?!$)", "");
						}

					}

				}
				command = CommonUtil.getCurlCommandAuditTwamp(scriptAbsFileName, mcmip, gnbId, endName,
						XmlCommandsConstants.AU_DIAGNOSTIC, testId);

				result.put("command", command);
				result.put("status", Constants.SUCCESS);

			}
		} catch (Exception e) {
			logger.error(
					"Exception RunTestServiceImpl in getCurlCommandAudit() " + ExceptionUtils.getFullStackTrace(e));
			result.put("status", Constants.FAIL);
			result.put("reason", e.getMessage());
		}
		return result;
	}

	private JSONObject getCurlCommandAuditTwampIAU(String neId, String sProgramId, String migrationType,
			UploadFileEntity scriptEntity, NetworkConfigEntity neEntity, String useCaseName, String ciqFileName,
			String testId) {
		JSONObject result = new JSONObject();
		String command = "";
		String endName = "";
		String mcmip = "";
		try {
			int programId = Integer.parseInt(sProgramId);
			String scriptAbsFileName = "";
			if (useCaseName.contains(Constants.COMMISION_USECASE) || useCaseName.contains(Constants.RF_USECASE)) {
				scriptAbsFileName = LoadPropertyFiles.getInstance().getProperty("BASE_PATH") + Constants.CUSTOMER + "/"
						+ Constants.UPLOAD_FILE_PATH_WITHOUT_VERSION.replace("programId", String.valueOf(programId))
								.replace("migrationType", migrationType).replace("subType", scriptEntity.getSubType())
						+ useCaseName.trim().replaceAll(" ", "_") + "/" + XmlCommandsConstants.IAU_DIAGNOSTIC + ".xml";
			} else {
				scriptAbsFileName = LoadPropertyFiles.getInstance().getProperty("BASE_PATH")
						+ scriptEntity.getFilePath() + "/" + useCaseName.trim().replaceAll(" ", "_") + "/"
						+ XmlCommandsConstants.IAU_DIAGNOSTIC + ".xml";
			}
			if (CommonUtil.isValidObject(neEntity) && CommonUtil.isValidObject(neEntity.getNeTypeEntity())
					&& neEntity.getNeTypeEntity().getId() == Constants.NW_CONFIG_VLSM_ID
					&& CommonUtil.isValidObject(neEntity.getNeDetails())) {
				for (NetworkConfigDetailsEntity detailsEntity : neEntity.getNeDetails()) {
					if (CommonUtil.isValidObject(detailsEntity.getServerTypeEntity())) {
						if (detailsEntity.getServerTypeEntity().getId() == Constants.NW_CONFIG_VLSM_MCMA_ID
								&& CommonUtil.isValidObject(detailsEntity.getServerIp())
								&& detailsEntity.getServerIp().length() > 0) {
							mcmip = detailsEntity.getServerIp();
							break;
						}
					}
				}
			}
			if (CommonUtil.isValidObject(neEntity) && CommonUtil.isValidObject(neEntity.getNeTypeEntity())
					&& neEntity.getNeTypeEntity().getId() == Constants.NW_CONFIG_USM_ID) {
				mcmip = neEntity.getNeIp();
			}
			if (StringUtils.isNotEmpty(scriptEntity.getFileName())) {
				endName = scriptEntity.getFileName().substring(0, scriptEntity.getFileName().indexOf('_'));
			}
			if ("IAU".equalsIgnoreCase(endName)) {
				String dbcollectionFileName = CommonUtil.createMongoDbFileName(sProgramId, ciqFileName);
				List<CIQDetailsModel> listCIQDetailsModel = getCIQDetailsModelList(neId, dbcollectionFileName);
				String gnbId = "";
				if (!ObjectUtils.isEmpty(listCIQDetailsModel))

				{
					CIQDetailsModel ciqDetailsModel = listCIQDetailsModel.get(0);

					LinkedHashMap<String, CiqMapValuesModel> objMapDetails = ciqDetailsModel.getCiqMap();

					if ("IAU".equalsIgnoreCase(endName) && !ObjectUtils.isEmpty(objMapDetails)
							&& objMapDetails.containsKey("NE ID AU")) {

						endName = "DU";
						gnbId = objMapDetails.get("NE ID AU").getHeaderValue();
						if (StringUtils.isNotEmpty(gnbId)) {
							gnbId = gnbId.trim();
							gnbId = gnbId.replaceAll("^0+(?!$)", "");
						}

					}

				}
				command = CommonUtil.getCurlCommandAuditTwampIAU(scriptAbsFileName, mcmip, gnbId, endName,
						XmlCommandsConstants.IAU_DIAGNOSTIC, testId);

				result.put("command", command);
				result.put("status", Constants.SUCCESS);

			}
		} catch (Exception e) {
			logger.error(
					"Exception RunTestServiceImpl in getCurlCommandAudit() " + ExceptionUtils.getFullStackTrace(e));
			result.put("status", Constants.FAIL);
			result.put("reason", e.getMessage());
		}
		return result;
	}

	private String gettwampoutput(UploadFileEntity scriptEntity, String dataOutput, String neId,
			String dbcollectionFileName, NetworkConfigEntity networkConfigEntity, boolean useCurrPassword,
			String sanePassword, NetworkConfigEntity neEntity, String sProgramId, String migrationType,
			String originalUseCaseName, String ciqFileName, String userName, String outputFileNameAudit, AtomicBoolean isMultipleDUo) {
		String twampshellop = "";
		try {
			String fileNameWoExten = FilenameUtils.removeExtension(scriptEntity.getFileName());
			String testId = auditXmlRulesServiceUtil.gettestIdtwamp(dataOutput, fileNameWoExten, neId,
					dbcollectionFileName, networkConfigEntity);
			System.out.println("TestId : " + testId);

			// Implementing wait for TWAMP
			Thread.sleep(Constants.TWAMP_TIMEOUT);

			JSONObject duoData = isDuoApplicable(scriptEntity, networkConfigEntity, useCurrPassword, sanePassword);
			if (duoData.containsKey("status") && duoData.get("status").equals(Constants.SUCCESS)) {
				JSONObject resultCurlCommand = getCurlCommandAuditTwamp(neId, sProgramId, migrationType, scriptEntity,
						neEntity, originalUseCaseName, ciqFileName, testId);
				if (resultCurlCommand.containsKey("status")
						&& resultCurlCommand.get("status").equals(Constants.SUCCESS)) {
					String tempCommand = resultCurlCommand.get("command").toString();
					System.out.println("--------------Command --------------");
					System.out.println(tempCommand);
					System.out.println("--------------Command --------------");
					if(isMultipleDUo.get()) {
						twampshellop = duoSessionAU(userName, outputFileNameAudit,
								XmlCommandsConstants.AU_DIAGNOSTIC + ".xml", duoData, tempCommand,neId, sProgramId);
					}else {
					twampshellop = duoSession(userName, outputFileNameAudit,
							XmlCommandsConstants.AU_DIAGNOSTIC + ".xml", duoData, tempCommand);
					}
				} else if (resultCurlCommand.containsKey("reason")) {
					twampshellop = resultCurlCommand.get("reason").toString();
				}
			}
		} catch (Exception e) {
			logger.error("Exception RunTestServiceImpl in gettwampoutput() " + ExceptionUtils.getFullStackTrace(e));
		}
		return twampshellop;
	}
	public String getAuthencationString() {
		StringBuilder authString = new StringBuilder();
		try {
			OvGeneralEntity objOvGeneralEntityUserName = customerRepository.getOvlabelTemplate(Constants.OV_USERNAME);
			OvGeneralEntity objOvGeneralEntityPassword = customerRepository.getOvlabelTemplate(Constants.OV_PASSWORD);
			authString.append(objOvGeneralEntityUserName.getValue());
			authString.append(":");
			authString.append(objOvGeneralEntityPassword.getValue());
		} catch (Exception e) {
			logger.info("Exception in getAuthencationString in FetchProcessServiceImpl "
					+ ExceptionUtils.getFullStackTrace(e));
		}

		return authString.toString();
	}
	public HttpComponentsClientHttpRequestFactory getHttpsConfiguration()
			throws NoSuchAlgorithmException, KeyManagementException, KeyStoreException {
		TrustStrategy acceptingTrustStrategy = (cert, authType) -> true;
		SSLContext sslContext = SSLContexts.custom().loadTrustMaterial(null, acceptingTrustStrategy).build();
		SSLConnectionSocketFactory sslsf = new SSLConnectionSocketFactory(sslContext, NoopHostnameVerifier.INSTANCE);

		Registry<ConnectionSocketFactory> socketFactoryRegistry = RegistryBuilder.<ConnectionSocketFactory>create()
				.register("https", sslsf).register("http", new PlainConnectionSocketFactory()).build();

		BasicHttpClientConnectionManager connectionManager = new BasicHttpClientConnectionManager(
				socketFactoryRegistry);
		CloseableHttpClient httpClient = HttpClients.custom().setSSLSocketFactory(sslsf)
				.setConnectionManager(connectionManager).build();

		HttpComponentsClientHttpRequestFactory requestFactory = new HttpComponentsClientHttpRequestFactory(httpClient);
		requestFactory.setHttpClient(httpClient);
		return requestFactory;
	}
	private String gettwampoutputIAU(UploadFileEntity scriptEntity, String dataOutput, String neId,
			String dbcollectionFileName, NetworkConfigEntity networkConfigEntity, boolean useCurrPassword,
			String sanePassword, NetworkConfigEntity neEntity, String sProgramId, String migrationType,
			String originalUseCaseName, String ciqFileName, String userName, String outputFileNameAudit, AtomicBoolean isMultipleDUo) {
		String twampshellop = "";
		try {
			String fileNameWoExten = FilenameUtils.removeExtension(scriptEntity.getFileName());
			String testId = auditXmlRulesServiceUtil.gettestIdtwamp(dataOutput, fileNameWoExten, neId,
					dbcollectionFileName, networkConfigEntity);
			System.out.println("TestId : " + testId);

			// Implementing wait for TWAMP
			Thread.sleep(Constants.TWAMP_TIMEOUT);

			JSONObject duoData = isDuoApplicable(scriptEntity, networkConfigEntity, useCurrPassword, sanePassword);
			if (duoData.containsKey("status") && duoData.get("status").equals(Constants.SUCCESS)) {
				JSONObject resultCurlCommand = getCurlCommandAuditTwampIAU(neId, sProgramId, migrationType,
						scriptEntity, neEntity, originalUseCaseName, ciqFileName, testId);
				if (resultCurlCommand.containsKey("status")
						&& resultCurlCommand.get("status").equals(Constants.SUCCESS)) {
					String tempCommand = resultCurlCommand.get("command").toString();
					System.out.println("--------------Command --------------");
					System.out.println(tempCommand);
					System.out.println("--------------Command --------------");
					if(isMultipleDUo.get()) {
						twampshellop = duoSessionAU(userName, outputFileNameAudit,
								XmlCommandsConstants.IAU_DIAGNOSTIC + ".xml", duoData, tempCommand,neId, sProgramId);	
					}else {
					twampshellop = duoSession(userName, outputFileNameAudit,
							XmlCommandsConstants.IAU_DIAGNOSTIC + ".xml", duoData, tempCommand);
					}
				} else if (resultCurlCommand.containsKey("reason")) {
					twampshellop = resultCurlCommand.get("reason").toString();
				}
			}
		} catch (Exception e) {
			logger.error("Exception RunTestServiceImpl in gettwampoutputIAU() " + ExceptionUtils.getFullStackTrace(e));
		}
		return twampshellop;
	}

	private JSONObject getCurlCommandAuditF1ULinkTwamp(String neId, String sProgramId, String migrationType,
			UploadFileEntity scriptEntity, NetworkConfigEntity neEntity, String useCaseName, String ciqFileName,
			String remoteIp) {
		JSONObject result = new JSONObject();
		String command = "";
		String endName = "";
		String mcmip = "";
		try {
			int programId = Integer.parseInt(sProgramId);
			String scriptAbsFileName = "";
			if (useCaseName.contains(Constants.COMMISION_USECASE) || useCaseName.contains(Constants.RF_USECASE)) {
				scriptAbsFileName = LoadPropertyFiles.getInstance().getProperty("BASE_PATH") + Constants.CUSTOMER + "/"
						+ Constants.UPLOAD_FILE_PATH_WITHOUT_VERSION.replace("programId", String.valueOf(programId))
								.replace("migrationType", migrationType).replace("subType", scriptEntity.getSubType())
						+ useCaseName.trim().replaceAll(" ", "_") + "/" + scriptEntity.getFileName();
			} else {
				scriptAbsFileName = LoadPropertyFiles.getInstance().getProperty("BASE_PATH")
						+ scriptEntity.getFilePath() + "/" + useCaseName.trim().replaceAll(" ", "_") + "/"
						+ scriptEntity.getFileName();
			}
			if (CommonUtil.isValidObject(neEntity) && CommonUtil.isValidObject(neEntity.getNeTypeEntity())
					&& neEntity.getNeTypeEntity().getId() == Constants.NW_CONFIG_VLSM_ID
					&& CommonUtil.isValidObject(neEntity.getNeDetails())) {
				for (NetworkConfigDetailsEntity detailsEntity : neEntity.getNeDetails()) {
					if (CommonUtil.isValidObject(detailsEntity.getServerTypeEntity())) {
						if (detailsEntity.getServerTypeEntity().getId() == Constants.NW_CONFIG_VLSM_MCMA_ID
								&& CommonUtil.isValidObject(detailsEntity.getServerIp())
								&& detailsEntity.getServerIp().length() > 0) {
							mcmip = detailsEntity.getServerIp();
							break;
						}
					}
				}
			}
			if (CommonUtil.isValidObject(neEntity) && CommonUtil.isValidObject(neEntity.getNeTypeEntity())
					&& neEntity.getNeTypeEntity().getId() == Constants.NW_CONFIG_USM_ID) {
				mcmip = neEntity.getNeIp();
			}
			if (StringUtils.isNotEmpty(scriptEntity.getFileName())) {
				endName = scriptEntity.getFileName().substring(0, scriptEntity.getFileName().indexOf('_'));
			}
			if ("AU".equalsIgnoreCase(endName)) {
				String dbcollectionFileName = CommonUtil.createMongoDbFileName(sProgramId, ciqFileName);
				List<CIQDetailsModel> listCIQDetailsModel = getCIQDetailsModelList(neId, dbcollectionFileName);
				String gnbId = "";
				if (!ObjectUtils.isEmpty(listCIQDetailsModel))

				{
					CIQDetailsModel ciqDetailsModel = listCIQDetailsModel.get(0);

					LinkedHashMap<String, CiqMapValuesModel> objMapDetails = ciqDetailsModel.getCiqMap();

					if (("AU".equalsIgnoreCase(endName)) && !ObjectUtils.isEmpty(objMapDetails)
							&& objMapDetails.containsKey("NE ID AU")) {

						endName = "DU";
						gnbId = objMapDetails.get("NE ID AU").getHeaderValue();
						if (StringUtils.isNotEmpty(gnbId)) {
							gnbId = gnbId.trim();
							gnbId = gnbId.replaceAll("^0+(?!$)", "");
						}
					}

				}
				if (scriptEntity.getFileName().contains(XmlCommandsConstants.AU_TWAMP_F1C_LINK)) {
					command = CommonUtil.getCurlCommandAuditTwamp(scriptAbsFileName, mcmip, gnbId, endName,
							scriptEntity.getFileName(), remoteIp);
				}

				result.put("command", command);
				result.put("status", Constants.SUCCESS);

			}
		} catch (Exception e) {
			logger.error(
					"Exception RunTestServiceImpl in getCurlCommandAudit() " + ExceptionUtils.getFullStackTrace(e));
			result.put("status", Constants.FAIL);
			result.put("reason", e.getMessage());
		}
		return result;
	}

	private JSONObject getCurlCommandAuditF1ULinkTwampIAU(String neId, String sProgramId, String migrationType,
			UploadFileEntity scriptEntity, NetworkConfigEntity neEntity, String useCaseName, String ciqFileName,
			String remoteIp) {
		JSONObject result = new JSONObject();
		String command = "";
		String endName = "";
		String mcmip = "";
		try {
			int programId = Integer.parseInt(sProgramId);
			String scriptAbsFileName = "";
			if (useCaseName.contains(Constants.COMMISION_USECASE) || useCaseName.contains(Constants.RF_USECASE)) {
				scriptAbsFileName = LoadPropertyFiles.getInstance().getProperty("BASE_PATH") + Constants.CUSTOMER + "/"
						+ Constants.UPLOAD_FILE_PATH_WITHOUT_VERSION.replace("programId", String.valueOf(programId))
								.replace("migrationType", migrationType).replace("subType", scriptEntity.getSubType())
						+ useCaseName.trim().replaceAll(" ", "_") + "/" + scriptEntity.getFileName();
			} else {
				scriptAbsFileName = LoadPropertyFiles.getInstance().getProperty("BASE_PATH")
						+ scriptEntity.getFilePath() + "/" + useCaseName.trim().replaceAll(" ", "_") + "/"
						+ scriptEntity.getFileName();
			}
			if (CommonUtil.isValidObject(neEntity) && CommonUtil.isValidObject(neEntity.getNeTypeEntity())
					&& neEntity.getNeTypeEntity().getId() == Constants.NW_CONFIG_VLSM_ID
					&& CommonUtil.isValidObject(neEntity.getNeDetails())) {
				for (NetworkConfigDetailsEntity detailsEntity : neEntity.getNeDetails()) {
					if (CommonUtil.isValidObject(detailsEntity.getServerTypeEntity())) {
						if (detailsEntity.getServerTypeEntity().getId() == Constants.NW_CONFIG_VLSM_MCMA_ID
								&& CommonUtil.isValidObject(detailsEntity.getServerIp())
								&& detailsEntity.getServerIp().length() > 0) {
							mcmip = detailsEntity.getServerIp();
							break;
						}
					}
				}
			}
			if (CommonUtil.isValidObject(neEntity) && CommonUtil.isValidObject(neEntity.getNeTypeEntity())
					&& neEntity.getNeTypeEntity().getId() == Constants.NW_CONFIG_USM_ID) {
				mcmip = neEntity.getNeIp();
			}
			if (StringUtils.isNotEmpty(scriptEntity.getFileName())) {
				endName = scriptEntity.getFileName().substring(0, scriptEntity.getFileName().indexOf('_'));
			}
			if ("IAU".equalsIgnoreCase(endName)) {
				String dbcollectionFileName = CommonUtil.createMongoDbFileName(sProgramId, ciqFileName);
				List<CIQDetailsModel> listCIQDetailsModel = getCIQDetailsModelList(neId, dbcollectionFileName);
				String gnbId = "";
				if (!ObjectUtils.isEmpty(listCIQDetailsModel))

				{
					CIQDetailsModel ciqDetailsModel = listCIQDetailsModel.get(0);

					LinkedHashMap<String, CiqMapValuesModel> objMapDetails = ciqDetailsModel.getCiqMap();

					if (("IAU".equalsIgnoreCase(endName)) && !ObjectUtils.isEmpty(objMapDetails)
							&& objMapDetails.containsKey("NE ID AU")) {

						endName = "DU";
						gnbId = objMapDetails.get("NE ID AU").getHeaderValue();
						if (StringUtils.isNotEmpty(gnbId)) {
							gnbId = gnbId.trim();
							gnbId = gnbId.replaceAll("^0+(?!$)", "");
						}
					}

				}
				if (scriptEntity.getFileName().contains(XmlCommandsConstants.IAU_TWAMP_F1C_LINK)) {
					command = CommonUtil.getCurlCommandAuditTwampIAU(scriptAbsFileName, mcmip, gnbId, endName,
							scriptEntity.getFileName(), remoteIp);
				}

				result.put("command", command);
				result.put("status", Constants.SUCCESS);

			}
		} catch (Exception e) {
			logger.error(
					"Exception RunTestServiceImpl in getCurlCommandAudit() " + ExceptionUtils.getFullStackTrace(e));
			result.put("status", Constants.FAIL);
			result.put("reason", e.getMessage());
		}
		return result;
	}

	private ArrayList<HashMap<String, String>> getRemoteIPAddress(String sProgramId, String ciqFileName, String neId) {
		ArrayList<HashMap<String, String>> remoteIpList = new ArrayList<>();
		try {
			String dbcollectionFileName = CommonUtil.createMongoDbFileName(sProgramId, ciqFileName);
			List<CIQDetailsModel> listCIQDetailsModel = getCIQDetailsModelList(neId, dbcollectionFileName);
			String aupfId = "";
			if (!ObjectUtils.isEmpty(listCIQDetailsModel))

			{
				CIQDetailsModel ciqDetailsModel = listCIQDetailsModel.get(0);

				LinkedHashMap<String, CiqMapValuesModel> objMapDetails = ciqDetailsModel.getCiqMap();

				if (!ObjectUtils.isEmpty(objMapDetails) && objMapDetails.containsKey("NE_ID_AUPF Name")) {

					aupfId = objMapDetails.get("NE_ID_AUPF Name").getHeaderValue().trim().replaceAll("^0+(?!$)", "");

				}

			}
			if (!aupfId.isEmpty()) {
				List<CIQDetailsModel> listCIQsheetDetailsModel = getCIQDetailsModelList(aupfId, dbcollectionFileName);
				if (!ObjectUtils.isEmpty(listCIQsheetDetailsModel)) {
					for (CIQDetailsModel ciqData : listCIQsheetDetailsModel) {
						String interfaceName = ciqData.getCiqMap().get("interface-name").getHeaderValue().trim();
						String ip = ciqData.getCiqMap().get("ip").getHeaderValue().trim();
						if ((interfaceName.contains("ext0") || interfaceName.contains("ext1")) && !ip.equals("::")
								&& !ip.isEmpty()) {
							HashMap<String, String> remoteIpData = new HashMap<>();
							remoteIpData.put("interface_name", interfaceName);
							remoteIpData.put("ip", ip);
							remoteIpList.add(remoteIpData);
						}
					}
				}
			}
		} catch (Exception e) {
			logger.error("Exception RunTestServiceImpl in getRemoteIPAddress() " + ExceptionUtils.getFullStackTrace(e));
		}
		System.out.println(remoteIpList);
		return remoteIpList;
	}

	private JSONObject gettwampoutputF1U(UploadFileEntity scriptEntity, String neId, String dbcollectionFileName,
			NetworkConfigEntity networkConfigEntity, boolean useCurrPassword, String sanePassword,
			NetworkConfigEntity neEntity, String sProgramId, String migrationType, String originalUseCaseName,
			String ciqFileName, String userName, String outputFileNameAudit, AtomicBoolean isMultipleDUo) {
		JSONObject totaltwampshellop = new JSONObject();
		try {
			JSONObject duoData = isDuoApplicable(scriptEntity, networkConfigEntity, useCurrPassword, sanePassword);
			ArrayList<HashMap<String, String>> remoteIpList = getRemoteIPAddress(sProgramId, ciqFileName, neId);
			StringBuilder required5GOutput = new StringBuilder();
			StringBuilder shelloutputTwamp = new StringBuilder();
			
			for (HashMap<String, String> remoteIp : remoteIpList) {

				if (duoData.containsKey("status") && duoData.get("status").equals(Constants.SUCCESS)) {
					JSONObject resultCurlCommand = getCurlCommandAuditF1ULinkTwamp(neId, sProgramId, migrationType,
							scriptEntity, neEntity, originalUseCaseName, ciqFileName, remoteIp.get("ip"));
					String shelloutput = "";
					if (resultCurlCommand.containsKey("status")
							&& resultCurlCommand.get("status").equals(Constants.SUCCESS)) {
						String tempCommand = resultCurlCommand.get("command").toString();
						System.out.println("--------------Command --------------");
						System.out.println(tempCommand);
						System.out.println("--------------Command --------------");
						if(isMultipleDUo.get()) {
							shelloutput = duoSessionAU(userName, outputFileNameAudit, scriptEntity.getFileName(), duoData,
									tempCommand,neId, sProgramId);
						}else {
						shelloutput = duoSession(userName, outputFileNameAudit, scriptEntity.getFileName(), duoData,
								tempCommand);
						}
					} else if (resultCurlCommand.containsKey("reason")) {
						shelloutput = resultCurlCommand.get("reason").toString();
					}
				
					String dataOutput = getRequiredOutPut5GAudit(shelloutput, scriptEntity.getFileName());
					required5GOutput.append(dataOutput);
					required5GOutput.append("/n");

					if (shelloutput.contains("<rpc-reply") && !(shelloutput.contains("<rpc-error"))) {
						String twampshellop = gettwampoutput(scriptEntity, dataOutput, neId, dbcollectionFileName,
								networkConfigEntity, useCurrPassword, sanePassword, neEntity, sProgramId, migrationType,
								originalUseCaseName, ciqFileName, userName, outputFileNameAudit,isMultipleDUo);
					
						shelloutput = shelloutput + "\n" + twampshellop;

						String dataOutput1 = getRequiredOutPut5GAuditTwamp(twampshellop, remoteIp.get("interface_name")
								+ "_" + remoteIp.get("ip") + "_" + XmlCommandsConstants.AU_DIAGNOSTIC + ".xml");
						required5GOutput.append(dataOutput1);
						required5GOutput.append("/n");

					}
					shelloutputTwamp.append(shelloutput);
					shelloutputTwamp.append("\n");

				}
				
			}
			totaltwampshellop.put("shelloutput", shelloutputTwamp.toString());
			totaltwampshellop.put("required5GOutput", required5GOutput.toString());

		} catch (Exception e) {
			logger.error("Exception RunTestServiceImpl in gettwampoutput() " + ExceptionUtils.getFullStackTrace(e));
		}
		return totaltwampshellop;
	}

	private JSONObject gettwampoutputF1UIAU(UploadFileEntity scriptEntity, String neId, String dbcollectionFileName,
			NetworkConfigEntity networkConfigEntity, boolean useCurrPassword, String sanePassword,
			NetworkConfigEntity neEntity, String sProgramId, String migrationType, String originalUseCaseName,
			String ciqFileName, String userName, String outputFileNameAudit, AtomicBoolean isMultipleDUo) {
		JSONObject totaltwampshellop = new JSONObject();
		try {
			JSONObject duoData = isDuoApplicable(scriptEntity, networkConfigEntity, useCurrPassword, sanePassword);
			ArrayList<HashMap<String, String>> remoteIpList = getRemoteIPAddress(sProgramId, ciqFileName, neId);
			StringBuilder required5GOutput = new StringBuilder();
			StringBuilder shelloutputTwamp = new StringBuilder();
			
			for (HashMap<String, String> remoteIp : remoteIpList) {

				if (duoData.containsKey("status") && duoData.get("status").equals(Constants.SUCCESS)) {
					JSONObject resultCurlCommand = getCurlCommandAuditF1ULinkTwampIAU(neId, sProgramId, migrationType,
							scriptEntity, neEntity, originalUseCaseName, ciqFileName, remoteIp.get("ip"));
					String shelloutput = "";
					if (resultCurlCommand.containsKey("status")
							&& resultCurlCommand.get("status").equals(Constants.SUCCESS)) {
						String tempCommand = resultCurlCommand.get("command").toString();
						System.out.println("--------------Command --------------");
						System.out.println(tempCommand);
						System.out.println("--------------Command --------------");
						if(isMultipleDUo.get()) {
							shelloutput = duoSessionAU(userName, outputFileNameAudit, scriptEntity.getFileName(), duoData,
									tempCommand,neId, sProgramId);
							}else {
								shelloutput = duoSession(userName, outputFileNameAudit, scriptEntity.getFileName(), duoData,
										tempCommand);	
							}
					} else if (resultCurlCommand.containsKey("reason")) {
						shelloutput = resultCurlCommand.get("reason").toString();
					}
			
					String dataOutput = getRequiredOutPut5GAudit(shelloutput, scriptEntity.getFileName());
					required5GOutput.append(dataOutput);
					required5GOutput.append("/n");

					if (shelloutput.contains("<rpc-reply") && !(shelloutput.contains("<rpc-error"))) {
						String twampshellop = gettwampoutputIAU(scriptEntity, dataOutput, neId, dbcollectionFileName,
								networkConfigEntity, useCurrPassword, sanePassword, neEntity, sProgramId, migrationType,
								originalUseCaseName, ciqFileName, userName, outputFileNameAudit,isMultipleDUo);
				
						shelloutput = shelloutput + "\n" + twampshellop;

						String dataOutput1 = getRequiredOutPut5GAuditTwamp(twampshellop, remoteIp.get("interface_name")
								+ "_" + remoteIp.get("ip") + "_" + XmlCommandsConstants.IAU_DIAGNOSTIC + ".xml");
						required5GOutput.append(dataOutput1);
						required5GOutput.append("/n");

					}
					shelloutputTwamp.append(shelloutput);
					shelloutputTwamp.append("\n");

				}
				
			}
			totaltwampshellop.put("shelloutput", shelloutputTwamp.toString());
			totaltwampshellop.put("required5GOutput", required5GOutput.toString());

		} catch (Exception e) {
			logger.error("Exception RunTestServiceImpl in gettwampoutput() " + ExceptionUtils.getFullStackTrace(e));
		}
		return totaltwampshellop;
	}
	
	private String getRequiredOutPut5GOV(String shelloutput, String fileName) {

		StringBuilder objBuilder = new StringBuilder();

		try {
			String fileNameWoExten = FilenameUtils.removeExtension(fileName);
			objBuilder.append("\n");
			objBuilder.append(fileNameWoExten);
			objBuilder.append("\n");

			objBuilder.append(shelloutput);
			objBuilder.append("\n");

		} catch (Exception e) {
			logger.error("Exception RunTestServiceImpl in getRequiredOutPut5GAudit() "
					+ ExceptionUtils.getFullStackTrace(e));
		}
		// TODO Auto-generated method stub

		objBuilder.append(XmlCommandsConstants.ENDTEXT5G);
		objBuilder.append("\n");
		return objBuilder.toString();
	}


@Override
	public String getRuntestExecResultNeUp(JSONObject runTestParams,
			Map<String, RunTestEntity> runTestEntityMap, String runType, String htmlOutputFileName,
			Map<String, Object> reRunDetails, boolean rfScriptsFlag) throws RctException {
		JSONObject dssResult = new JSONObject();
		Map run = (Map) runTestParams.get("runTestFormDetails");
		String testname = run.get("testname").toString();

		List<Map> scriptSeqDetails = (List<Map>) run.get("scripts");
		List<Map> neList = (List<Map>) run.get("neDetails");
		List<LinkedHashMap> useCaseList = (List) run.get("useCase");
		int programId = Integer.parseInt(runTestParams.get("programId").toString());

		boolean useCurrPassword = (boolean) run.get("currentPassword");
		String serviceToken = runTestParams.get("serviceToken").toString();
		String sanePassword = run.get("password").toString();
		String migType = runTestParams.get("migrationType").toString();
		String migSubType = runTestParams.get("migrationSubType").toString();
		String userName = runTestParams.get("userName").toString();
		String checklistFileName = run.get("checklistFileName").toString();
		String ciqFileName = run.get("ciqName").toString();
		String sProgramId = runTestParams.get("programId").toString();
		String remarks = run.get("testDesc").toString();
		String sessionId = runTestParams.get("sessionId").toString();
		CustomerDetailsEntity customerDetailsEntity = getCustomerDetailsEntity(programId);
		AtomicBoolean totalTestCompleted = new AtomicBoolean();
		AtomicBoolean isMultipleDUo = new AtomicBoolean();
		isMultipleDUo.set(false);
		if (run.containsKey("multipleDuo")) {
			boolean duo1234 = (boolean) run.get("multipleDuo");
			if (duo1234 == true) {
				isMultipleDUo.set(true);
			}
		}
		try {
			ExecutorService executorservice = Executors.newFixedThreadPool(neList.size());
			for (Map usecase : useCaseList) {
				Integer useCaseId = Integer.valueOf(usecase.get("useCaseId").toString());
				runTestRepository.updateUseCountForUseCase(useCaseId, Constants.USECOUNT_INCREMENT, neList.size());
			}
			for (Map neid : neList) {

				executorservice.submit(() -> {
					LocalDateTime l1 = LocalDateTime.now();
					Map<String, String> scriptFilesDetails = new HashMap<>();
					StringBuilder auditHtmlFilePath = new StringBuilder();
					StringBuilder auditHtmlFileName = new StringBuilder();
					NetworkConfigEntity neMappingEntitiesForVersion = null;
					ReportsEntity reportsEntity = null;

					String neId = neid.get("neId").toString();
					String neName = neid.get("neName").toString();
					logger.error("Started the thread for NE " + neId + " at : " + l1);
					String threadname = "RT_" + runTestEntityMap.get(neId).getId();
					Thread.currentThread().setName(threadname);
					runTestEntityMap.get(neId).setruntestThreadName(threadname);
					runTestRepository.updateRunTest(runTestEntityMap.get(neId));

					UserDetailsEntity userDetailsEntity2 = userActionRepositoryImpl.getUserDetailsBasedName(userName);
					if (GlobalStatusMap.userNeQueue.contains(userDetailsEntity2.getVpnUserName())) {
						GlobalStatusMap.userNeQueue.get(userDetailsEntity2.getVpnUserName()).add(neId);
					} else {
						GlobalStatusMap.userNeQueue.put(userDetailsEntity2.getVpnUserName(),
								new ConcurrentLinkedQueue<>());
						GlobalStatusMap.userNeQueue.get(userDetailsEntity2.getVpnUserName()).add(neId);
					}

					int lsmId = 0;
					String lsmName = run.get("lsmName").toString();
					String lsmVersion = run.get("lsmVersion").toString();
					if (run.containsKey("lsmId")) {
						if (!run.get("lsmId").toString().isEmpty()) {
							lsmId = Integer.parseInt(run.get("lsmId").toString());
						}
					}
					if (lsmVersion.isEmpty() || lsmName.isEmpty()) {
						NeMappingModel neMappingModelversion = new NeMappingModel();
						CustomerDetailsEntity programDetailsEntityversion = new CustomerDetailsEntity();
						programDetailsEntityversion.setId(programId);
						neMappingModelversion.setProgramDetailsEntity(programDetailsEntityversion);
						neMappingModelversion.setEnbId(neId);
						neMappingEntitiesForVersion = runTestRepository.getNetWorkEntityDetails(neMappingModelversion);
						lsmId = neMappingEntitiesForVersion.getId();
						lsmVersion = neMappingEntitiesForVersion.getNeVersionEntity().getNeVersion();
						lsmName = neMappingEntitiesForVersion.getNeName();

					}
					NetworkConfigEntity networkConfigEntity = runTestRepository.getNeType(lsmId);

					NetworkConfigEntity neEntity = uploadFileServiceImpl.getNeEntity(lsmVersion, lsmName, programId);

					String migrationType = null;
					String migrationSubType = null;

					if (migType.equalsIgnoreCase(Constants.PRE_MIGRATION)) {
						migrationType = "PreMigration";
					} else if (migType.equalsIgnoreCase(Constants.POST_MIGRATION)) {
						migrationType = "PostMigration";
					}

					if ("precheck".equalsIgnoreCase(migSubType)) {
						migrationSubType = "PreCheck";
					} else if ("commission".equalsIgnoreCase(migSubType)) {
						migrationSubType = "Commission";
					} else if ("postcheck".equalsIgnoreCase(migSubType)) {
						migrationSubType = "PostCheck";
					} else if ("AUDIT".equalsIgnoreCase(migSubType)) {
						migrationSubType = "Audit";
					} else if ("RANATP".equalsIgnoreCase(migSubType)) {
						migrationSubType = "RanATP";
					} else if ("NESTATUS".equalsIgnoreCase(migSubType)) {
						migrationSubType = "NESTATUS";
					}
					String generateScriptPath = "";

					try {
						StringBuilder required5GOutput = new StringBuilder();
						StringBuilder required5GOutputEnb = new StringBuilder();
						LinkedHashMap<String, Set<XmlElementEntity>> elementrulesMap = new LinkedHashMap<>();
						StringBuilder generatedPath = new StringBuilder();
						generatedPath = generatedPath.append(LoadPropertyFiles.getInstance().getProperty("BASE_PATH"));
						generatedPath.append(Constants.CUSTOMER)
								.append(Constants.GENERATE_SCRIPT.replace("programId", sProgramId)
										.replace("migrationType", migrationType).replace("neId", neId)
										.replace("subType", migrationSubType));

						String finalStatusResult = "Success";
						int iUseCaseId = 0;
						Map<String, String> generateScriptMap = new HashMap<>();
						Map<String, String> scriptNameMap = new HashMap<>();
						if (scriptSeqDetails != null) {

							for (Map scriptInfoDetails : scriptSeqDetails) {
								String useGeneratedScriptsCheck = scriptInfoDetails.get("useGeneratedScript")
										.toString();
								String sScriptName = scriptInfoDetails.get("scriptName").toString();
								String useCaseNameInScript = scriptInfoDetails.get("useCaseName").toString();
								generateScriptMap.put(useCaseNameInScript + "_" + sScriptName,
										useGeneratedScriptsCheck);
								scriptNameMap.put(useCaseNameInScript + "_" + sScriptName, sScriptName);
							}
						}

						ArrayList scriptFinalLst = null;

						// Use case loop
						TreeSet<String> finalListFile = new TreeSet<>();
						scriptFinalLst = new ArrayList<ArrayList>();

						for (Map usecase : useCaseList) {
							Integer useCaseExeSeq = Integer.valueOf(usecase.get("executionSequence").toString());
							String useCaseName = (String) usecase.get("useCaseName");
							iUseCaseId = Integer.valueOf(usecase.get("useCaseId").toString());
							List<UseCaseBuilderParamEntity> scriptDetails = runTestRepository
									.getScriptDetails(iUseCaseId);

							Map<Integer, Integer> scriptIdAndSeqmap = new HashMap<>();
							for (UseCaseBuilderParamEntity scriptInfo : scriptDetails) {
								List scriptLst = new ArrayList<>();
								Integer scriptId = scriptInfo.getScriptsDetails().getId();

								int scriptUiExeSeq = getScriptExeSeq(scriptSeqDetails, scriptId);

								Integer scriptExeSeq = scriptUiExeSeq;

								Integer uploadedscriptId = scriptInfo.getId();
								if (scriptExeSeq != 0) {

									scriptLst.add(scriptId);
									scriptLst.add(scriptExeSeq);
									scriptLst.add(uploadedscriptId);
									scriptFinalLst.add(scriptLst);
									scriptIdAndSeqmap.put(scriptId, scriptExeSeq);

								}
							}

							// Script loop
							for (UseCaseBuilderParamEntity scriptEntity : scriptDetails) {

								Integer scriptId = scriptEntity.getScriptsDetails().getId();
								int scriptUiExeSeq = getScriptExeSeq(scriptSeqDetails, scriptId);
								Integer scriptExeSeq1 = scriptUiExeSeq;

								if (scriptExeSeq1 != 0) {
									int scriptExeSeq = scriptIdAndSeqmap.get(scriptId);

									UploadFileEntity uploadFileEntity = runTestRepository.getScriptInfo(scriptId);

									String dbcollectionFileName = CommonUtil
											.createMongoDbFileName(String.valueOf(programId), ciqFileName);
									String vznEnbIP = fileUploadRepository.getEnBDataByPath(dbcollectionFileName,
											Constants.VZ_GROW_IPPLAN, neId,
											Constants.ORAN_SPRINT_COMM_SCRIPT_eNB_OAM_IP_eNB_S_B_IP);
									String eNB_OAM_IP = fileUploadRepository.getEnBDataByPath(dbcollectionFileName,
											Constants.SPT_GROW_SHEET_FDD_TDD, neId,
											Constants.ORAN_SPRINT_COMM_SCRIPT_8_CHG_IP_ADDR);

									String enbIP = "127.0.0.1";

									if (StringUtils.isNotEmpty(vznEnbIP)) {
										enbIP = vznEnbIP;
									} else if (StringUtils.isNotEmpty(eNB_OAM_IP)) {
										String sprintEnbIP = CommonUtil.getLeftSubStringWithLen(eNB_OAM_IP, 3);
										if (StringUtils.isNotEmpty(sprintEnbIP)) {
											enbIP = sprintEnbIP;
										} else {
											enbIP = eNB_OAM_IP;
										}
									}

									String CSR_OAM_IP = fileUploadRepository.getEnBDataByPath(dbcollectionFileName,
											Constants.SPT_GROW_SHEET_FDD_TDD, neId,
											Constants.ORAN_SPRINT_COMM_SCRIPT_9_CSR_OAM_IP);

									NeMappingModel neMappingModel = new NeMappingModel();
									CustomerDetailsEntity programDetailsEntity = new CustomerDetailsEntity();
									programDetailsEntity.setId(programId);
									neMappingModel.setProgramDetailsEntity(programDetailsEntity);
									neMappingModel.setEnbId(neId);
									List<NeMappingEntity> neMappingEntities = neMappingService
											.getNeMapping(neMappingModel);

									String neType = Constants.NE_TYPE_ENB;
									if (uploadFileEntity.getFileName().contains(Constants.PRECHECK_CSR_FILE_NAME)
											|| uploadFileEntity.getFileName()
													.contains(Constants.POSTCHECK_CSR_FILE_NAME)) {
										enbIP = CommonUtil.getLeftSubStringWithLen(CSR_OAM_IP, 3);
										neType = Constants.NE_TYPE_CSR;
									} else if (uploadFileEntity.getFileName().contains(Constants.PRECHECK_BSM_FILE_NAME)
											|| uploadFileEntity.getFileName()
													.contains(Constants.POSTCHECK_BSM_FILE_NAME)) {
										enbIP = neMappingEntities.get(0).getBsmIp();
										neType = Constants.NE_TYPE_BSM;
									}

									String useGeneratedScriptsCheck = generateScriptMap
											.get(useCaseName + "_" + uploadFileEntity.getFileName());

									String[] scriptNameSplit = uploadFileEntity.getFileName().split("\\.");
									String checkLsmName = null;
									if (useGeneratedScriptsCheck != null
											&& "YES".equalsIgnoreCase(useGeneratedScriptsCheck.trim())) {
										File folder = new File(generatedPath.toString());
										if (!folder.exists()) {
											FileUtil.createDirectory(generatedPath.toString());
										}

										File[] listOfFiles = folder.listFiles();
										ArrayList<String> listOfFile = new ArrayList<>();
										if (listOfFiles.length > 0) {
											for (File file : listOfFiles) {
												listOfFile.add(file.getName());
											}

											String sLsmName = lsmName;
											String sUseCaseName = useCaseName;

											if (sLsmName.contains("_")) {
												sLsmName = charRemoveAt(sLsmName);
											}

											if (sUseCaseName.contains("_")) {
												sUseCaseName = charRemoveAt(sUseCaseName);
											}

											if (scriptNameSplit[0].contains("_")) {
												scriptNameSplit[0] = charRemoveAt(scriptNameSplit[0]);
											}

											sLsmName = sLsmName.replaceAll("\\s", "");
											sUseCaseName = sUseCaseName.replaceAll("\\s", "");
											scriptNameSplit[0] = scriptNameSplit[0].replaceAll("\\s", "");
											useCaseName = useCaseName.trim().replaceAll("\\s", "_");

											String filePathwithName = scriptExeSeq + "_" + sLsmName + "_" + sUseCaseName
													+ "_" + iUseCaseId + "_" + scriptNameSplit[0] + "_" + scriptId + "."
													+ scriptNameSplit[1];
											if (listOfFile.contains(filePathwithName)) {
												// do nothing
											} else {
												generateScriptWithOutExe5GAudit(neId, neName, sProgramId, migrationType,
														migrationSubType, uploadFileEntity, enbIP, neEntity,
														useCaseName, sessionId, lsmName, iUseCaseId, useCaseExeSeq,
														scriptId, scriptExeSeq, lsmId, useCurrPassword, sanePassword,
														userName, lsmVersion, ciqFileName, neType);
											}

										} else {
											generateScriptWithOutExe5GAudit(neId, neName, sProgramId, migrationType,
													migrationSubType, uploadFileEntity, enbIP, neEntity, useCaseName,
													sessionId, lsmName, iUseCaseId, useCaseExeSeq, scriptId,
													scriptExeSeq, lsmId, useCurrPassword, sanePassword, userName,
													lsmVersion, ciqFileName, neType);
										}

									} else {
										generateScriptWithOutExe5GAudit(neId, neName, sProgramId, migrationType,
												migrationSubType, uploadFileEntity, enbIP, neEntity, useCaseName,
												sessionId, lsmName, iUseCaseId, useCaseExeSeq, scriptId, scriptExeSeq,
												lsmId, useCurrPassword, sanePassword, userName, lsmVersion, ciqFileName,
												neType);
									}

									checkLsmName = lsmName;

									if (checkLsmName.contains("_")) {
										checkLsmName = charRemoveAt(checkLsmName);
									}

									checkLsmName = checkLsmName.replaceAll("\\s", "");

									File folder = new File(generatedPath.toString());
									File[] listOfFiles = folder.listFiles();

									if (listOfFiles.length > 0) {
										for (File file : listOfFiles) {
											String fileName = file.getName();
											if (fileName.contains(checkLsmName)
													&& fileName.contains(Integer.toString(iUseCaseId))
													&& fileName.contains(Integer.toString(scriptId))
													&& fileName.contains(Integer.toString(scriptExeSeq))) {
												finalListFile.add(fileName);
											} else {
												// do nothing
											}
										}
									}

								} else {
									// do nothing
								}
							}
						}

						Map<Integer, String> scriptExehashMap = new HashMap<>();

						for (String fileName : finalListFile) {

							String[] scriptExeSeq = fileName.split("_");
							int iScriptExeSeq = Integer.parseInt(scriptExeSeq[0]);

							scriptExehashMap.put(iScriptExeSeq, fileName);

						}

						Map<Integer, String> scriptexeSortedByExeSeqMap = scriptExehashMap.entrySet().stream()
								.sorted(Map.Entry.comparingByKey()).collect(Collectors.toMap(Map.Entry::getKey,
										Map.Entry::getValue, (e1, e2) -> e1, LinkedHashMap::new));

						// updating runTestEntity to update the generated script path before running the
						// run test
						mainloop1: for (Entry<Integer, String> file : scriptexeSortedByExeSeqMap.entrySet()) {
							String orderFileName = file.getValue();
							String fileNameWithPath = generatedPath.toString() + "/" + orderFileName;
							String filePathWithRunTestId = generatedPath.toString()
									+ runTestEntityMap.get(neId).getId();
							File dir = new File(filePathWithRunTestId);
							if (!dir.exists()) {
								FileUtil.createDirectory(filePathWithRunTestId);
							}
							FileUtils.copyFileToDirectory(new File(fileNameWithPath), dir);
							String filePath = filePathWithRunTestId.toString() + "/" + orderFileName;
							generateScriptPath = generateScriptPath
									+ filePath.replace(LoadPropertyFiles.getInstance().getProperty("BASE_PATH"), "")
									+ ",";

							if (StringUtils.isNotEmpty(generateScriptPath)) {
								runTestEntityMap.get(neId).setGenerateScriptPath(
										generateScriptPath.substring(0, generateScriptPath.length() - 1));
								runTestRepository.updateRunTest(runTestEntityMap.get(neId));
							}
						}

						Map<String, Boolean> createMapboo = new HashMap<>();
						AtomicBoolean sanePasswordBoo = new AtomicBoolean();
						sanePasswordBoo.set(true);
						String result1 = "FAIL";

						StringBuilder auditname = new StringBuilder();
						mainloop1: for (Entry<Integer, String> file : scriptexeSortedByExeSeqMap.entrySet()) {

							LocalDateTime lshtool1 = LocalDateTime.now();
							long dshsec = 0;

							String orderFileName = file.getValue();

							// for (String orderFileName : finalListFile) {

							String fileNameWithPath = generatedPath.toString() + "/" + orderFileName;
							String dbcollectionFileName = CommonUtil.createMongoDbFileName(String.valueOf(programId),
									ciqFileName);
							String vznEnbIP = fileUploadRepository.getEnBDataByPath(dbcollectionFileName,
									Constants.VZ_GROW_IPPLAN, neId,
									Constants.ORAN_SPRINT_COMM_SCRIPT_eNB_OAM_IP_eNB_S_B_IP);
							String eNB_OAM_IP = fileUploadRepository.getEnBDataByPath(dbcollectionFileName,
									Constants.SPT_GROW_SHEET_FDD_TDD, neId,
									Constants.ORAN_SPRINT_COMM_SCRIPT_8_CHG_IP_ADDR);
							String enbIP = "127.0.0.1";

							if (StringUtils.isNotEmpty(vznEnbIP)) {
								enbIP = vznEnbIP;
							} else if (StringUtils.isNotEmpty(eNB_OAM_IP)) {
								String sprintEnbIP = CommonUtil.getLeftSubStringWithLen(eNB_OAM_IP, 3);
								if (StringUtils.isNotEmpty(sprintEnbIP)) {
									enbIP = sprintEnbIP;
								} else {
									enbIP = eNB_OAM_IP;
								}
							}

							String output = "";
							String shelloutput = "";
							String outputFileName = "";
							String outputFileNameAudit = "";
							String outputFileNameResult = "";
							StringBuilder newOutputFileDBPath = new StringBuilder();
							StringBuilder newOutputFilePath = new StringBuilder();

							String[] useCaseNameSplit = orderFileName.split("_");
							int iScriptExeSeq = Integer.parseInt(useCaseNameSplit[0]);
							String useCaseName = useCaseNameSplit[2];
							int scriptId = Integer.parseInt(useCaseNameSplit[5].split("\\.")[0]);
							String descFinalPath = "";
							String scriptFileName = useCaseNameSplit[4];
							iUseCaseId = Integer.parseInt(useCaseNameSplit[3]);

							UseCaseBuilderEntity useCaseBuilderEntity = runTestRepository.getUseCaseEntity(iUseCaseId);
							String originalUseCaseName = useCaseBuilderEntity.getUseCaseName();

							UploadFileEntity scriptEntity = runTestRepository.getScriptInfo(scriptId);

							/// not included
							// swetha
							String scriptAbsFileName = LoadPropertyFiles.getInstance().getProperty("BASE_PATH")
									+ scriptEntity.getFilePath() + "/" + originalUseCaseName.trim().replaceAll(" ", "_")
									+ "/" + scriptEntity.getFileName();

							scriptFilesDetails.put(scriptAbsFileName, scriptEntity.getPrompt());

							StringBuilder outputFilePath = new StringBuilder();

							StringBuilder comFilePath = new StringBuilder();
							String scriptArguments = scriptEntity.getArguments();

							// Template changes starts
							String connectionLocationUserName = null;
							String connectionLocationPwd = "";
							String connectionSudoPassword = "";

							ProgramTemplateEntity programTemplateEntity = fileUploadRepository
									.getProgramTemplate(programId, Constants.SCRIPT_STORE_TEMPLATE);
							if (programTemplateEntity != null) {
								if (programTemplateEntity.getValue() != null
										&& !programTemplateEntity.getValue().trim().isEmpty()) {
									JSONObject objData = CommonUtil.parseDataToJSON(programTemplateEntity.getValue());
									HashMap connLocation = (HashMap) objData.get("connLocation");

									// NE
									HashMap ne = (HashMap) connLocation.get("NE");
									connectionSudoPassword = ne.get("sudoPassword").toString();
									connectionLocationUserName = ne.get("username").toString();
									connectionLocationPwd = ne.get("password").toString();

								}
							}
							String finalArguments = "";
							// Template changes end
							if (CommonUtil.isValidObject(scriptArguments) && StringUtils.isNotEmpty(scriptArguments)) {
								String[] arguments = scriptArguments.split(Constants.DELIMITER);
								if (CommonUtil.isValidObject(arguments) && arguments.length > 0) {
									for (String argument : arguments) {
										String argPreceeding = "";
										argument = argument.trim();
										if (argument.contains(" ") && argument.contains("-")
												&& argument.startsWith("-")) {
											argPreceeding = StringUtils.substringBefore(argument, " ");
											argPreceeding = argPreceeding.trim();
											argument = StringUtils.substringAfter(argument, " ");
											argument = argument.trim();
										}
										UserDetailsEntity userDetailsEntity = userActionRepositoryImpl
												.getUserDetailsBasedName(userName);
										String saneUserName = "";
										String sanePwd = "";
										if (CommonUtil.isValidObject(userDetailsEntity)) {
											saneUserName = userDetailsEntity.getVpnUserName();
										}
										if (useCurrPassword == true) {
											sanePwd = PasswordCrypt.decrypt(userDetailsEntity.getVpnPassword());
										} else {
											sanePwd = sanePassword;
										}
										String newArgument = commonUtil.getArgumentValue(Integer.toString(programId),
												ciqFileName, neId, neName, networkConfigEntity, migrationType,
												migrationSubType, argument, userName, sessionId,
												connectionLocationUserName, connectionLocationPwd,
												connectionSudoPassword, saneUserName, sanePwd);
										if (argPreceeding != null) {
											if (argPreceeding.trim().contains("-")) {
												finalArguments = finalArguments + " " + argPreceeding + " ";
											}
										}
										if (newArgument != null) {
											newArgument = "'" + newArgument + "'";
										}
										finalArguments = finalArguments + newArgument + " ";

									}
								}
							}
							comFilePath.append(LoadPropertyFiles.getInstance().getProperty("BASE_PATH"))
									.append(Constants.CUSTOMER).append(Constants.SEPARATOR).append(programId);

							if (migrationType.equalsIgnoreCase(Constants.POST_MIGRATION)
									|| migrationSubType.equalsIgnoreCase("NESTATUS")) {

								outputFilePath.append(comFilePath)
										.append(Constants.RUN_MIGRATION_OUTPUT.replace("migration", migrationType)
												.replace("enbId", StringUtils.substringBeforeLast(neId, "."))
												.replace("subtype", migrationSubType).replaceAll(" ", "_"));

								newOutputFilePath.append(comFilePath)
										.append(Constants.RUN_MIGRATION_OUTPUT.replace("migration", migrationType)
												.replace("enbId", StringUtils.substringBeforeLast(neId, "."))
												.replace("subtype", migrationSubType).replaceAll(" ", "_"))
										.append(testname).append("_").append(StringUtils.substringBeforeLast(neId, "."))
										.append("_").append(neName).append("/");

								newOutputFileDBPath.append(Constants.SEPARATOR).append(Constants.CUSTOMER)
										.append(Constants.SEPARATOR).append(programId).append(Constants.SEPARATOR)
										.append(Constants.RUN_MIGRATION_OUTPUT.replace("migration", migrationType)
												.replace("enbId", StringUtils.substringBeforeLast(neId, "."))
												.replace("subtype", migrationSubType).replaceAll(" ", "_"))
										.append(testname).append("_").append(StringUtils.substringBeforeLast(neId, "."))
										.append("_").append(neName).append("/");

								String timeStamp = new SimpleDateFormat("yyyy-MM-dd_HH:mm:ss").format(new Date());

								auditHtmlFileName.setLength(0);
								auditHtmlFileName.append("NEUPSTATUS_" + neId + "_" + serviceToken + ".txt");

								auditHtmlFilePath.setLength(0);
								auditHtmlFilePath.append(comFilePath)
										.append(Constants.RUN_MIGRATION_OUTPUT.replace("migration", migrationType)
												.replace("enbId", StringUtils.substringBeforeLast(neId, "."))
												.replace("subtype", migrationSubType).replaceAll(" ", "_"))
										.append(auditHtmlFileName.toString());

								File newFilePath = new File(newOutputFilePath.toString());
								newFilePath.mkdirs();

								File outFilePath = new File(outputFilePath.toString());
								outFilePath.mkdirs();

								outputFileNameResult = auditHtmlFilePath.toString();
								outputFileNameAudit = outputFilePath + serviceToken + "_" + "output.txt";
								if ("NESTATUS".equalsIgnoreCase(migrationSubType)) {
									// subtype = "Audit"; Audit

									String endName = "";
									if (StringUtils.isNotEmpty(scriptEntity.getFileName())) {
										endName = scriptEntity.getFileName().substring(0,
												scriptEntity.getFileName().indexOf('_'));
									}

									if (scriptEntity.getFileName().contains(XmlCommandsConstants.DSS_VDU_NEUP_USECASE)
											|| scriptEntity.getFileName()
													.contains(XmlCommandsConstants.CBAND_VDU_NEUP_USECASE)
											|| scriptEntity.getFileName()
													.contains(XmlCommandsConstants.IAU_NEUP_USECASE)
											|| scriptEntity.getFileName()
													.contains(XmlCommandsConstants.AUDIT_4G_NEUP_USECASE)
											|| scriptEntity.getFileName()
													.contains(XmlCommandsConstants.AUDIT4G_NEUP_USECASE)
											|| scriptEntity.getFileName()
													.contains(XmlCommandsConstants.AU_NEUP_USECASE)) {
										shelloutput = neUpStatusUtil.getNEUpResponse(scriptEntity, "", neId,
												dbcollectionFileName, networkConfigEntity, useCurrPassword,
												sanePassword, neEntity, sProgramId, migrationType, originalUseCaseName,
												ciqFileName, userName, outputFileNameAudit, createMapboo,
												required5GOutput, isMultipleDUo, outputFileNameResult);
									} else if (scriptEntity.getFileName()
											.contains(XmlCommandsConstants.AUDIT_4G_FIRMWARECHECK)
											|| scriptEntity.getFileName()
													.contains(XmlCommandsConstants.DSS_VDU_FIRMWARECHECK)
											|| scriptEntity.getFileName()
													.contains(XmlCommandsConstants.CBAND_VDU_FIRMWARECHECK)
										    || scriptEntity.getFileName()
													.contains(XmlCommandsConstants.IAU_FIRMWARECHECK)
											|| scriptEntity.getFileName()
													.contains(XmlCommandsConstants.AU_FIRMWARECHECK)
											|| scriptEntity.getFileName()
													.contains(XmlCommandsConstants.AUDIT4G_FIRMWARECHECK)) {
										shelloutput = neUpStatusUtil.getFirmWareCheck(scriptEntity, "", neId,
												dbcollectionFileName, networkConfigEntity, useCurrPassword,
												sanePassword, neEntity, sProgramId, migrationType, originalUseCaseName,
												ciqFileName, userName, outputFileNameAudit, createMapboo,
												required5GOutput, isMultipleDUo, outputFileNameResult);
									} else {
										if (sanePasswordBoo.get()) {
											LocalDateTime lsh1 = LocalDateTime.now();
											JSONObject duoData = isDuoApplicable(scriptEntity, networkConfigEntity,
													useCurrPassword, sanePassword);
											if (duoData.containsKey("status")
													&& duoData.get("status").equals(Constants.SUCCESS)) {
												JSONObject resultCurlCommand = getCurlCommandAudit(neId, sProgramId,
														migrationType, scriptEntity, neEntity, originalUseCaseName,
														ciqFileName);
												if (resultCurlCommand.containsKey("status")
														&& resultCurlCommand.get("status").equals(Constants.SUCCESS)) {
													String tempCommand = resultCurlCommand.get("command").toString();
													System.out.println("--------------Command --------------");
													System.out.println(tempCommand);
													System.out.println("--------------Command --------------");
													shelloutput = duoSession(userName, outputFileNameAudit,
															scriptEntity.getFileName(), duoData, tempCommand);
												} else if (resultCurlCommand.containsKey("reason")) {
													shelloutput = resultCurlCommand.get("reason").toString();
												}

											} else if (!duoData.containsKey("reason")) {
												shelloutput = executeCommand5GAudit(fileNameWithPath,
														outputFileNameAudit, finalArguments, "");
											} else {
												shelloutput = duoData.get("reason").toString();
											}
											// shelloutput = returnshellop(scriptEntity.getFileName());
											LocalDateTime lsh2 = LocalDateTime.now();
											dshsec = Duration.between(lsh1, lsh2).getSeconds();
											if (dshsec > Constants.SSH_TIMEOUT && !shelloutput.contains("<rpc-reply")
													&& !shelloutput.contains("</rpc-reply>")) {
												shelloutput = shelloutput + "\n\nMessage from SRCT : SSH Timeout";
											}
											logger.error("Duration for script in server : " + scriptEntity.getFileName()
													+ " NE : " + neId + "(HH:mm:ss) : " + String.format("%d:%02d:%02d",
															dshsec / 3600, (dshsec % 3600) / 60, dshsec % 60));
										}

										if (shelloutput.contains("spawn id exp")) {
											sanePasswordBoo.set(false);
										}
										if (shelloutput.contains("<rpc-reply")
												&& !(shelloutput.contains("<rpc-error"))) {
											createMapboo.put(FilenameUtils.removeExtension(scriptEntity.getFileName()),
													true);
										} else {
											createMapboo.put(FilenameUtils.removeExtension(scriptEntity.getFileName()),
													false);
										}

										String dataOutput = getRequiredOutPut5GAudit(shelloutput,
												scriptEntity.getFileName());
										required5GOutput.append(dataOutput);
										required5GOutput.append("/n");
									}
								}

								String path = LoadPropertyFiles.getInstance().getProperty("BASE_PATH") + "Customer/"
										+ programId + "/" + migrationType + "/" + neId + "/" + migrationSubType + "/"
										+ "Output" + "/";

								File duplicatePath = new File(path);
								duplicatePath.mkdirs();

								if ("NESTATUS".equalsIgnoreCase(migrationSubType)) {

									timeStamp = new SimpleDateFormat("MMddyyyy_HH_mm_ss")
											.format(new Timestamp(System.currentTimeMillis()));
									String newOutputFileName = serviceToken + "_" + useCaseName + "_" + scriptFileName
											+ "_" + timeStamp + ".txt";
									descFinalPath = newOutputFilePath.toString() + newOutputFileName;
									FileWriter fileWriter = new FileWriter(descFinalPath);
									fileWriter.write(shelloutput);
									fileWriter.close();
								}
								CommonUtil.removeCtrlChars(descFinalPath);

							}
							UseCaseBuilderParamEntity useCaseBuilderParamEntity = null;

							for (int j = 0; j < scriptFinalLst.size(); j++) {
								ArrayList scritlst = (ArrayList) scriptFinalLst.get(j);
								int scriptID = (int) scritlst.get(0);

								if (scriptID == scriptEntity.getId()) {
									int scrpitid12 = (int) scritlst.get(2);
									useCaseBuilderParamEntity = useCaseBuilderRepository
											.getUseCaseBuilderParamEntity(scrpitid12);
									break;
								}
							}
							if (createMapboo.containsKey(FilenameUtils.removeExtension(scriptEntity.getFileName()))) {
								if (createMapboo.get(FilenameUtils.removeExtension(scriptEntity.getFileName()))) {
									result1 = "PASS";
								} else {
									result1 = "FAIL";
								}
							}

							RunTestEntity runTestEntity = runTestEntityMap.get(neId);

							UseCaseBuilderEntity useCaseBuilderEntitybyId = useCaseBuilderService
									.getUseCaseBuilderEntity(iUseCaseId);

							UploadFileEntity uploadFileEntity = uploadFileRepository.getUploadFileEntity(scriptId);
							ConcurrentHashMap<Integer, List<RunTestResultEntity>> runtestResultEntityListMap = new ConcurrentHashMap<>();
							RunTestResultEntity runTestResultEntity = new RunTestResultEntity();
							runTestResultEntity.setRunTestEntity(runTestEntity);

							runTestResultEntity.setUseCaseBuilderEntity(useCaseBuilderEntitybyId);
							runTestResultEntity.setUploadFileEntity(uploadFileEntity);

							runTestResultEntity.setCurrentResult(result1);
							runTestResultEntity.setCurrentScriptOutput(newOutputFileDBPath.toString());
							runTestResultEntity.setCustomerDetailsEntity(customerDetailsEntity);
							runTestResultEntity.setMigrationType(migrationType);
							runTestResultEntity.setMigrationSubType(migrationSubType);
							runTestResultEntity.setNeName(neId);
							runTestResultEntity.setScriptExeSeq(iScriptExeSeq);
							if (runtestResultEntityListMap.containsKey(scriptId)) {
								runtestResultEntityListMap.get(scriptId).add(runTestResultEntity);
							} else {
								List<RunTestResultEntity> runtestResultEntityList = new ArrayList<>();
								runtestResultEntityList.add(runTestResultEntity);
								runtestResultEntityListMap.put(scriptId, runtestResultEntityList);
							}

							runTestResultRepository.createRunTestResult(runTestResultEntity);

							List<RunTestResultEntity> resultList = runtestResultEntityListMap.get(scriptId);
							boolean status = false;
							for (RunTestResultEntity runTestResultEntity1 : resultList) {
								if (runTestResultEntity1.getCurrentResult().equalsIgnoreCase("PASS")) {
									status = true;
								} else {
									status = false;
									break;
								}
							}
							if (!result1.equals("PASS")) {
								break;
							}
							LocalDateTime lshtool2 = LocalDateTime.now();
							long dshtool = Duration.between(lshtool1, lshtool2).getSeconds() - dshsec;
							logger.error("Duration for script in tool : " + scriptEntity.getFileName() + " NE : " + neId
									+ "(HH:mm:ss) : " + String.format("%d:%02d:%02d", dshtool / 3600,
											(dshtool % 3600) / 60, dshtool % 60));
						}

						StringBuilder comFilePath = new StringBuilder();
						comFilePath.append(LoadPropertyFiles.getInstance().getProperty("BASE_PATH"))
								.append(Constants.CUSTOMER).append(Constants.SEPARATOR).append(programId);

						StringBuilder outputFilePath = new StringBuilder();

						outputFilePath.append(comFilePath)
								.append(Constants.RUN_MIGRATION_OUTPUT.replace("migration", migrationType)
										.replace("enbId", StringUtils.substringBeforeLast(neId, "."))
										.replace("subtype", migrationSubType).replaceAll(" ", "_"));

						String outputFileName = outputFilePath + serviceToken + "_" + "output.txt";

						CommonUtil.removeCtrlChars(outputFileName);
						String programName = customerDetailsEntity.getProgramName();

						int ucsleep = getUCSleepInterval(useCaseList, iUseCaseId);

						Thread.sleep(ucsleep);
						String fileSavePath = StringUtils.substringBeforeLast(auditHtmlFilePath.toString(), "/");
						fileSavePath = fileSavePath.replace(LoadPropertyFiles.getInstance().getProperty("BASE_PATH"),
								"");
						if (createMapboo.isEmpty()) {
							auditHtmlFileName.setLength(0);
							fileSavePath = "";
						}
						if (!sanePasswordBoo.get() || !result1.equalsIgnoreCase("PASS")) {
							finalStatusResult = FAILURE;
						}
						runTestEntityMap.get(neId).setResult(auditHtmlFileName.toString());
						runTestEntityMap.get(neId).setResultFilePath(fileSavePath + "/" + auditHtmlFileName.toString());
						runTestEntityMap.get(neId).setProgressStatus("Completed");
						runTestEntityMap.get(neId).setStatus(finalStatusResult);

						if (totalTestCompleted.get()) {
							runTestEntityMap.get(neId).setFailedScript("true");
							;
						} else {
							runTestEntityMap.get(neId).setFailedScript("false");
							;
						}

						if (StringUtils.isNotEmpty(generateScriptPath)) {
							runTestEntityMap.get(neId).setGenerateScriptPath(
									generateScriptPath.substring(0, generateScriptPath.length() - 1));
						}
						runTestRepository.updateRunTest(runTestEntityMap.get(neId));

						if (run.containsKey("trackerId")) {
							OvScheduledEntity ovScheduledEntity = ovScheduledTaskService
									.getOvScheduledServiceDetails(run.get("trackerId").toString(), neId);

							ovScheduledEntity.setPostMigAuditStatus(finalStatusResult);
							if (finalStatusResult.equals("Success")) {
								// ovScheduledEntity = fetchProcessService.statusUpdateApi(ovScheduledEntity,
								// "PostMigration","",runTestParams.get("programName").toString());
							}
							ovScheduledEntity = ovScheduledTaskService.mergeOvScheduledDetails(ovScheduledEntity);
						}

					} catch (Exception e) {
						runTestEntityMap.get(neId).setProgressStatus("Completed");
						runTestEntityMap.get(neId).setStatus(FAILURE);
						runTestRepository.updateRunTest(runTestEntityMap.get(neId));
						logger.error("Exception RunTestServiceImpl in getRuntestExecResultNeUp() "
								+ ExceptionUtils.getFullStackTrace(e));
					}
					LocalDateTime l2 = LocalDateTime.now();
					logger.error("Completed the thread for NE " + neId + " at : " + l2);
					long duthreadsec = Duration.between(l1, l2).getSeconds();
					logger.error("Duration for thread for NE " + neId + " (HH:mm:ss) : " + String.format("%d:%02d:%02d",
							duthreadsec / 3600, (duthreadsec % 3600) / 60, duthreadsec % 60));
					GlobalStatusMap.userNeQueue.get(userDetailsEntity2.getVpnUserName()).remove(neId);
					return Constants.SUCCESS;

				});
			}

			executorservice.shutdown();
		}

		catch (

		Exception e) {
			logger.error("Exception RunTestServiceImpl in getRuntestExecResultNeUp() "
					+ ExceptionUtils.getFullStackTrace(e));

			return e.getMessage();
		}

		return Constants.SUCCESS;

	}
	@Override
	public String loadneOplogs(Integer runTestId) {

		return runTestRepository.loadneOplogs(runTestId);
	}
	// For Testing
	/*private String returnshellop(String name) {
		String fullOutputLog = "";
		try {
			fullOutputLog = new String(Files.readAllBytes(Paths.get("/home/user/Desktop/Responses/" + name)));
		} catch (IOException e) {
			System.out.println(e);
		} finally {
			return fullOutputLog;
		}
	}*/
}
